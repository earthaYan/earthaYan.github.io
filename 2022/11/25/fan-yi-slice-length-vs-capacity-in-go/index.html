<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="翻译-Slice length vs. capacity in Go" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary | just try it</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">默奥沙</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            翻译-Slice length vs. capacity in Go
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%88%87%E7%89%87-length-%E5%92%8C-capacity"><span class="post-toc-text">Go 语言中的切片 length 和 capacity</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-text">总结</span></a></li></ol></li></ol>
        
        <p>原文地址：<a target="_blank" rel="noopener" href="https://teivah.medium.com/slice-length-vs-capacity-in-go-af71a754b7d8">https://teivah.medium.com/slice-length-vs-capacity-in-go-af71a754b7d8</a></p>
<h1 id="Go-语言中的切片-length-和-capacity"><a href="#Go-语言中的切片-length-和-capacity" class="headerlink" title="Go 语言中的切片 length 和 capacity"></a>Go 语言中的切片 length 和 capacity</h1><p><b>长话短说</b>:切片长度是指切片中可访问元素的数量,而切片容量是指从切片第一个元素开始,数组中元素的数量。</p>
<hr>
<p>Go 开发者混淆或者没有完全理解切片 length 和 capacity 的现象非常普遍。理解这两个概念有利于高效地处理一些核心操作,比如初始化切片,使用 append 添加元素,复制,截取。而这种错误理解会导致切片滥用甚至内存泄漏。</p>
<p>在 Go 语言中, slice 是由数组返回的。这意味着切片的数据是持久化的存在一个数组形式的数据结构中。如果数组满了，切片可以处理添加元素的逻辑,或者如果数组几乎是空的话,切片也可以处理缩小数组的逻辑。</p>
<p>在计算机内部, 切片包含一个指向数组的指针,一个 length 属性和一个 capacity 属性。length 是切片包含的元素个数,而 capacity 是从切片第一个元素开始计算的后备数组的元素个数。让我们通过一些例子来让事情更清晰一些。首先通过给定的 length 和 capacity 初始化切片：</p>
<pre><code class="go">s := make([]int, 3, 6)  /// length 3, 容量 6 的切片
</code></pre>
<p>代表 length 的第一个参数是必须的，但是代表 capacity 的第二个参数是可选参数。图 1 展示了这段代码在内存中的执行结果。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice.webp" class="" title="图1-一个长度3，容量6的切片">

<p>这个例子里,<code>make</code> 创建了一个 6(capacity) 个元素的数组。但是因为 length 被设置为 3, 所以 Go 只初始化了前 3 个元素。而且由于 slice 被设置为 <code>[]int</code> 类型，所以前三个元素的初始值被设置为 <code>int</code> 的零值: 0。灰色元素是已经分配但还没被使用。</p>
<p>我们打印这个切片,可以得到 length 范围内的元素: <code>[0,0,0]</code>。如果我们设置 <code>s[1]</code> 为 1,切片的第二个元素会被修改，但是不会影响它的 length 和 capacity。图 2 说明了这一点。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice_update.webp" class="" title="图2——更新切片第二个元素:s[1]&#x3D;1">

<p>但是, length 范围以外的元素即使已经在内存中分配了空间已经也是禁止访问的。举个例子, <code>s[4]=0</code> 就会引发下面的报错:</p>
<blockquote>
<p>panic: runtime error: index out of range [4] with length 3</p>
</blockquote>
<p>那我们怎样使用切片的剩余空间呢?答案是通过内置的 <code>append</code> 方法:</p>
<pre><code class="go">s = append(s, 2)
</code></pre>
<p>这行代码会追加一个新的元素到已经存在的 <code>s</code> 切片。如图 3 所示,他会使用第一个灰色元素(已经被分配空间但还未使用)来存储元素 <code>2</code></p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice_3.webp" class="" title="图3——追加元素到s">

<p>此时切片的 length 会从 3 更新到 4,因为切片现在包含了 4 个元素。如果我们现在再追加 3 个元素,让背后的数组不够大的话会发生什么呢?</p>
<pre><code class="go">s=append(s,3,4,5)
fmt.Println(s)
</code></pre>
<p>运行这段代码,我们看到切片依然能够处理我们的请求:</p>
<blockquote>
<p>[0 1 0 2 3 4 5]</p>
</blockquote>
<p>数组是大小固定的结构,所以只能存储新元素到 4 。当我们想要插入元素 5 的时候,数组已经满了:此时 Go 会在内部另外创建一个数组：capacity 是原来的两倍,拷贝原数组中的所有元素,然后插入元素 5。图 4 展示了这个过程。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/new.webp" class="" title="图4——初始数组已满,GO创建了另一个数组并复制了所有的元素">

<p>切片现在指向了新的后备数组。那之前的后备数组会发生什么呢?如果堆中分配了空间,且它不再被引用,那么最终会被垃圾收集器(GC)释放。(我们在 #95 错误中讨论了堆内存:”<a target="_blank" rel="noopener" href="https://livebook.manning.com/book/100-go-mistakes-and-how-to-avoid-them/chapter-12/240">不理解栈和堆</a>“,并且在 #99 错误中学习了 GC 是如何工作的。)</p>
<p>截取切片会发生什么呢?截取是在数组或切片执行的操作,提供了半开区间范围。索引 1 是被包含的,而索引 2 是不被包含的。接下来的例子展示了这个影响，图 5 展示了内存中的结果：</p>
<pre><code class="go">s1 := make([]int,3,6)
s2 := s1[1:3] //截取自索引1~3
</code></pre>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slicing.webp" class="" title="图5——s1和s2以不同的length和capacity引用了同一个后备数组">

<p>首先 <code>s1</code> 作为 length 3 和 capacity 6 的切片被创建。当通过截取 <code>s1</code> 创建 <code>s2</code> 时,两个切片引用了同一个后备数组。但是 <code>s2</code> 是从索引 1 开始的。因此它的 length 和 capacity 和 s1 是不一样的(length 等于 2,capacity 为 5)。如果我们修改 <code>s1[0]</code> 或者 <code>s2[0]</code>,这个修改是作用域同一个数组的,因此会如图 6 所示在两个切片中都是可见的。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/visible_change.webp" class="" title="图6——因为s1和s2共用一个后备数组，所以修改一个元素会使得两个切片都会产生变化">

<p>现在如果我们追加一个元素到 <code>s2</code> 会发生什么呢?接下来的代码也会修改 <code>s1</code> 么?</p>
<pre><code class="go">s2 = append(s2, 2)
</code></pre>
<p>共享的后备数组会被修改,但是只有 <code>s2</code> 的 length 变了。图 7 展示了追加元素到 <code>s2</code> 的结果。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/append.webp" class="" title="图7——追加一个元素到s2">

<p><code>s1</code> 仍然是一个 length 为 3,capacity 为 6 的切片。因此如果打印 <code>s1</code> 和 <code>s2</code>,添加的元素只在 <code>s2</code>中可见：</p>
<blockquote>
<p>s1&#x3D;[0 1 0], s2&#x3D;[1 0 2]</p>
</blockquote>
<p>理解这个行为非常重要，这样我们在使用 append 的时候不会做出错误的假设。</p>
<p>【注意】：在这些例子中,后备数组都是内部创建, GO 开发者不能直接获取。唯一的例外是：切片是从对现有数组进行切片创建的。</p>
<p>最后需要注意的一点是:假使我们一直追加元素到 s2 到后备数组变满会怎么样呢?就智能内存而言状态会是什么样? 让我们再添加 3 个元素，这样后备数组就不会有剩余的容量了：</p>
<pre><code class="go">s2 = append(s2, 3)
s2 = append(s2, 4) // At this stage, the backing is already full
s2 = append(s2, 5)
</code></pre>
<p>这段代码会使得 GO 创建另一个后备数组。图 8 展示了内存中的结果。</p>
<img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/figure8.webp" class="" title="图8——向s2追加元素直至后备元素没有剩余空间">

<p>此时 s1 和 s2 指向了两个不同的数组。因为 s1 依旧 length 为 3,capacity 为 6,仍然有可用的缓存空间，所以它还是引用原来的数组。同时，新的后备数组通过从 s2 的第一个索引开始复制原数组创建。这就是为什么新数组从元素 1 而不是从元素 0 开始。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说, slice length 是切片中可用元素的个数,而 slice capacity 是后备数组中元素个数。向一个满切片(length &#x3D;&#x3D; capacity) 添加元素会创建一个新后备数组,这个数组拥有新的 capacity,然后从之前的数组中复制所有元素，修改切片指针指向新的数组。</p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2022-11-25</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/GoLang/'>
                            GoLang
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%BF%BB%E8%AF%91/'>
                            翻译
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>