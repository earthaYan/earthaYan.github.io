<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="gin-web笔记" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">备忘录/笔记本</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            gin-web笔记
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%89%E8%A3%85"><span class="post-toc-text">安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="post-toc-text">快捷方式：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#AsciiJSON"><span class="post-toc-text">AsciiJSON</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#html-%E6%B8%B2%E6%9F%93"><span class="post-toc-text">html 渲染</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-html-%E6%A8%A1%E6%9D%BF"><span class="post-toc-text">自定义 html 模板</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP2-server-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%8E%A8%E9%80%81"><span class="post-toc-text">HTTP2 server 服务器 推送</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JSONP"><span class="post-toc-text">JSONP</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Multipart-x2F-Urlencoded-%E7%BB%91%E5%AE%9A"><span class="post-toc-text">Multipart&#x2F;Urlencoded 绑定</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Multipart-x2F-Urlencoded-%E8%A1%A8%E5%8D%95"><span class="post-toc-text">Multipart&#x2F;Urlencoded 表单</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AF%B9%E7%89%B9%E6%AE%8A-HTML-%E5%AD%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E2%80%94%E2%80%94PureJSON"><span class="post-toc-text">对特殊 HTML 字符进行编码——PureJSON</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Query-%E5%92%8C-post-form"><span class="post-toc-text">Query 和 post form</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%98%B2%E6%AD%A2-JSON-%E5%8A%AB%E6%8C%81%E2%80%94%E2%80%94SecureJSON"><span class="post-toc-text">防止 JSON 劫持——SecureJSON</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-%E6%B8%B2%E6%9F%93"><span class="post-toc-text">XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6"><span class="post-toc-text">上传文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6"><span class="post-toc-text">单文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6"><span class="post-toc-text">多文件</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="post-toc-text">不使用默认的中间件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E-reader-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="post-toc-text">从 reader 读取数据</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%87%8D%E5%90%AF%E6%88%96%E5%81%9C%E6%AD%A2-web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="post-toc-text">重启或停止 web 服务器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-BasicAuth-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="post-toc-text">使用 BasicAuth 中间件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-http-%E6%96%B9%E6%B3%95"><span class="post-toc-text">使用 http 方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="post-toc-text">使用中间件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84"><span class="post-toc-text">路由组</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%AA%E7%BB%91%E5%AE%9A-url-%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">只绑定 url 查询字符串</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%9C%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8-go-routine"><span class="post-toc-text">在中间件使用 go routine</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="post-toc-text">记录日志</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="post-toc-text">定义路由日志的格式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%B0%86-request-body-%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD"><span class="post-toc-text">将 request body 绑定到不同的结构体中</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E9%A2%9C%E8%89%B2"><span class="post-toc-text">控制日志输出颜色</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%98%A0%E5%B0%84%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%96%E8%A1%A8%E5%8D%95%E5%8F%82%E6%95%B0"><span class="post-toc-text">映射查询字符串或表单参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%82%E6%95%B0"><span class="post-toc-text">查询字符串参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#model-binding-%E7%BB%91%E5%AE%9A%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="post-toc-text">model binding 绑定和验证</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%91%E5%AE%9A-uri"><span class="post-toc-text">绑定 uri</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%91%E5%AE%9A%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%96%E8%80%85%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="post-toc-text">绑定查询字符串或者表单数据</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89-struct"><span class="post-toc-text">绑定表单数据到自定义 struct</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-http-%E9%85%8D%E7%BD%AE"><span class="post-toc-text">自定义 http 配置</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="post-toc-text">自定义中间件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81"><span class="post-toc-text">自定义验证</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%BE%E7%BD%AE-x2F-%E8%8E%B7%E5%8F%96-cookie"><span class="post-toc-text">设置&#x2F;获取 cookie</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0"><span class="post-toc-text">路由参数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84-1"><span class="post-toc-text">路由组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1"><span class="post-toc-text">运行多个服务</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="post-toc-text">重定向</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get%E9%87%8D%E5%AE%9A%E5%90%91"><span class="post-toc-text">get重定向</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#post-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="post-toc-text">post 重定向</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91"><span class="post-toc-text">路由重定向</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6"><span class="post-toc-text">静态文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%B5%8C%E5%85%A5"><span class="post-toc-text">静态资源嵌入</span></a></li></ol>
        
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">go get -u github.com/gin-gonic/gin
</code></pre>
<p>Gin 默认使用<code>encoding/json</code>进行编译</p>
<h2 id="快捷方式："><a href="#快捷方式：" class="headerlink" title="快捷方式："></a>快捷方式：</h2><ul>
<li>gin.H 是 map[string]interface{}的快捷方式</li>
<li>gin.Accounts 是 map[string]string 的一种快捷方式</li>
</ul>
<h2 id="AsciiJSON"><a href="#AsciiJSON" class="headerlink" title="AsciiJSON"></a>AsciiJSON</h2><p>使用 AsciiJSON 生成具有转义的非 ASCII 字符的 ASCII-only JSON。<br>原数据：</p>
<pre><code class="go">data := map[string]interface&#123;&#125;&#123;
  &quot;lang&quot;: &quot;GO语言&quot;,
  &quot;tag&quot;:  &quot;&lt;br&gt;&quot;,
&#125;
// 输出data:&#123;&quot;lang&quot;:&quot;GO\u8bed\u8a00&quot;,&quot;tag&quot;:&quot;\u003cbr\u003e&quot;&#125;
c.AsciiJSON(http.StatusOK, data)
</code></pre>
<h2 id="html-渲染"><a href="#html-渲染" class="headerlink" title="html 渲染"></a>html 渲染</h2><p>使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code></p>
<pre><code class="tmpl">&lt;!-- templates/index.tmpl --&gt;
&lt;html&gt;
    &lt;h1&gt;
        &#123;&#123; .title &#125;&#125;
    &lt;/h1&gt;
&lt;/html&gt;
&lt;!-- templates/posts/index.tmpl --&gt;
&#123;&#123; define "posts/index.tmpl" &#125;&#125;
&lt;html&gt;&lt;h1&gt;
    &#123;&#123; .title &#125;&#125;
&lt;/h1&gt;
&lt;p&gt;Using posts/index.tmpl&lt;/p&gt;
&lt;/html&gt;
&#123;&#123; end &#125;&#125;
&lt;!-- templates/users/index.tmpl --&gt;
&#123;&#123; define "users/index.tmpl" &#125;&#125;
&lt;html&gt;&lt;h1&gt;
    &#123;&#123; .title &#125;&#125;
&lt;/h1&gt;
&lt;p&gt;Using users/index.tmpl&lt;/p&gt;
&lt;/html&gt;
&#123;&#123; end &#125;&#125;
</code></pre>
<p>如何使用模板：</p>
<pre><code class="go">    router.LoadHTMLGlob(&quot;templates/**/*&quot;)
  //router.LoadHTMLFiles(&quot;templates/template1.html&quot;, &quot;templates/template2.html&quot;)
  // 使用不同目录下的相同名称的模板
    router.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;
        c.HTML(http.StatusOK, &quot;posts/index.tmpl&quot;, gin.H&#123;
            &quot;title&quot;: &quot;Posts&quot;,
        &#125;)
    &#125;)
    router.GET(&quot;/users/index&quot;, func(c *gin.Context) &#123;
        c.HTML(http.StatusOK, &quot;users/index.tmpl&quot;, gin.H&#123;
            &quot;title&quot;: &quot;Users&quot;,
        &#125;)
    &#125;)
</code></pre>
<h3 id="自定义-html-模板"><a href="#自定义-html-模板" class="headerlink" title="自定义 html 模板"></a>自定义 html 模板</h3><p>暂忽略</p>
<h2 id="HTTP2-server-服务器-推送"><a href="#HTTP2-server-服务器-推送" class="headerlink" title="HTTP2 server 服务器 推送"></a>HTTP2 server 服务器 推送</h2><p>服务器推送：还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了 index.html，但是服务器把 index.html、style.css、example.png 全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能</p>
<pre><code class="go">var html = template.Must(template.New(&quot;https&quot;).Parse(`
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Https Test&lt;/title&gt;
  &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 style=&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
`))
r.GET(&quot;/&quot;, func(c *gin.Context) &#123;
  if pusher := c.Writer.Pusher(); pusher != nil &#123;
    // 使用 pusher.Push() 做服务器推送
    if err := pusher.Push(&quot;/assets/app.js&quot;, nil); err != nil &#123;
      log.Printf(&quot;Failed to push: %v&quot;, err)
    &#125;
  &#125;
  c.HTML(200, &quot;https&quot;, gin.H&#123;
    &quot;status&quot;: &quot;success&quot;,
  &#125;)
&#125;)
</code></pre>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>用来解决跨域问题:如果查询参数存在回调，则将回调添加到响应体中</p>
<pre><code class="go">data := map[string]interface&#123;&#125;&#123;
  &quot;foo&quot;: &quot;bar&quot;,
&#125;
// 请求：/JSONP?callback=x
// 输出data:x(&#123;\&quot;foo\&quot;:\&quot;bar\&quot;&#125;)
c.JSONP(http.StatusOK, data)
</code></pre>
<h2 id="Multipart-x2F-Urlencoded-绑定"><a href="#Multipart-x2F-Urlencoded-绑定" class="headerlink" title="Multipart&#x2F;Urlencoded 绑定"></a>Multipart&#x2F;Urlencoded 绑定</h2><pre><code class="go">type LoginForm struct &#123;
    User     string `form:&quot;user&quot; binding:&quot;required&quot;`
    Password string `form:&quot;password&quot; binding:&quot;required&quot;`
&#125;
// 显式绑定声明绑定multipart form：
c.ShouldBindWith(&amp;form, binding.Form)
// 使用ShouldBind 方法自动绑定
var form LoginForm
if c.ShouldBind(&amp;form) == nil &#123;
  if form.User == &quot;user&quot; &amp;&amp; form.Password == &quot;password&quot; &#123;
    c.JSON(200, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)
  &#125; else &#123;
    c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)
  &#125;
&#125;
// curl测试
// curl -v --form user=user --form password=password http://localhost:8080/login
</code></pre>
<h2 id="Multipart-x2F-Urlencoded-表单"><a href="#Multipart-x2F-Urlencoded-表单" class="headerlink" title="Multipart&#x2F;Urlencoded 表单"></a>Multipart&#x2F;Urlencoded 表单</h2><pre><code class="go">    router.POST(&quot;/form_post&quot;, func(c *gin.Context) &#123;
        message := c.PostForm(&quot;message&quot;)
        nick := c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)
        c.JSON(200, gin.H&#123;
            &quot;status&quot;:  &quot;posted&quot;,
            &quot;message&quot;: message,
            &quot;nick&quot;:    nick,
        &#125;)
    &#125;)
</code></pre>
<h2 id="对特殊-HTML-字符进行编码——PureJSON"><a href="#对特殊-HTML-字符进行编码——PureJSON" class="headerlink" title="对特殊 HTML 字符进行编码——PureJSON"></a>对特殊 HTML 字符进行编码——PureJSON</h2><p>JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \ u003c。如果要按字面对这些字符进行编码，则可以使用 PureJSON</p>
<pre><code class="go">// 提供 unicode 实体
r.GET(&quot;/json&quot;, func(c *gin.Context) &#123;
  c.JSON(200, gin.H&#123;
    &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;,
  &#125;)
&#125;)
// 提供字面字符
r.GET(&quot;/pureJson&quot;, func(c *gin.Context) &#123;
  c.PureJSON(200, gin.H&#123;
    &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;,
  &#125;)
&#125;)
</code></pre>
<h2 id="Query-和-post-form"><a href="#Query-和-post-form" class="headerlink" title="Query 和 post form"></a>Query 和 post form</h2><p>请求如下：</p>
<blockquote>
<p>POST &#x2F;post?id&#x3D;1234&amp;page&#x3D;1 HTTP&#x2F;1.1<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>name&#x3D;mau&amp;message&#x3D;this_is_great</p>
</blockquote>
<pre><code class="go">id := c.Query(&quot;id&quot;)
page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)
name := c.PostForm(&quot;name&quot;)
message := c.PostForm(&quot;message&quot;)
fmt.Printf(&quot;id: %s; page: %s; name: %s; message: %s&quot;, id, page, name, message)
// 结果：id: 1234; page: 1; name: mau; message: this_is_great
</code></pre>
<h2 id="防止-JSON-劫持——SecureJSON"><a href="#防止-JSON-劫持——SecureJSON" class="headerlink" title="防止 JSON 劫持——SecureJSON"></a>防止 JSON 劫持——SecureJSON</h2><p>如果给定的结构是数组值，则默认预置 “while(1),” 到响应体</p>
<pre><code class="go">names := []string&#123;&quot;lena&quot;, &quot;austin&quot;, &quot;foo&quot;&#125;
// 自定义SecureJSON 前缀
r.SecureJsonPrefix(&quot;)]&#125;&#39;,\n&quot;)
// 结果：while(1);[&quot;lena&quot;,&quot;austin&quot;,&quot;foo&quot;]
c.SecureJSON(http.StatusOK, names)
</code></pre>
<h2 id="XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染"><a href="#XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染" class="headerlink" title="XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染"></a>XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染</h2><pre><code class="go">// JSON
r.GET(&quot;/someJSON&quot;, func(c *gin.Context) &#123;
  c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)
&#125;)
// JSON-使用结构体
r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) &#123;
  // 你也可以使用一个结构体
  var msg struct &#123;
    Name    string `json:&quot;user&quot;`
    Message string
    Number  int
  &#125;
  msg.Name = &quot;Lena&quot;
  msg.Message = &quot;hey&quot;
  msg.Number = 123
  // 输出：&#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;
  c.JSON(http.StatusOK, msg)
&#125;)
// XML
r.GET(&quot;/someXML&quot;, func(c *gin.Context) &#123;
  c.XML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)
&#125;)
// Yaml
r.GET(&quot;/someYAML&quot;, func(c *gin.Context) &#123;
  c.YAML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)
&#125;)
// ProtoBuf
r.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) &#123;
  reps := []int64&#123;int64(1), int64(2)&#125;
  label := &quot;test&quot;
  // protobuf 的具体定义写在 testdata/protoexample 文件中
  data := &amp;protoexample.Test&#123;
    Label: &amp;label,
    Reps:  reps,
  &#125;
  // 数据在响应中变为二进制数据
  // 将输出被 protoexample.Test protobuf 序列化了的数据
  c.ProtoBuf(http.StatusOK, data)
&#125;)
</code></pre>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h3><pre><code class="go">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)
router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB,8右移20位
router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;
  // 单文件
  file, _ := c.FormFile(&quot;file&quot;)
  log.Println(file.Filename)
  dst := &quot;./&quot; + file.Filename
  // 上传文件至指定的完整文件路径
  c.SaveUploadedFile(file, dst)
  c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))
&#125;)
//curl -X POST http://localhost:8080/upload \
// -F &quot;file=@/Users/appleboy/test.zip&quot; \
// -H &quot;Content-Type: multipart/form-data&quot;
</code></pre>
<h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><pre><code class="go">router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;
  // Multipart form
  form, _ := c.MultipartForm()
  files := form.File[&quot;upload[]&quot;]
  for _, file := range files &#123;
    log.Println(file.Filename)
    // 上传文件至指定目录
    c.SaveUploadedFile(file, dst)
  &#125;
  c.String(http.StatusOK, fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)))
&#125;)
// curl -X POST http://localhost:8080/upload \
//   -F &quot;upload[]=@/Users/appleboy/test1.zip&quot; \
//   -F &quot;upload[]=@/Users/appleboy/test2.zip&quot; \
//   -H &quot;Content-Type: multipart/form-data&quot;
</code></pre>
<h2 id="不使用默认的中间件"><a href="#不使用默认的中间件" class="headerlink" title="不使用默认的中间件"></a>不使用默认的中间件</h2><p>gin.Default()默认使用 Logger 和 Recovery 中间件<br>gin.New()可以用于不需要使用默认的中间件的场景下</p>
<h2 id="从-reader-读取数据"><a href="#从-reader-读取数据" class="headerlink" title="从 reader 读取数据"></a>从 reader 读取数据</h2><pre><code class="go">response, err := http.Get(&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;)
if err != nil || response.StatusCode != http.StatusOK &#123;
  c.Status(http.StatusServiceUnavailable)
  return
&#125;
reader := response.Body
contentLength := response.ContentLength
contentType := response.Header.Get(&quot;Content-Type&quot;)
extraHeaders := map[string]string&#123;
  &quot;Content-Disposition&quot;: `attachment; filename=&quot;gopher.png&quot;`,
&#125;
c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)
</code></pre>
<h2 id="重启或停止-web-服务器"><a href="#重启或停止-web-服务器" class="headerlink" title="重启或停止 web 服务器"></a>重启或停止 web 服务器</h2><p>使用<code>fvbock/endless</code>代替<code>ListenAndServe</code></p>
<pre><code class="go">router := gin.Default()
router.GET(&quot;/&quot;, handler)
// [...]
endless.ListenAndServe(&quot;:4242&quot;, router)
</code></pre>
<h2 id="使用-BasicAuth-中间件"><a href="#使用-BasicAuth-中间件" class="headerlink" title="使用 BasicAuth 中间件"></a>使用 BasicAuth 中间件</h2><p>gin.BasicAuth() 中间件</p>
<pre><code class="go">var secrets = gin.H&#123;
    &quot;foo&quot;:    gin.H&#123;&quot;email&quot;: &quot;foo@bar.com&quot;, &quot;phone&quot;: &quot;123433&quot;&#125;,
    &quot;austin&quot;: gin.H&#123;&quot;email&quot;: &quot;austin@example.com&quot;, &quot;phone&quot;: &quot;666&quot;&#125;,
    &quot;lena&quot;:   gin.H&#123;&quot;email&quot;: &quot;lena@guapa.com&quot;, &quot;phone&quot;: &quot;523443&quot;&#125;,
&#125;
authorized := r.Group(&quot;/admin&quot;, gin.BasicAuth(gin.Accounts&#123;
 &quot;foo&quot;:    &quot;bar&quot;,
 &quot;austin&quot;: &quot;1234&quot;,
 &quot;lena&quot;:   &quot;hello2&quot;,
 &quot;manu&quot;:   &quot;4321&quot;,
&#125;))

// /admin/secrets 端点
// 触发 &quot;localhost:8080/admin/secrets
authorized.GET(&quot;/secrets&quot;, func(c *gin.Context) &#123;
  // 获取用户，它是由 BasicAuth 中间件设置的
  user := c.MustGet(gin.AuthUserKey).(string)
  if secret, ok := secrets[user]; ok &#123;
    c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user, &quot;secret&quot;: secret&#125;)
  &#125; else &#123;
    c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user, &quot;secret&quot;: &quot;NO SECRET :(&quot;&#125;)
  &#125;
&#125;)
</code></pre>
<h2 id="使用-http-方法"><a href="#使用-http-方法" class="headerlink" title="使用 http 方法"></a>使用 http 方法</h2><pre><code class="go">    // 使用默认中间件（logger 和 recovery 中间件）创建 gin 路由
    router := gin.Default()
    router.GET(&quot;/someGet&quot;, getting)
    router.POST(&quot;/somePost&quot;, posting)
    router.PUT(&quot;/somePut&quot;, putting)
    router.DELETE(&quot;/someDelete&quot;, deleting)
    router.PATCH(&quot;/somePatch&quot;, patching)
    router.HEAD(&quot;/someHead&quot;, head)
    router.OPTIONS(&quot;/someOptions&quot;, options)
    // 默认在 8080 端口启动服务，除非定义了一个 PORT 的环境变量。
    router.Run()
</code></pre>
<h2 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h2><pre><code class="go">// Logger 中间件将日志写入 gin.DefaultWriter，
r.Use(gin.Logger())
// Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。
r.Use(gin.Recovery())
// 可以为每个路由添加任意数量的中间件。
r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)
</code></pre>
<h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><pre><code class="go">authorized := r.Group(&quot;/&quot;, AuthRequired())
&#123;
  authorized.POST(&quot;/login&quot;, loginEndpoint)
  authorized.POST(&quot;/submit&quot;, submitEndpoint)
  authorized.POST(&quot;/read&quot;, readEndpoint)
  // 嵌套路由组
  testing := authorized.Group(&quot;testing&quot;)
  testing.GET(&quot;/analytics&quot;, analyticsEndpoint)
&#125;
</code></pre>
<p>同下面的完全一样</p>
<pre><code class="go">authorized := r.Group(&quot;/&quot;)
authorized.Use(AuthRequired())
&#123;
  authorized.POST(&quot;/login&quot;, loginEndpoint)
  authorized.POST(&quot;/submit&quot;, submitEndpoint)
  authorized.POST(&quot;/read&quot;, readEndpoint)
&#125;
</code></pre>
<h2 id="只绑定-url-查询字符串"><a href="#只绑定-url-查询字符串" class="headerlink" title="只绑定 url 查询字符串"></a>只绑定 url 查询字符串</h2><p>只绑定 url 查询参数，而忽略 post 参数：<code>ShouldBindQuery</code></p>
<pre><code class="go">type Person struct &#123;
    Name    string `form:&quot;name&quot;`
    Address string `form:&quot;address&quot;`
&#125;
route.PUT(&quot;/testing&quot;, startPage)
func startPage(c *gin.Context) &#123;
    var person Person
    if c.ShouldBindQuery(&amp;person) == nil &#123;
        log.Println(&quot;====== Only Bind By Query String ======&quot;)
        log.Println(person.Name)
        log.Println(person.Address)
    &#125;
    c.String(200, &quot;Success&quot;)
&#125;
</code></pre>
<h2 id="在中间件使用-go-routine"><a href="#在中间件使用-go-routine" class="headerlink" title="在中间件使用 go routine"></a>在中间件使用 go routine</h2><p>当在中间件或 handler 中启动新的 Goroutine 时，不能使用原始的上下文，必须使用只读副本。</p>
<pre><code class="go">r.GET(&quot;/long_async&quot;, func(c *gin.Context) &#123;
  // 创建在 goroutine 中使用的副本
  cCp := c.Copy()
  go func() &#123;
    // 用 time.Sleep() 模拟一个长任务。
    time.Sleep(5 * time.Second)
    // 使用的是复制的上下文 &quot;cCp&quot;，这一点很重要
    log.Println(&quot;Done! in path &quot; + cCp.Request.URL.Path)
  &#125;()
&#125;)
r.GET(&quot;/long_sync&quot;, func(c *gin.Context) &#123;
  // 用 time.Sleep() 模拟一个长任务。
  time.Sleep(5 * time.Second)
  // 因为没有使用 goroutine，不需要使用上下文副本
  log.Println(&quot;Done! in path &quot; + c.Request.URL.Path)
&#125;)
</code></pre>
<h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><pre><code class="go">// 只将日志写入文件
f, _ := os.Create(&quot;gin.log&quot;)
gin.DefaultWriter = io.MultiWriter(f)
// 需要同时将日志写入文件和控制台
gin.DefaultWriter = io.MultiWriter(f, os.Stdout)
</code></pre>
<h2 id="定义路由日志的格式"><a href="#定义路由日志的格式" class="headerlink" title="定义路由日志的格式"></a>定义路由日志的格式</h2><p>默认的路由日志格式</p>
<pre><code class="bash">[GIN-debug] POST   /foo                      --&gt; main.main.func1 (3 handlers)
[GIN-debug] GET    /bar                      --&gt; main.main.func2 (3 handlers)
[GIN-debug] GET    /status                   --&gt; main.main.func3 (3 handlers)
</code></pre>
<p>自定义日志格式：JSON，key-value 等-&gt;<code>gin.DebugPrintRouteFunc</code></p>
<pre><code class="go">gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) &#123;
  log.Printf(&quot;endpoint %v %v %v %v\n&quot;, httpMethod, absolutePath, handlerName, nuHandlers)
&#125;
</code></pre>
<h2 id="将-request-body-绑定到不同的结构体中"><a href="#将-request-body-绑定到不同的结构体中" class="headerlink" title="将 request body 绑定到不同的结构体中"></a>将 request body 绑定到不同的结构体中</h2><p><code>c.ShouldBind</code>通过<code>c.Request.Body</code>绑定数据，但是在部分格式不能多次调用：</p>
<ul>
<li>JSON</li>
<li>XML</li>
<li>MsgPack</li>
<li>ProtoBuf<br>如果需要多次绑定到不同结构体,需要使用<code>c.ShouldBindBodyWith</code><br>可以多次调用<code>c.ShouldBind</code>的格式：</li>
<li>Query</li>
<li>Form</li>
<li>FormPost</li>
<li>FormMultipart</li>
</ul>
<pre><code class="go">type formA struct &#123;
  Foo string `json:&quot;foo&quot; xml:&quot;foo&quot; binding:&quot;required&quot;`
&#125;
type formB struct &#123;
  Bar string `json:&quot;bar&quot; xml:&quot;bar&quot; binding:&quot;required&quot;`
&#125;
func SomeHandler(c *gin.Context) &#123;
  objA := formA&#123;&#125;
  objB := formB&#123;&#125;
  // c.ShouldBind 使用了 c.Request.Body，不可重用。
  if errA := c.ShouldBind(&amp;objA); errA == nil &#123;
    c.String(http.StatusOK, `the body should be formA`)
  // 因为现在 c.Request.Body 是 EOF，所以这里会报错。
  &#125; else if errB := c.ShouldBind(&amp;objB); errB == nil &#123;
    c.String(http.StatusOK, `the body should be formB`)
  &#125;
&#125;
// 读取 c.Request.Body 并将结果存入上下文。
if errA := c.ShouldBindBodyWith(&amp;objA, binding.JSON); errA == nil &#123;
  c.String(http.StatusOK, `the body should be formA`)
// 这时, 复用存储在上下文中的 body。
&#125; else if errB := c.ShouldBindBodyWith(&amp;objB, binding.JSON); errB == nil &#123;
  c.String(http.StatusOK, `the body should be formB JSON`)
// 可以接受其他格式
&#125; else if errB2 := c.ShouldBindBodyWith(&amp;objB, binding.XML); errB2 == nil &#123;
  c.String(http.StatusOK, `the body should be formB XML`)
&#125;
</code></pre>
<h2 id="控制日志输出颜色"><a href="#控制日志输出颜色" class="headerlink" title="控制日志输出颜色"></a>控制日志输出颜色</h2><p>输出到控制台的日志默认是有颜色的</p>
<pre><code class="go">// 禁止日志的颜色
gin.DisableConsoleColor()
// 强制日志颜色化
gin.ForceConsoleColor()
</code></pre>
<h2 id="映射查询字符串或表单参数"><a href="#映射查询字符串或表单参数" class="headerlink" title="映射查询字符串或表单参数"></a>映射查询字符串或表单参数</h2><pre><code class="bash">POST /post?ids[a]=1234&amp;ids[b]=hello HTTP/1.1
Content-Type: application/x-www-form-urlencoded

names[first]=thinkerou&amp;names[second]=tianou
</code></pre>
<pre><code class="go">ids := c.QueryMap(&quot;ids&quot;)
names := c.PostFormMap(&quot;names&quot;)
fmt.Printf(&quot;ids: %v; names: %v&quot;, ids, names)

// query参数——ids: map[b:hello a:1234],
// 表单参数——names: map[second:tianou first:thinkerou]
</code></pre>
<h2 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h2><p>&#x2F;&#x2F; 使用现有的基础请求对象解析查询字符串参数。<br>示例 URL： &#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe</p>
<pre><code class="go">router.GET(&quot;/welcome&quot;, func(c *gin.Context) &#123;
  firstname := c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)
  lastname := c.Query(&quot;lastname&quot;) // c.Request.URL.Query().Get(&quot;lastname&quot;) 的一种快捷方式

  c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)
&#125;)
</code></pre>
<h2 id="model-binding-绑定和验证"><a href="#model-binding-绑定和验证" class="headerlink" title="model binding 绑定和验证"></a>model binding 绑定和验证</h2><p>在绑定的所有字段上，设置相应的 tag，比如使用 json 绑定的时候，设置字段标签为 <code>json:&quot;filename&quot;</code><br>方法：ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML<br>行为： 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</p>
<pre><code class="go">type Login struct &#123;
    User     string `form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;`
    Password string `form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`
&#125;
// 绑定 JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)
router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) &#123;
  var json Login
  if err := c.ShouldBindJSON(&amp;json); err != nil &#123;
    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)
    return
  &#125;

  if json.User != &quot;manu&quot; || json.Password != &quot;123&quot; &#123;
    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)
    return
  &#125;

  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)
&#125;)
// 绑定XML
//	&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
//	&lt;root&gt;
//		&lt;user&gt;manu&lt;/user&gt;
//		&lt;password&gt;123&lt;/password&gt;
//	&lt;/root&gt;)
router.POST(&quot;/loginXML&quot;, func(c *gin.Context) &#123;
  var xml Login
  if err := c.ShouldBindXML(&amp;xml); err != nil &#123;
    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)
    return
  &#125;

  if xml.User != &quot;manu&quot; || xml.Password != &quot;123&quot; &#123;
    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)
    return
  &#125;

  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)
&#125;)
// 绑定 HTML 表单 (user=manu&amp;password=123)
router.POST(&quot;/loginForm&quot;, func(c *gin.Context) &#123;
  var form Login
  // 根据 Content-Type Header 推断使用哪个绑定器。
  if err := c.ShouldBind(&amp;form); err != nil &#123;
    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)
    return
  &#125;
  if form.User != &quot;manu&quot; || form.Password != &quot;123&quot; &#123;
    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)
    return
  &#125;
  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)
&#125;)
</code></pre>
<h2 id="绑定-uri"><a href="#绑定-uri" class="headerlink" title="绑定 uri"></a>绑定 uri</h2><pre><code class="go">type Person struct &#123;
    ID   string `uri:&quot;id&quot; binding:&quot;required,uuid&quot;`
    Name string `uri:&quot;name&quot; binding:&quot;required&quot;`
&#125;
route.GET(&quot;/:name/:id&quot;, func(c *gin.Context) &#123;
  var person Person
  if err := c.ShouldBindUri(&amp;person); err != nil &#123;
    c.JSON(400, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)
    return
  &#125;
  c.JSON(200, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)
&#125;)
</code></pre>
<h2 id="绑定查询字符串或者表单数据"><a href="#绑定查询字符串或者表单数据" class="headerlink" title="绑定查询字符串或者表单数据"></a>绑定查询字符串或者表单数据</h2><pre><code class="go">
type Person struct &#123;
    Name     string    `form:&quot;name&quot;`
    Address  string    `form:&quot;address&quot;`
    Birthday time.Time `form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;`
&#125;
route.GET(&quot;/testing&quot;, startPage)
func startPage(c *gin.Context) &#123;
    var person Person
    // 如果是 `GET` 请求，只使用 `Form` 绑定引擎（`query`）。
    // 如果是 `POST` 请求，首先检查 `content-type` 是否为 `JSON` 或 `XML`，然后再使用 `Form`（`form-data`）。
    // 查看更多：https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L88
    if c.ShouldBind(&amp;person) == nil &#123;
        log.Println(person.Name)
        log.Println(person.Address)
        log.Println(person.Birthday)
    &#125;

    c.String(200, &quot;Success&quot;)
&#125;
</code></pre>
<h2 id="绑定表单数据到自定义-struct"><a href="#绑定表单数据到自定义-struct" class="headerlink" title="绑定表单数据到自定义 struct"></a>绑定表单数据到自定义 struct</h2><p>不支持嵌套的 struct</p>
<pre><code class="go">type StructA struct &#123;
    FieldA string `form:&quot;field_a&quot;`
&#125;

type StructB struct &#123;
    NestedStruct StructA
    FieldB string `form:&quot;field_b&quot;`
&#125;
func GetDataB(c *gin.Context) &#123;
  var b StructB
  c.Bind(&amp;b)
  c.JSON(200, gin.H&#123;
      &quot;a&quot;: b.NestedStruct,
      &quot;b&quot;: b.FieldB,
  &#125;)
&#125;
</code></pre>
<h2 id="自定义-http-配置"><a href="#自定义-http-配置" class="headerlink" title="自定义 http 配置"></a>自定义 http 配置</h2><pre><code class="go">http.ListenAndServe(&quot;:8080&quot;, router)
// 自定义
s := &amp;http.Server&#123;
  Addr:           &quot;:8080&quot;,
  Handler:        router,
  ReadTimeout:    10 * time.Second,
  WriteTimeout:   10 * time.Second,
  MaxHeaderBytes: 1 &lt;&lt; 20,
&#125;
s.ListenAndServe()
</code></pre>
<h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><pre><code class="go">func Logger() gin.HandlerFunc &#123;
    return func(c *gin.Context) &#123;
        t := time.Now()

        // 设置 example 变量
        c.Set(&quot;example&quot;, &quot;12345&quot;)

        // 请求前

        c.Next()

        // 请求后
        latency := time.Since(t)
        log.Print(latency)

        // 获取发送的 status
        status := c.Writer.Status()
        log.Println(status)
    &#125;
&#125;
//
r := gin.New()
r.Use(Logger())

r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;
  example := c.MustGet(&quot;example&quot;).(string)
  // 打印：&quot;12345&quot;
  log.Println(example)
&#125;)
</code></pre>
<h2 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h2><pre><code class="go">type Booking struct &#123;
    CheckIn  time.Time `form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`
    CheckOut time.Time `form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn,bookabledate&quot; time_format:&quot;2006-01-02&quot;`
&#125;
var bookableDate validator.Func = func(fl validator.FieldLevel) bool &#123;
    date, ok := fl.Field().Interface().(time.Time)
    if ok &#123;
        today := time.Now()
        if today.After(date) &#123;
            return false
        &#125;
    &#125;
    return true
&#125;
    if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;
        v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)
    &#125;
</code></pre>
<h2 id="设置-x2F-获取-cookie"><a href="#设置-x2F-获取-cookie" class="headerlink" title="设置&#x2F;获取 cookie"></a>设置&#x2F;获取 cookie</h2><p>获取:<code>cookie, err := c.Cookie(&quot;gin_cookie&quot;)</code><br>设置:<code>c.SetCookie(&quot;gin_cookie&quot;, &quot;test&quot;, 3600, &quot;/&quot;, &quot;localhost&quot;, false, true)</code></p>
<h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><p>匹配 &#x2F;user&#x2F;john 但不会匹配 &#x2F;user&#x2F; 或者 &#x2F;user:</p>
<pre><code class="go">router.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123;
  name := c.Param(&quot;name&quot;)
  c.String(http.StatusOK, &quot;Hello %s&quot;, name)
&#125;)
</code></pre>
<p>匹配 &#x2F;user&#x2F;john&#x2F; 和 &#x2F;user&#x2F;john&#x2F;send:</p>
<pre><code class="go">//  如果没有其他路由匹配 /user/john，它将重定向到 /user/john/
router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) &#123;
  name := c.Param(&quot;name&quot;)
  action := c.Param(&quot;action&quot;)
  message := name + &quot; is &quot; + action
  c.String(http.StatusOK, message)
&#125;)
</code></pre>
<h2 id="路由组-1"><a href="#路由组-1" class="headerlink" title="路由组"></a>路由组</h2><pre><code class="go">v1 := router.Group(&quot;/v1&quot;)
&#123;
  v1.POST(&quot;/login&quot;, loginEndpoint)
  v1.POST(&quot;/submit&quot;, submitEndpoint)
  v1.POST(&quot;/read&quot;, readEndpoint)
&#125;
</code></pre>
<h2 id="运行多个服务"><a href="#运行多个服务" class="headerlink" title="运行多个服务"></a>运行多个服务</h2><p>GO </p>
<pre><code class="go">var (
    g errgroup.Group
)

func router01() http.Handler &#123;
    e := gin.New()
    e.Use(gin.Recovery())
    e.GET(&quot;/&quot;, func(c *gin.Context) &#123;
        c.JSON(
            http.StatusOK,
            gin.H&#123;
                &quot;code&quot;:  http.StatusOK,
                &quot;error&quot;: &quot;Welcome server 01&quot;,
            &#125;,
        )
    &#125;)
    return e
&#125;
func router02() http.Handler &#123;
    e := gin.New()
    e.Use(gin.Recovery())
    e.GET(&quot;/&quot;, func(c *gin.Context) &#123;
        c.JSON(
            http.StatusOK,
            gin.H&#123;
                &quot;code&quot;:  http.StatusOK,
                &quot;error&quot;: &quot;Welcome server 02&quot;,
            &#125;,
        )
    &#125;)

    return e
&#125;

server01 := &amp;http.Server&#123;
  Addr:         &quot;:8080&quot;,
  Handler:      router01(),
  ReadTimeout:  5 * time.Second,
  WriteTimeout: 10 * time.Second,
&#125;

server02 := &amp;http.Server&#123;
  Addr:         &quot;:8081&quot;,
  Handler:      router02(),
  ReadTimeout:  5 * time.Second,
  WriteTimeout: 10 * time.Second,
&#125;

g.Go(func() error &#123;
  return server01.ListenAndServe()
&#125;)

g.Go(func() error &#123;
  return server02.ListenAndServe()
&#125;)

if err := g.Wait(); err != nil &#123;
  log.Fatal(err)
&#125;
</code></pre>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="get重定向"><a href="#get重定向" class="headerlink" title="get重定向"></a>get重定向</h3><pre><code class="go">r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;
    c.Redirect(http.StatusMovedPermanently, &quot;http://www.google.com/&quot;)
&#125;)
</code></pre>
<h3 id="post-重定向"><a href="#post-重定向" class="headerlink" title="post 重定向"></a>post 重定向</h3><pre><code class="go">r.POST(&quot;/test&quot;, func(c *gin.Context) &#123;
    c.Redirect(http.StatusFound, &quot;/foo&quot;)
&#125;)
</code></pre>
<h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>使用<code>HandleContext</code></p>
<pre><code class="go">r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;
    c.Request.URL.Path = &quot;/test2&quot;
    r.HandleContext(c)
&#125;)
r.GET(&quot;/test2&quot;, func(c *gin.Context) &#123;
    c.JSON(200, gin.H&#123;&quot;hello&quot;: &quot;world&quot;&#125;)
&#125;)
</code></pre>
<h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><pre><code class="go">router.Static(&quot;/assets&quot;, &quot;./assets&quot;)
router.StaticFS(&quot;/more_static&quot;, http.Dir(&quot;my_file_system&quot;))
router.StaticFile(&quot;/favicon.ico&quot;, &quot;./resources/favicon.ico&quot;)
</code></pre>
<h2 id="静态资源嵌入"><a href="#静态资源嵌入" class="headerlink" title="静态资源嵌入"></a>静态资源嵌入</h2><pre><code class="go">// loadTemplate 加载由 go-assets-builder 嵌入的模板
func loadTemplate() (*template.Template, error) &#123;
    t := template.New(&quot;&quot;)
    for name, file := range Assets.Files &#123;
        if file.IsDir() || !strings.HasSuffix(name, &quot;.tmpl&quot;) &#123;
            continue
        &#125;
        h, err := ioutil.ReadAll(file)
        if err != nil &#123;
            return nil, err
        &#125;
        t, err = t.New(name).Parse(string(h))
        if err != nil &#123;
            return nil, err
        &#125;
    &#125;
    return t, nil
&#125;
t, err := loadTemplate()
if err != nil &#123;
  panic(err)
&#125;
r.SetHTMLTemplate(t)

r.GET(&quot;/&quot;, func(c *gin.Context) &#123;
  c.HTML(http.StatusOK, &quot;/html/index.tmpl&quot;, nil)
&#125;)
</code></pre>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-03-23</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/GoLang/'>
                            GoLang
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%90%8E%E7%AB%AF/'>
                            后端
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>