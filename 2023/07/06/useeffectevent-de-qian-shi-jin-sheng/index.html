<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="useEffectEvent的前世今生" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">备忘录/笔记本</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            useEffectEvent的前世今生
        </div>
      
    

    <div class="post-md">
        
            
        
        <p>去年 React 团队分享了一个新 Hook <code>useEvent</code> 的<a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/pull/220">RFC220</a>,完整 RFC 内容见<a target="_blank" rel="noopener" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md">useEvent</a>。这个 Hook 的来源是<a target="_blank" rel="noopener" href="https://github.com/facebook/react/issues/14099">#14099</a>。 useEvent 的<a target="_blank" rel="noopener" href="https://github.com/facebook/react/pull/25229">原型</a>已经实现，但是今年 1 月份关闭了<code>useEvent</code>提案，为什么会关闭呢，主要有以下几个原因：</p>
<ol>
<li>将渲染优化和“修复”Effect 耦合在一个提案下，很难实现</li>
<li>容易诱导开发者将当前使用 <code>useCallback</code> 包裹的函数都替换成 <code>useEvent</code></li>
</ol>
<p>但是关闭提案并不意味着全盘否定，事实上，只是对其进行了拆分。针对渲染优化，React 团队准备开发一个<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=lGEMwh32soc">自动记忆编译器</a>，而针对修复 Effect，则发布了一个 <code>useEffectEvent</code>的新的 Hook。</p>
<p>官方之前在 RFC 给出的 useEvent 的大概实现如下所示，当然这不是真正的实现，真正的实现肯定比这个复杂得多：</p>
<pre><code class="javascript">// (!) Approximate behavior
function useEvent(handler) &#123;
  const handlerRef = useRef(null);
  // 渲染之前运行
  useLayoutEffect(() =&gt; &#123;
    handlerRef.current = handler;
  &#125;);
  return useCallback((...args) =&gt; &#123;
    // 渲染期间执行的话，会抛出错误
    const fn = handlerRef.current;
    return fn(...args);
  &#125;, []);
&#125;
</code></pre>
<p>下面就借助代码来讲述一下这个新的 Hook 应该怎么使用。<br>当前存在的问题：<br>你创建了一个聊天连接，把当前的 message 存储在 state 变量中，每次输入的时候更新 message,当用户准备好后就可以发送。</p>
<pre><code class="javascript">function Chat() &#123;
  const [message, setMessage] = React.useState(&quot;&quot;);
  const sendMessage = (val) =&gt; &#123;
    console.log(val);
  &#125;;
  const onSend = () =&gt; &#123;
    sendMessage(message);
  &#125;;
  return (
    &lt;&gt;
      &lt;Input onSend=&#123;onSend&#125; setMessage=&#123;setMessage&#125; /&gt;
    &lt;/&gt;
  );
&#125;
</code></pre>
<p>在上面的例子中，由于 <code>onSend</code> 的函数引用每次都会变化，即每次的 <code>onSend</code> 都是重新创建的不同的函数，这会直接破坏 Input 组件的 memo 效果，原因是当一个组件被 memoize 后,会对 props 进行浅层比较来决定是否需要重新渲染。如果 props 是“浅相等”(同一个引用),就跳过重新渲染。而 <code>onSend</code> 每次都跟上一次不一样。</p>
<p>那如何优化呢？很明显可以使用<code>useCallback</code>包裹<code>onSend</code>函数，保证只有 state 变量变化时，<code>onSend</code>函数才会被重新创建。</p>
<pre><code class="javascript">const onSend = React.useCallback(() =&gt; &#123;
  sendMessage(message);
&#125;, [message]);
</code></pre>
<p>通过这个修改，Input 组件只有在 <code>onSend</code> 函数重新创建的时候 <code>Input</code> 组件才会重新渲染。但是这样并不完全契合我们的预期，因为每当 message 变化， <code>onSend</code> 函数还是会被重新创建。但是如果去掉依赖项，就获取不到最新的 message 值。</p>
<img src="/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/recreate.png" class="">

<p>还可以通过 ref 修复这个问题:使用 sendRef 存储事件处理函数，这样你输入的时候 onSend 函数会一直保持为同一个函数标识符</p>
<pre><code class="javascript">const sendRef = React.useRef(null);
React.useLayoutEffect(() =&gt; &#123;
  sendRef.current = () =&gt; sendMessage(message);
&#125;);
const onSend = React.useCallback((...args) =&gt; &#123;
  return sendRef.current(...args);
&#125;, []);
</code></pre>
<p>尽管这个方法能解决我们的问题，但是很明显牺牲了代码可读性。基于以上的问题，React 团队推出了一个新的 Hook <code>useEffectEvent</code>，使用起来非常方便。</p>
<p>但是因为这个 Hook 目前还没有在稳定版 React 中发布，所以需要先安装实验版本的 React</p>
<pre><code class="bash">npm install react@experimental
npm install react-dom@experimental
npm install eslint-plugin-react-hooks@experimental
</code></pre>
<p>现在只需要直接用 <code>useEffectEvent</code> 将回调函数包裹起来就可以</p>
<pre><code class="javascript">import &#123; experimental_useEffectEvent as useEffectEvent &#125; from &quot;react&quot;;
const onSend = React.experimental_useEffectEvent(() =&gt; &#123;
  sendMessage(message);
&#125;);
</code></pre>
<p>新的 Hook useEffectEvent 允许用户定义一个函数，可以一直读取到最新的 props&#x2F;state，但是和这个函数会有一个稳定的标识符，所以他不会破坏缓存，也不会重新触发 Effect,可以减少不必要的渲染。它和 <code>useCallback</code> 的区别是:</p>
<ol>
<li>重渲染次数的显著不同：<img src="/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/retrigger.png" class=""></li>
<li>useEffectEvent 不需要依赖项列表</li>
</ol>
<p>useEvent 的返回值，它的行为就和普通函数一样，所以也可以给他传递参数，比如 <code>roomID</code></p>
<pre><code class="javascript">const onSend = useEffectEvent((roomID) =&gt; &#123;
  sendMessage(roomID, message);
&#125;);
onSend(roomID);
</code></pre>
<p>回到 Chat 组件，每当 roomID 变化时就展示一个成功的 alert 并清空 message,使用 useEffect 可以达到目的。</p>
<pre><code class="javascript">function Chat() &#123;
  const [message, setMessage] = React.useState(&quot;&quot;);
  const [roomID, setRoomID] = React.useState(&quot;reavel&quot;);
  const sendMessage = (val) =&gt; &#123;
    console.log(val);
  &#125;;
  const onSend = React.experimental_useEffectEvent(() =&gt; &#123;
    sendMessage(message);
  &#125;);
  React.useEffect(() =&gt; &#123;
    if (!!roomID) &#123;
      showNotification(&quot;Changed room-&gt;&quot; + roomID, &quot;dark&quot;);
      setMessage(&quot;&quot;);
    &#125;
  &#125;, [roomID]);
  return (
    &lt;&gt;
      &lt;div&gt;
        &lt;select
          onChange=&#123;(e) =&gt; &#123;
            setRoomID(e.target.value);
          &#125;&#125;
        &gt;
          &lt;option value=&quot;travel&quot;&gt;travel room&lt;/option&gt;
          &lt;option value=&quot;music&quot;&gt;music room&lt;/option&gt;
          &lt;option value=&quot;sport&quot;&gt;sport room&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;
      &lt;Input onSend=&#123;onSend&#125; setMessage=&#123;setMessage&#125; message=&#123;message&#125; /&gt;
    &lt;/&gt;
  );
&#125;
</code></pre>
<p>但是如果 toast 是从当前的主题上下文中读取的话，代码检查工具会提示你需要将 theme 添加到依赖项中</p>
<pre><code class="javascript">function Chat() &#123;
  const theme = useContext(ThemeContext);
  const [message, setMessage] = useState(&quot;&quot;);
  const onSend = useEffectEvent(() =&gt; &#123;
    setMessage(message);
  &#125;);

  React.useEffect(() =&gt; &#123;
    if (!!roomID) &#123;
      showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);
      setMessage(&quot;&quot;);
    &#125;
  &#125;, [roomID, theme]);
  return &lt;Input onSend=&#123;onSend&#125; /&gt;;
&#125;
</code></pre>
<p>实际上主题色变化的时候，连接的房间并没发生变化，所以实际上我们并不需要重新展示消息。我们可以使用 <code>useCallback</code> 将代码从 <code>useEffect</code> 中提取出来。</p>
<pre><code class="javascript">const theme = useContext(ThemeContext);
const onChangedRoom = useCallback(() =&gt; &#123;
  showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);
  setMessage(&quot;&quot;);
&#125;, [theme]);
useEffect(() =&gt; &#123;
  onChangedRoom();
&#125;, [roomID]);
return &lt;Input onSend=&#123;onSend&#125; /&gt;;
</code></pre>
<p>但是因为 <code>useEffectEvent</code> 在防止不必要的重渲染上更有意义,所以我们使用 <code>useEffectEvent</code> 包裹对应的代码，使它变成非响应式代码。</p>
<pre><code class="javascript">const theme = useContext(ThemeContext);
const onChangedRoom = useEffectEvent(() =&gt; &#123;
  showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);
  setMessage(&quot;&quot;);
&#125;);
useEffect(() =&gt; &#123;
  onChangedRoom();
&#125;, [roomID]);
return &lt;Input onSend=&#123;onSend&#125; /&gt;;
</code></pre>
<p>这样既减少了不必要的重渲染，代码可读性也得到了改善。</p>
<p>那哪些情况不适合用 useEffectEvent 呢？即需要在渲染期间调用的函数,因为 useEffectEvent 在渲染期间运行会抛出错误</p>
<pre><code class="javascript">function ThemedGrid() &#123;
  const theme = useContext(ThemeContext);
  const renderItem = useCallback(
    (item) =&gt; &#123;
      // 渲染期间调用，所以他不是一个事件
      return &lt;Row &#123;...item&#125; theme=&#123;theme&#125; /&gt;;
    &#125;,
    [theme]
  );
  return &lt;Grid renderItem=&#123;renderItem&#125; /&gt;;
&#125;
</code></pre>
<p>代码：<a target="_blank" rel="noopener" href="https://stackblitz.com/edit/stackblitz-starters-ida8fu">https://stackblitz.com/edit/stackblitz-starters-ida8fu</a></p>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-07-06</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/React/'>
                            React
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E5%89%8D%E7%AB%AF/'>
                            前端
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>