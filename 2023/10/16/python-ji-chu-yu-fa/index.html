<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="python基础语法" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary | just try it</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">默奥沙</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            python基础语法
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c2-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="post-toc-text">c2. 解释器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="post-toc-text">调用解释器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%AF%E5%8A%A8%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="post-toc-text">启动解释器方式：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%80%80%E5%87%BA%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="post-toc-text">退出解释器方法：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">交互模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E7%8E%AF%E5%A2%83"><span class="post-toc-text">解释器和环境</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c3-Python-%E9%9D%9E%E6%AD%A3%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="post-toc-text">c3. Python 非正式介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="post-toc-text">计算器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="post-toc-text">算术运算符：+,-,*,&#x2F;</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%87%E6%9C%AC%E7%B1%BB%E5%9E%8B-str"><span class="post-toc-text">文本类型 str</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B-list"><span class="post-toc-text">列表类型 list</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#python-%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E6%AD%A5"><span class="post-toc-text">python 编程第一步</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c4-%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="post-toc-text">c4. 控制流</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="post-toc-text">条件语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">for 循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BF%AE%E6%94%B9%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="post-toc-text">修改迭代对象中的内容</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#range-%E5%87%BD%E6%95%B0"><span class="post-toc-text">range()函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#break-x2F-continue-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E4%B8%8A%E7%9A%84-else-%E5%AD%90%E5%8F%A5"><span class="post-toc-text">break&#x2F;continue 语句和循环上的 else 子句</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#for-x2F-while-%E4%B8%AD%E7%9A%84-else-%E5%AD%90%E5%8F%A5"><span class="post-toc-text">for&#x2F;while 中的 else 子句</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pass-%E8%AF%AD%E5%8F%A5"><span class="post-toc-text">pass 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#match-%E8%AF%AD%E5%8F%A5"><span class="post-toc-text">match 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="post-toc-text">定义函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-2"><span class="post-toc-text">定义函数 2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="post-toc-text">默认参数值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="post-toc-text">关键字参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="post-toc-text">调用约定</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0"><span class="post-toc-text">特殊参数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%BB%E6%84%8F%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="post-toc-text">任意实参列表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A7%A3%E5%8C%85%E5%AE%9E%E5%8F%82%E5%88%97%E8%A1%A8"><span class="post-toc-text">解包实参列表</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="post-toc-text">lambda 表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">文档字符串</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3"><span class="post-toc-text">函数注解</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c5-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-text">c5. 数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%88%97%E8%A1%A8"><span class="post-toc-text">列表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%A0%88"><span class="post-toc-text">实现堆栈</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="post-toc-text">实现队列</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="post-toc-text">列表推导式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#del-%E8%AF%AD%E5%8F%A5"><span class="post-toc-text">del 语句</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E5%BA%8F%E5%88%97"><span class="post-toc-text">元组和序列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E5%88%97%E8%A1%A8%E5%8C%BA%E5%88%AB"><span class="post-toc-text">元组和列表区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88"><span class="post-toc-text">集合</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88"><span class="post-toc-text">创建集合</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="post-toc-text">集合操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="post-toc-text">集合推导式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%97%E5%85%B8"><span class="post-toc-text">字典</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8"><span class="post-toc-text">创建字典</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="post-toc-text">字典推导式</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8A%80%E5%B7%A7"><span class="post-toc-text">循环技巧</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6-deep"><span class="post-toc-text">条件控制 deep</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c6-%E6%A8%A1%E5%9D%97"><span class="post-toc-text">c6. 模块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97"><span class="post-toc-text">什么是模块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dir-%E5%87%BD%E6%95%B0"><span class="post-toc-text">dir()函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8C%85"><span class="post-toc-text">包</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5"><span class="post-toc-text">从包中导入</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%AF%BC%E5%85%A5"><span class="post-toc-text">相对导入</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c7-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="post-toc-text">c7. 输入和输出</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c8-%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="post-toc-text">c8. 错误和异常</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c9-%E7%B1%BB"><span class="post-toc-text">c9. 类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="post-toc-text">作用域和命名空间</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89%E8%AF%AD%E6%B3%95"><span class="post-toc-text">类定义语法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Class-%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">Class 对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%8C%E6%9C%9B%E9%80%9A%E8%BF%87%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="post-toc-text">希望通过指定初始状态创建实例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">实例对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1"><span class="post-toc-text">方法对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="post-toc-text">类和实例变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BE%8B%E5%A4%96%E6%83%85%E5%86%B5"><span class="post-toc-text">例外情况</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="post-toc-text">继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="post-toc-text">多重继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="post-toc-text">私有变量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8"><span class="post-toc-text">迭代器和生成器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="post-toc-text">生成器表达式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c10-%E6%A0%87%E5%87%86%E5%BA%93-part1"><span class="post-toc-text">c10. 标准库-part1</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c11-%E6%A0%87%E5%87%86%E5%BA%93-part2"><span class="post-toc-text">c11. 标准库-part2</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#c12-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%92%8C%E5%8C%85"><span class="post-toc-text">c12. 虚拟环境和包</span></a></li></ol>
        
        <h2 id="c2-解释器"><a href="#c2-解释器" class="headerlink" title="c2. 解释器"></a>c2. 解释器</h2><p>前提：安装 python 并将安装路径添加到环境变量中</p>
<h3 id="调用解释器"><a href="#调用解释器" class="headerlink" title="调用解释器"></a>调用解释器</h3><h4 id="启动解释器方式："><a href="#启动解释器方式：" class="headerlink" title="启动解释器方式："></a>启动解释器方式：</h4><ol>
<li><code>py xx.py</code> 或者 <code>python xx.py</code></li>
<li><code>python -c command [arg] ...</code>,命令最好用引号包裹</li>
<li><code>python -m module [arg] ...</code>,在命令行下直接运行 Python 模块</li>
</ol>
<blockquote>
<p>区别：方法 2 是执行 command 中的语句,类似于 shell -c,方法 3 会将模块作为主程序运行，模块通过名称区分</p>
</blockquote>
<pre><code class="py"># my_module.py
def greet(name):
    print(f&quot;Hello, &#123;name&#125;!&quot;)

# 外部调用
python -m my_module
</code></pre>
<h4 id="退出解释器方法："><a href="#退出解释器方法：" class="headerlink" title="退出解释器方法："></a>退出解释器方法：</h4><ol>
<li><code>CTRL+Z</code>+<code>Enter</code></li>
<li><code>exit()</code></li>
</ol>
<h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><ol>
<li>主提示符<code>&gt;&gt;&gt;</code>:提示输入下一条指令</li>
<li>次要提示符<code>...</code>:提示输入连续行</li>
</ol>
<blockquote>
<p>输入多行架构的语句时，要用连续行</p>
</blockquote>
<h3 id="解释器和环境"><a href="#解释器和环境" class="headerlink" title="解释器和环境"></a>解释器和环境</h3><p>默认编码：UTF-8<br>指定编码方式：通过注释实现：<code># -*- coding: encoding -*-</code></p>
<blockquote>
<p>指定编码需要和 vscode 底部的编码方式保持一致，否则会报错 SyntaxError: encoding problem: GB2312 或者乱码</p>
</blockquote>
<pre><code class="py">#!/usr/bin/env python3
# -*- coding: gb2312 -*-
</code></pre>
<h2 id="c3-Python-非正式介绍"><a href="#c3-Python-非正式介绍" class="headerlink" title="c3. Python 非正式介绍"></a>c3. Python 非正式介绍</h2><h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p>注释：python 注释以<code>#</code>开头，直到该行结束</p>
<h4 id="算术运算符："><a href="#算术运算符：" class="headerlink" title="算术运算符：+,-,*,/"></a>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code></h4><p>特殊算术运算符：</p>
<ul>
<li><code>//</code>：取整 5&#x2F;&#x2F;2&#x3D;2</li>
<li><code>%</code>：取余 5%2&#x3D;1</li>
<li><code>**</code>：乘方 5**2&#x3D;25</li>
<li><code>=</code>：赋值 a&#x3D;3</li>
</ul>
<blockquote>
<ol>
<li>普通除法的返回值一直是浮点数。</li>
<li>交互模式下，前一次输出的表达式会赋值给变量<code>_</code>,并且避免给这个变量显式赋值</li>
</ol>
</blockquote>
<h4 id="文本类型-str"><a href="#文本类型-str" class="headerlink" title="文本类型 str"></a>文本类型 str</h4><p>单行字符串：使用单引号或者双引号包裹<br>多行字符串：使用三重引号包裹<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code><br>转义：<code>\</code>+字符<br>不转义：<code>print(r&#39;a\b&#39;)</code><br>合并重复: +和*<br>字符串长度：<code>len(str1)</code></p>
<blockquote>
<p>自动合并：相邻的两个或多个 字符串<strong>字面值</strong> （引号标注的字符）会自动合并。</p>
</blockquote>
<blockquote>
<p>支持下标(正负数)访问和切片<code>word[0:3]</code>:包含 0-2 的字符的子串<br>word[0:],word[-2:]包含了<code>stop</code>下标,字符串中单个字符不可修改</p>
</blockquote>
<pre><code class="py"># 3 times &#39;un&#39;, followed by &#39;ium&#39;
3 * &#39;un&#39; + &#39;ium&#39;
# 输出结果：&#39;unununium&#39;
s=&#39;Py&#39; &#39;thon&#39;
# 输出结果：Python
</code></pre>
<h4 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h4><p>使用<code>[]</code>进行包裹，支持不同类型数据组合,可以嵌套<br>单个元素可以通过下标或者切片修改<br>获取列表长度：<code>len(list1)</code><br>列表末尾添加新元素：<code>cubes.append(216) </code><br>合并列表:<code>squares + [36, 49, 64, 81, 100]</code></p>
<h3 id="python-编程第一步"><a href="#python-编程第一步" class="headerlink" title="python 编程第一步"></a>python 编程第一步</h3><p>缩进是 python 组织语句结构的方式<br>print()可以传多个参数，通过<code>,</code>分隔，比如 <code>print(&#39;a&#39;,&#39;b&#39;)</code>打印出来的结果是：<code>a b</code></p>
<h2 id="c4-控制流"><a href="#c4-控制流" class="headerlink" title="c4. 控制流"></a>c4. 控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><pre><code class="py">x=input(&#39;请输入：&#39;)
x=int(x)
if x &lt; 0:
    x = 0
    print(&#39;Negative changed to zero&#39;)
elif x == 0:
    print(&#39;Zero&#39;)
else:
    print(&#39;More&#39;)
</code></pre>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>形式：<code>for item in 列表/字符串</code><br>注意点：</p>
<ul>
<li>python 本身不支持通过下标进行迭代，即<code>for (int i = 0; i &lt; 10; i++)</code>这样的形式，而是按顺序遍历可迭代对象（如列表、字符串等）中的元素。</li>
</ul>
<pre><code class="py">words = [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]
for w in words:
    print(w, len(w))
</code></pre>
<ul>
<li>如果需要下标进行迭代的话，可使用<code>enumerate</code>将列表或字符串作为参数</li>
</ul>
<pre><code class="py">words = [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]
for index,value in enumerate(words):
    print(&#39;index&#39;,index,&#39;value&#39;,value)
</code></pre>
<h4 id="修改迭代对象中的内容"><a href="#修改迭代对象中的内容" class="headerlink" title="修改迭代对象中的内容"></a>修改迭代对象中的内容</h4><p>推荐方法：迭代多项集的副本或者创建新的多项集<br>不推荐：通过下标修改<br>原因：如果在循环体中修改了该集合的内容（增删改），可能会导致迭代过程出现意外的行为。因为修改集合后，原始集合的长度和结构发生了变化，而迭代器无法正确地处理这种变化。</p>
<pre><code class="py"># 正确做法
users = &#123;&#39;Hans&#39;: &#39;active&#39;, &#39;Éléonore&#39;: &#39;inactive&#39;, &#39;景太郎&#39;: &#39;active&#39;&#125;

# Strategy:  迭代副本
for user, status in users.copy().items():
    if status == &#39;inactive&#39;:
        del users[user]

# Strategy:  创建一个新的集合
active_users = &#123;&#125;
for user, status in users.items():
    if status == &#39;active&#39;:
        active_users[user] = status

print(users,active_users)
</code></pre>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>作用：用于生成等差数列,生成的数列左闭右开</p>
<ul>
<li>&#96;&#96;range(num)&#96;:从 0 开始生成 0 一直到 num-1 的数列</li>
<li><code>range(start,end)</code>:从 start 开始生成一直到 end-1 的数列</li>
<li><code>range(start,end,step)</code>:从 start 开始按照 step 步长生成一直到 end-1 的数列<br>应用：按照索引迭代序列</li>
</ul>
<pre><code class="py">a = [&#39;Mary&#39;, &#39;had&#39;, &#39;a&#39;, &#39;little&#39;, &#39;lamb&#39;]
for i in range(len(a)):
    print(i, a[i])
</code></pre>
<h3 id="break-x2F-continue-语句和循环上的-else-子句"><a href="#break-x2F-continue-语句和循环上的-else-子句" class="headerlink" title="break&#x2F;continue 语句和循环上的 else 子句"></a>break&#x2F;continue 语句和循环上的 else 子句</h3><p>break 语句：跳出最近一层的 for&#x2F;while 循环<br>continue 语句：执行循环的下一次迭代<br>else 子句：for 或 while 循环可以包括 else 子句</p>
<pre><code class="py">for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, &#39;equals&#39;, x, &#39;*&#39;, n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, &#39;is a prime number&#39;)
</code></pre>
<h4 id="for-x2F-while-中的-else-子句"><a href="#for-x2F-while-中的-else-子句" class="headerlink" title="for&#x2F;while 中的 else 子句"></a>for&#x2F;while 中的 else 子句</h4><p>else 子句和 for&#x2F;while 同级</p>
<pre><code class="py"># for 循环中的 else 子句
for item in iterable:
    # 循环体
else:
    # 循环正常完成时执行的逻辑

# while 循环中的 else 子句
while condition:
    # 循环体
else:
    # 循环条件为假时执行的逻辑
</code></pre>
<p>执行时机不一样<br>for：如果 for 循环正常完成（即<strong>没有通过 break 语句</strong>提前退出），则执行 else 块中的代码</p>
<pre><code class="py"># for 循环中的 else 子句
for i in range(5):
    print(i)
else:
    print(&quot;For loop completed&quot;)
# 结果
0
1
2
3
4
For loop completed
</code></pre>
<p>while：如果 while 循环的条件为假，即<strong>终止了循环（不再满足循环条件）</strong>，则执行 else 块中的代码.同样如果中途有 break 语句则不会执行 else 子句</p>
<pre><code class="py"># while 循环中的 else 子句
x = 0
while x &lt; 5:
    print(x)
    x += 1
else:
    print(&quot;While loop condition is false&quot;)
</code></pre>
<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>不执行任何动作。<br>使用场景：语法上需要语句，但程序不需要执行任何动作</p>
<ol>
<li>在定义一个函数或类时，如果函数或类体内还没有具体的实现，可以使用 pass 语句来占位</li>
</ol>
<pre><code class="py">def my_function():
    pass

class MyClass:
    pass
</code></pre>
<ol start="2">
<li>开发过程中，当你想跳过某些代码块的执行时，可以使用 pass 语句作为占位符，以后再进行实现</li>
</ol>
<pre><code class="py">if condition_1:
    # 处理condition_1的情况
elif condition_2:
    pass  # 暂时不需要处理condition_2的情况
else:
    # 处理其他情况
</code></pre>
<h3 id="match-语句"><a href="#match-语句" class="headerlink" title="match 语句"></a>match 语句</h3><p>作用：接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较<br>本质：模式匹配<br>如果都不匹配，会执行<code>case _</code>,这个相当于 js 中的 default 分支</p>
<pre><code class="py">def http_error(status):
    match status:
        case 400|500:
            return &quot;Bad request&quot;
        case 404:
            return &quot;Not found&quot;
        case 418:
            return &quot;I&#39;m a teapot&quot;
        case _:
            return &quot;Something&#39;s wrong with the internet&quot;

def http_error2(point):
    match point:
        case (0, 0):
            print(&quot;Origin&quot;)
        case (0, y):
            print(f&quot;Y=&#123;y&#125;&quot;)
        case (x, 0):
            print(f&quot;X=&#123;x&#125;&quot;)
        case (x, y):
            print(f&quot;X=&#123;x&#125;, Y=&#123;y&#125;&quot;)
        case _:
            raise ValueError(&quot;Not a point&quot;)
# http_error2((0,3)) =&gt;Y=3
</code></pre>
<blockquote>
<p>Todo:此处需要二次学习</p>
</blockquote>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>形式：<code>def funcName(形参列表)</code><br>函数体第一条语句为字符串的时候，它就是<code>docstring</code>。作用是自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档</p>
<pre><code class="py">def fib(n):    # write Fibonacci series up to n
    &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
    a, b = 0, 1
    while a &lt; n:
        print(a, end=&#39; &#39;)
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
</code></pre>
<ul>
<li>返回值：return 语句返回函数的值。return 语句不带表达式参数时，返回 None。函数执行完毕退出也返回 None</li>
<li>实参：按值调用 进行传递</li>
</ul>
<blockquote>
<p>此处值指的始终是对象的 引用 而不是对象的值</p>
</blockquote>
<h3 id="定义函数-2"><a href="#定义函数-2" class="headerlink" title="定义函数 2"></a>定义函数 2</h3><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>用于：函数定义</p>
<pre><code class="py">def ask_ok(prompt, retries=4, reminder=&#39;Please try again!&#39;):
    while True:
        ok = input(prompt)
        if ok in (&#39;y&#39;, &#39;ye&#39;, &#39;yes&#39;):
            return True
        if ok in (&#39;n&#39;, &#39;no&#39;, &#39;nop&#39;, &#39;nope&#39;):
            return False
        retries = retries - 1
        if retries &lt; 0:
            raise ValueError(&#39;invalid user response&#39;)
        print(reminder)
</code></pre>
<p>调用方式：</p>
<ol>
<li>只给出必选实参：<code>ask_ok(&#39;Do you really want to quit?&#39;)</code></li>
<li>给出一个可选实参：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2)</code></li>
<li>给出所有实参：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2, &#39;Come on, only yes or no!&#39;)</code></li>
</ol>
<blockquote>
<p>默认参数值只在函数定义之前生效</p>
</blockquote>
<pre><code class="py">i = 5

def f(arg=i):
    print(arg)

i = 6
f() #此时结果为5
</code></pre>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>在函数调用中前面带有标识符（例如 name&#x3D;）或者作为包含在前面带有 ** 的字典里的值传入<br>用于：函数调用</p>
<blockquote>
<p>positional 参数 vs keyword 参数</p>
</blockquote>
<pre><code class="py">def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;, type=&#39;Norwegian Blue&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)
    print(&quot;-- Lovely plumage, the&quot;, type)
    print(&quot;-- It&#39;s&quot;, state, &quot;!&quot;)

# 有效调用
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action=&#39;VOOOOOM&#39;)             # 2 keyword arguments
parrot(action=&#39;VOOOOOM&#39;, voltage=1000000)             # 2 keyword arguments
parrot(&#39;a million&#39;, &#39;bereft of life&#39;, &#39;jump&#39;)         # 3 positional arguments
parrot(&#39;a thousand&#39;, state=&#39;pushing up the daisies&#39;)  # 1 positional, 1 keyword
# 无效调用
parrot()                     # required argument missing
parrot(voltage=5.0, &#39;dead&#39;)  # non-keyword argument after a keyword argument
parrot(110, voltage=220)     # duplicate value for the same argument
parrot(actor=&#39;John Cleese&#39;)  # unknown keyword argument
</code></pre>
<h5 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h5><ol>
<li>调用时，关键字参数必须跟在位置参数后面</li>
<li>关键字参数都必须匹配定义时候的参数名称</li>
<li>不能对同一个参数多次赋值</li>
<li>最后一个形参为<code>**name</code>形式的时候，接收一个字典 dict</li>
<li><code>**name</code> 形参可以与 <code>*name</code> 形参组合使用（<code>*name</code> 必须在 <code>**name</code> 前面）， <code>*name</code> 形参接收一个 元组，该元组包含形参列表之外的位置参数。</li>
</ol>
<pre><code class="py">def cheeseshop(kind, *arguments, **keywords):
    print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;)
    print(&quot;-- I&#39;m sorry, we&#39;re all out of&quot;, kind)
    for arg in arguments:
        print(arg)
    print(&quot;-&quot; * 40)
    for kw in keywords:
        print(kw, &quot;:&quot;, keywords[kw])

cheeseshop(&quot;Limburger&quot;, &quot;It&#39;s very runny, sir.&quot;,
           &quot;It&#39;s really very, VERY runny, sir.&quot;,
           shopkeeper=&quot;Michael Palin&quot;,
           client=&quot;John Cleese&quot;,
           sketch=&quot;Cheese Shop Sketch&quot;)
</code></pre>
<h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h4><ol>
<li>函数定义中未使用<code>/</code>和<code>*</code>时，参数按照位置或关键词传递给函数</li>
<li>仅限位置传参：<code>/</code></li>
<li>仅限关键字传参：<code>*</code></li>
</ol>
<pre><code class="py"># 正常传参
def standard_arg(arg):
    print(arg)
# 仅限使用位置形参
def pos_only_arg(arg, /):
    print(arg)
# 仅限关键词传参
def kwd_only_arg(*, arg):
    print(arg)
# 混合使用
def combined_example(pos_only, /, standard, *, kwd_only):
    print(pos_only, standard, kwd_only)

#报错：combined_example() takes 2 positional arguments but 3 were given
combined_example(1, 2, 3)
#正确：1，2，3
combined_example(1, 2, kwd_only=3)
#正确：1，2，3
combined_example(1, standard=2, kwd_only=3)
#报错：combined_example() got some positional-only arguments passed as keyword arguments: &#39;pos_only&#39;
combined_example(pos_only=1, standard=2, kwd_only=3)
</code></pre>
<pre><code class="bash">def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                  |
        |        Positional or keyword   |
        |                                - Keyword only
         -- Positional only
</code></pre>
<h4 id="任意实参列表"><a href="#任意实参列表" class="headerlink" title="任意实参列表"></a>任意实参列表</h4><p><code>*args</code> 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：</p>
<pre><code class="py">def write_multiple_items(file, separator, *args):
    file.write(separator.join(args))
</code></pre>
<h4 id="解包实参列表"><a href="#解包实参列表" class="headerlink" title="解包实参列表"></a>解包实参列表</h4><p>使用场景：函数调用要求独立的位置参数，但实参在列表或元组里<br>使用语法：</p>
<ul>
<li><code>*参数</code>：列表&#x2F;元组</li>
<li><code>**参数</code>：字典（对象）</li>
</ul>
<pre><code class="py"># 此处参数为列表
args = [3, 6] # args = (3, 6)也可以
list(range(*args))

# 解包字典
def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;):
    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)
    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&#39; &#39;)
    print(&quot;E&#39;s&quot;, state, &quot;!&quot;)
d = &#123;&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&#39; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;&#125;
parrot(**d)
</code></pre>
<h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>作用：用于创建匿名函数,常规函数定义的语法糖<br>语法：只能是单个表达式，返回值是是一个函数<br>不适合场景：创建逻辑复杂的函数<br>例子：<br><code>lambda a, b: a+b</code>函数返回两个参数之和</p>
<pre><code class="py">def make_incrementor(n):
    return lambda x: x + n
f = make_incrementor(42)
f(0) #42
f(1) #43
</code></pre>
<h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>特殊注释形式，对函数、类、模块等代码元素进行文档说明<br>访问：<code>__doc__</code><br>作用：</p>
<ol>
<li>自动生成代码的 api 文档</li>
<li>提供代码使用说明</li>
<li>提供内部实现说明</li>
</ol>
<p>docstring 约定：</p>
<ul>
<li>多行时，隔一行应为空白行</li>
<li>必须以大写字符开头，以<code>.</code>结尾</li>
</ul>
<h4 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h4><p>作用：为函数参数和返回值添加元数据或类型提示</p>
<blockquote>
<p>不会影响函数的实际行为，而是提供了额外的信息，可以被工具、IDE 和静态类型检查器等利用<br>函数注解使用<code>冒号（:）</code>后跟一个表达式来指定注解的内容。通常，注解可以是一个类型，也可以是任何其他有效的 Python 表达式。<br>和 TS 区别：这个不会影响运行，且不会强制执行</p>
</blockquote>
<pre><code class="py">def greet(name) :
    return f&quot;Hello, &#123;name&#125;!&quot;

def greet(name: str) -&gt; str:
    return f&quot;Hello, &#123;name&#125;!&quot;
# 鼠标悬浮到函数名称上可发现第一个里面的name显示为any类型
# 第二个显示为str
</code></pre>
<h2 id="c5-数据结构"><a href="#c5-数据结构" class="headerlink" title="c5. 数据结构"></a>c5. 数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol>
<li>list.append(x)：末尾添加元素，<code>a[len(a):] = [x] </code></li>
<li>list.extend(iterable)：用可迭代对象的元素扩展列表。 <code>a[len(a):] = iterable </code></li>
<li>list.insert(index, value):指定位置插入元素</li>
<li>list.remove(x):从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常</li>
<li>list.pop([index]):删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素,[]表示这是个可选参数</li>
<li>list.clear():删除列表里的所有元素</li>
<li>list.index(x[, start[, end]]):返回列表中第一个值为 x 的元素的零基索引.未找到指定元素时，触发 ValueError 异常。<blockquote>
<p>可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。</p>
</blockquote>
</li>
<li>list.count(x):返回列表中元素 x 出现的次数</li>
<li>list.sort(*, key&#x3D;None, reverse&#x3D;False):就地排序列表中的元素</li>
<li>list.reverse():反转列表元素</li>
<li>list.copy()：返回列表的浅拷贝。相当于 a[:]</li>
</ol>
<h4 id="实现堆栈"><a href="#实现堆栈" class="headerlink" title="实现堆栈"></a>实现堆栈</h4><p>特点：先进后出<br>借助 append 和 pop 方法</p>
<h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>特点：先进先出<br>借助 collections.deque</p>
<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>概念：通过对现有列表进行迭代和筛选，快速生成一个新的列表</p>
<pre><code class="py">squares = []
for x in range(10):
    squares.append(x**2)

# squares-&gt;[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>语法：new_list &#x3D; <code>[expression for item in iterable if condition]</code></p>
<ul>
<li>expression：应用于每个迭代项的表达式</li>
<li>item：从可迭代对象中取出的每个元素</li>
<li>iterable：表示可迭代对象</li>
<li>condition：可选的 条件表达式，用于筛选满足条件的元素</li>
</ul>
<pre><code class="py">numbers = [1, 2, 3, 4, 5]
squared_numbers = [num**2 for num in numbers if num % 2 == 0]
print(squared_numbers)  # 输出: [4, 16]

tuple=[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
# tuple值：[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
</code></pre>
<p>列表推导式可嵌套</p>
<pre><code class="py">matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
a= [[row[i] for row in matrix] for i in range(4)]
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre>
<h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>按索引而不是值从列表中移除条目</p>
<pre><code class="py">a = [-1, 1, 66.25, 333, 333, 1234.5]
del a[0]
# a:[1, 66.25, 333, 333, 1234.5]
del a[2:4]
# a:[1, 66.25, 1234.5]
del a[:]
# a:[]
del a
# 删除整个变量，之后不能再使用
</code></pre>
<h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p>序列：列表、字符串、元组、range<br>形式：元组由多个用逗号隔开的值组成</p>
<pre><code class="py">t = 12345, 54321, &#39;hello!&#39;
u = t, (1, 2, 3, 4, 5)
print(u)
</code></pre>
<p>元组可嵌套，所以上述最终结果为<code>((12345, 54321, &#39;hello!&#39;), (1, 2, 3, 4, 5))</code></p>
<h4 id="元组和列表区别"><a href="#元组和列表区别" class="headerlink" title="元组和列表区别"></a>元组和列表区别</h4><ol>
<li>元组是不可变的，适合存储一些不希望被修改的数据，如坐标、日期等</li>
<li>列表是可修改的，适合存储一些需要频繁修改的数据</li>
<li>元素在内存占用和访问上更有优势</li>
</ol>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>概念：由不重复元素组成的无序容器<br>作用：</p>
<ol>
<li>消除重复元素</li>
</ol>
<pre><code class="py">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;
print(basket)
# &#123;&#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;
a = set(&#39;abracadabra&#39;)
print(a)
# &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;&#125;
</code></pre>
<ol start="2">
<li>成员检测</li>
</ol>
<pre><code class="py">isExist=&#39;orange&#39; in basket #True
</code></pre>
<p>打印出来的值去除了重复的 apple 元素</p>
<h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>语法：使用<code>set()</code>函数或<code>&#123;&#125;</code></p>
<blockquote>
<p>创建空集合只能用 set()方法<br><code>&#123;&#125;</code>创建的是空字典</p>
</blockquote>
<pre><code class="py">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;
a = set(&#39;abracadabra&#39;)
</code></pre>
<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><ol>
<li><code>a-b</code>：差集，从 a 中去除 b 后剩余的集合</li>
<li><code>a|b</code>: 并集</li>
<li><code>a&amp;b</code>: 交集</li>
<li><code>a^b</code>: 异或</li>
</ol>
<h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><pre><code class="py">a = &#123;x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;&#125;
# &#123;r,d&#125;
</code></pre>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>本质：键值对 的集合，但键必须唯一<br>作用：通过 key 存取值<br>删除：使用 <code>del</code>，<br>返回所有键的列表：<code>list(dic)</code>,按插入次序排列<br>检查字典里是否有某个键：使用<code>in</code>关键字</p>
<h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><ol>
<li>字面值创建</li>
<li>dict()函数：<code>dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])</code></li>
</ol>
<h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>{x: x**2 for x in (2, 4, 6)}<br>结果：{2: 4, 4: 16, 6: 36}</p>
<h3 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h3><ol>
<li>items()方法：字典提取键及其对应的值</li>
</ol>
<pre><code class="py">knights = &#123;&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;&#125;
for k, v in knights.items():
    print(k, v)
</code></pre>
<ol start="2">
<li>enumerate()方法：在集合中同时取出位置索引和对应的值</li>
</ol>
<pre><code class="py">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
    print(i, v)
</code></pre>
<ol start="3">
<li>zip()方法：同时循环两个或多个序列时，将其内的元素一一匹配</li>
</ol>
<pre><code class="py">questions = [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;]
answers = [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;]
for q, a in zip(questions, answers):
    print(&#39;What is your &#123;0&#125;?  It is &#123;1&#125;.&#39;.format(q, a))
# q,a分别是2个列表的对应元素
</code></pre>
<h3 id="条件控制-deep"><a href="#条件控制-deep" class="headerlink" title="条件控制 deep"></a>条件控制 deep</h3><ol>
<li>in &amp; not in：成员检测</li>
<li>is &amp; is not：比较两个对象是否是同一个对象</li>
<li>所有比较运算符优先级相同且低于任何数值运算符</li>
<li>比较运算符支持链式操作<blockquote>
<p>a &lt; b &#x3D;&#x3D; c 校验 a 是否小于 b，且 b 是否等于 c。</p>
</blockquote>
</li>
<li>比较操作可以用布尔运算符 <code>and</code> 和 <code>or</code> 组合，并且，比较操作（或其他布尔运算）的结果都可以用 <code>not</code> 取反。not 的优先级最高， or 的优先级最低。</li>
<li>and&#x2F;or 是短路运算符，从左到右，一旦可以确定结果，求值就会立刻停止</li>
</ol>
<p>赋值：</p>
<ol>
<li>普通赋值</li>
<li>海象运算符：<code>:=</code><blockquote>
<p>第二种主要用于同时存在赋值和比较的情况</p>
</blockquote>
</li>
</ol>
<h2 id="c6-模块"><a href="#c6-模块" class="headerlink" title="c6. 模块"></a>c6. 模块</h2><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 <strong>模块</strong><br>使用：模块中的定义可以导入到其他模块或者主模块<br>命名：文件名&#x3D;模块名+’.py’</p>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h3><p>作用：查找模块定义的名称。返回结果是经过排序的字符串列表<br>有参数：查找指定模块定义的名称<br>无参数：列出当前已定义的名称</p>
<blockquote>
<p>不会列出内置函数和变量的名称。这些内容的定义在标准模块 builtins 中</p>
</blockquote>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>概念：通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式<br>例子：模块名 <code>A.B</code> 表示名为 A 的包中名为 B 的子模块<br>作用：避免不同包的模块名冲突</p>
<h4 id="从包中导入"><a href="#从包中导入" class="headerlink" title="从包中导入"></a>从包中导入</h4><ol>
<li><code>import sound.effects.echo</code></li>
<li><code>from sound.effects import echo</code></li>
<li><code>from sound.effects import * </code><blockquote>
<p>导入方式 3 中：模块中的所有公开对象和函数导入当前命名空间。这意味着可以直接使用模块中的对象和函数，而不需要使用模块前缀。</p>
</blockquote>
</li>
</ol>
<h4 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h4><pre><code class="py"># 绝对导入
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
# 相对导入（对于 surround 模块）
from . import echo
from .. import formats
from ..filters import equalizer
</code></pre>
<h2 id="c7-输入和输出"><a href="#c7-输入和输出" class="headerlink" title="c7. 输入和输出"></a>c7. 输入和输出</h2><p>TODO</p>
<h2 id="c8-错误和异常"><a href="#c8-错误和异常" class="headerlink" title="c8. 错误和异常"></a>c8. 错误和异常</h2><p>TODO</p>
<h2 id="c9-类"><a href="#c9-类" class="headerlink" title="c9. 类"></a>c9. 类</h2><p>作用：将数据和功能绑定在一起<br>特性：</p>
<ol>
<li>类的继承机制支持多个基类</li>
<li>派生的类能覆盖基类的方法</li>
<li>类的方法能够调用基类中的同名方法</li>
<li>在运行时创建，创建后还可修改</li>
</ol>
<h3 id="作用域和命名空间"><a href="#作用域和命名空间" class="headerlink" title="作用域和命名空间"></a>作用域和命名空间</h3><p>TODO:需要二次学习理解</p>
<h3 id="类定义语法"><a href="#类定义语法" class="headerlink" title="类定义语法"></a>类定义语法</h3><pre><code class="py">class 类名:
    语句
</code></pre>
<blockquote>
<p>TODO:与函数定义 (def 语句) 一样，类定义必须先执行才能生效。把类定义放在 if 语句的分支里或函数内部试试。[没理解]</p>
</blockquote>
<p>进入类定义时，会创建一个新的命名空间，将它作为局部作用域。</p>
<h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>类对象包括两种操作：</p>
<ul>
<li>属性引用：<code>obj.name</code></li>
<li>实例化：<code>obj()</code></li>
</ul>
<pre><code class="py">class MyClass:
    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;
    i = 12345

    def f(self):
        return &#39;hello world&#39;
</code></pre>
<p>上述代码，可以通过<code>MyClass.i</code>或者<code>MyClass.f</code>进行属性引用，分别返回一个 number 和一个 function，可以通过<code>MyClass.i=newValue</code>来修改它的值，但修改后会影响实例对应的值。<br>可以通过<code>MyClass()</code>进行实例化,返回一个类对象，可赋值给变量。本质是创建一个空对象。</p>
<h4 id="希望通过指定初始状态创建实例"><a href="#希望通过指定初始状态创建实例" class="headerlink" title="希望通过指定初始状态创建实例"></a>希望通过指定初始状态创建实例</h4><p>方法：定义<code>__init__()</code>方法</p>
<pre><code class="py">class A:
    def __init__(self,data):
        self.data=data
</code></pre>
<h3 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h3><p>作用:属性引用-数据属性+方法</p>
<h3 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h3><p>MyClass.f：函数对象<br>m.f:方法对象<br>区别：实例对象会作为函数的第一个参数被传入</p>
<h3 id="类和实例变量"><a href="#类和实例变量" class="headerlink" title="类和实例变量"></a>类和实例变量</h3><p>实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法<br>如果类定义中有同名的实例变量和类变量，各个实例将共享该变量，比如</p>
<pre><code class="py">class Dog:
    tricks = []             # mistaken use of a class variable
    def __init__(self, name):
        self.name = name
    def add_trick(self, trick):
        self.tricks.append(trick)

d = Dog(&#39;Fido&#39;)
e = Dog(&#39;Buddy&#39;)
d.add_trick(&#39;roll over&#39;)
e.add_trick(&#39;play dead&#39;)
d.tricks
</code></pre>
<p>此时类的实例对象 d 和 e 共享 tricks 这个变量</p>
<h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p>
<pre><code class="py">class Warehouse:
   purpose = &#39;storage&#39;
   region = &#39;west&#39;


w1 = Warehouse()
print(w1.purpose, w1.region)

w2 = Warehouse()
w2.region = &#39;east&#39;
print(w2.purpose, w2.region)
print(w1.purpose, w1.region)
</code></pre>
<p>此时第二次的 w1.region 依旧为 west</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>语法：</p>
<pre><code class="py">class 类名(基类模块名.基类名):
class 类名(基类名):
    &lt;statement-1&gt;
    &lt;statement-N&gt;
</code></pre>
<p>查询属性：<br>如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。<br>内置函数：</p>
<ol>
<li><p>isinstance() ：检查一个实例的类型: isinstance(obj, int) 仅会在 obj.<strong>class</strong> 为 int 或某个派生自 int 的类时为 True。</p>
</li>
<li><p>issubclass() ：检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int 的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类</p>
</li>
</ol>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>含义：一个类继承自多个类</p>
<pre><code class="py">class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    &lt;statement-N&gt;
</code></pre>
<p>理论上：D-&gt;B1-&gt;B1-super-&gt;B2-&gt;B2-super<br>实际上：方法解析顺序会动态改变以支持对 super() 的协同调用，只调用每个父类一次，并且保持单调</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>python 不存在实际意义上的私有变量（仅限一个对象内部访问）<br>日常开发中会以一个<strong>带下划线的名称</strong>，比如<code>_var</code>来表示这个函数&#x2F;方法&#x2F;数据成员应该被看作是非公有部分</p>
<pre><code class="py">class Mapping:
    def __init__(self, iterable):
        self.items_list = []
        self.__update(iterable)
    def update(self, iterable):
        for item in iterable:
            self.items_list.append(item)

    __update = update   # 私有化拷贝

class MappingSubclass(Mapping):
    def update(self, keys, values):
        # 提供update（）的新签名
        # 不会破坏 __init__()
        for item in zip(keys, values):
            self.items_list.append(item)
</code></pre>
<p>上面的代码中，</p>
<blockquote>
<p>名称改写：任何形式为 <code>__spam</code> 的标识符的文本将被替换为<code>_classname__spam</code>，其中<code>_classname</code>为去除了前缀下划线的当前类名称。支持需要私有变量的场景，避免父类和子类的名称冲突</p>
</blockquote>
<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><h2 id="c10-标准库-part1"><a href="#c10-标准库-part1" class="headerlink" title="c10. 标准库-part1"></a>c10. 标准库-part1</h2><h2 id="c11-标准库-part2"><a href="#c11-标准库-part2" class="headerlink" title="c11. 标准库-part2"></a>c11. 标准库-part2</h2><h2 id="c12-虚拟环境和包"><a href="#c12-虚拟环境和包" class="headerlink" title="c12. 虚拟环境和包"></a>c12. 虚拟环境和包</h2>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-10-16</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Python/'>
                            Python
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/Python/'>
                            Python
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>