<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="俄罗斯方块" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">备忘录/笔记本</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            俄罗斯方块
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-pygame"><span class="post-toc-text">初始化 pygame</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">主循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pygame-event-get-%E6%96%B9%E6%B3%95"><span class="post-toc-text">pygame.event.get()方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%BB%E9%9D%A2"><span class="post-toc-text">创建画面</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="post-toc-text">显示图片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-rect-%E6%96%B9%E6%B3%95"><span class="post-toc-text">get_rect()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#blit-image-position-%E6%96%B9%E6%B3%95"><span class="post-toc-text">blit(image,position)方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A9%E5%9B%BE%E7%89%87%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="post-toc-text">让图片动起来</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8E%BB%E6%8E%89%E6%AE%8B%E5%BD%B1"><span class="post-toc-text">去掉残影</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">控制移动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-pressed-%E6%96%B9%E6%B3%95"><span class="post-toc-text">get_pressed()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rect-move-ip-x-y-%E6%96%B9%E6%B3%95"><span class="post-toc-text">Rect.move_ip(x,y)方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">增加上下方向移动</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%9D%97%E7%B1%BB"><span class="post-toc-text">实现方块类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8"><span class="post-toc-text">在主函数中进行调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="post-toc-text">多实例</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8B%86%E5%88%86%E6%96%87%E4%BB%B6"><span class="post-toc-text">拆分文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E8%A1%A8%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="post-toc-text">逻辑和表现分离</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#transform-scale"><span class="post-toc-text">transform.scale()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%B9%E5%9D%97"><span class="post-toc-text">生成多个方块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%B8%B2%E6%9F%93%E6%96%B9%E5%9D%97"><span class="post-toc-text">主流程渲染方块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#relPos"><span class="post-toc-text">relPos</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%84%E5%90%88%E6%96%B9%E5%9D%97"><span class="post-toc-text">组合方块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BlockGroup-%E7%B1%BB"><span class="post-toc-text">BlockGroup 类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%8B%E8%90%BD"><span class="post-toc-text">模拟下落</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-Block-%E7%9A%84%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%B8%AA%E5%9D%97%E7%9A%84-drop-%E5%87%BD%E6%95%B0"><span class="post-toc-text">在 Block 的类中实现单个块的 drop 函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-BlockGroup-%E7%9A%84%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%B8%AA%E7%BB%84%E5%90%88%E5%9D%97%E7%9A%84%E4%B8%8B%E8%90%BD"><span class="post-toc-text">在 BlockGroup 的类中实现单个组合块的下落</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-main-%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8"><span class="post-toc-text">在 main 函数中调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81"><span class="post-toc-text">框架代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B8%B8%E6%88%8F%E4%B8%BB%E9%80%BB%E8%BE%91"><span class="post-toc-text">确定游戏主逻辑</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%B9%E5%9D%97%E7%BB%84%E7%9A%84%E5%A4%9A%E6%80%81"><span class="post-toc-text">方块组的多态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%9D%97%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E5%B8%B8%E9%87%8F"><span class="post-toc-text">定义方块组类型和一些其他常量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-BlockGroup-%E7%B1%BB%E4%B8%AD%E5%A2%9E%E5%8A%A0%E8%AF%A5-blockGroupType-%E5%8F%82%E6%95%B0"><span class="post-toc-text">在 BlockGroup 类中增加该 blockGroupType 参数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E8%B0%83%E6%95%B4"><span class="post-toc-text">游戏逻辑调整</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%A2%B0%E6%92%9E"><span class="post-toc-text">模拟碰撞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B0%81%E8%A3%85-blockGroup-%E4%B8%AD%E6%89%80%E6%9C%89-block-%E7%9A%84%E5%9D%90%E6%A0%87"><span class="post-toc-text">封装 blockGroup 中所有 block 的坐标</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89-blockGroup-%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="post-toc-text">定义 blockGroup 的增删改查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="post-toc-text">碰撞检测</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A3%80%E6%B5%8B%E5%88%B0%E7%A2%B0%E6%92%9E%E4%BB%A5%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="post-toc-text">检测到碰撞以后的处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">控制左右移动</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="post-toc-text">控制左右移动速度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#blockGroup-%E7%B1%BB%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E6%A3%80%E6%B5%8B%E5%87%BD%E6%95%B0-%E4%BB%A5%E6%AF%AB%E7%A7%92%E4%B8%BA%E5%8D%95%E4%BD%8D"><span class="post-toc-text">blockGroup 类新增一个时间检测函数(以毫秒为单位)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8"><span class="post-toc-text">调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%8B%E8%90%BD%E9%80%9F%E5%BA%A6"><span class="post-toc-text">控制下落速度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%B9%E5%9D%97%E6%97%8B%E8%BD%AC"><span class="post-toc-text">方块旋转</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BF%AE%E6%94%B9-block-%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="post-toc-text">修改 block 类的初始化函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%B9%E5%9D%97%E6%B6%88%E9%99%A4"><span class="post-toc-text">方块消除</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%93%E6%9D%9F%E6%B6%88%E9%99%A4"><span class="post-toc-text">结束消除</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%B1%E8%B4%A5%E5%88%A4%E5%AE%9A"><span class="post-toc-text">失败判定</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A1%E5%88%86%E8%A7%84%E5%88%99"><span class="post-toc-text">计分规则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%8B%E4%B8%AA%E6%96%B9%E5%9D%97"><span class="post-toc-text">下个方块</span></a></li></ol>
        
        <h2 id="初始化-pygame"><a href="#初始化-pygame" class="headerlink" title="初始化 pygame"></a>初始化 pygame</h2><ol>
<li>引入 pygame 包</li>
<li>调用 pygame 的 init 方法进行初始化</li>
</ol>
<pre><code class="py">import pygame
from pygame.locals import *

pygame.init()
</code></pre>
<p>2 个 import 的区别是：第二个 import 导出的变量可以直接使用，不需要加包名前缀</p>
<h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><ol>
<li>使用 set_mode 方法定义一个游戏窗口</li>
<li>使用 while 做一个死循环，使用 udpate 方法不断更新游戏窗口</li>
<li>添加退出机制</li>
</ol>
<pre><code class="py">pygame.init()
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
</code></pre>
<h3 id="pygame-event-get-方法"><a href="#pygame-event-get-方法" class="headerlink" title="pygame.event.get()方法"></a>pygame.event.get()方法</h3><p>作用：从事件队列中获取当前所有<em>挂起的事件</em>(事件队列中等待处理的事件)，并将其从事件队列中移除<br>在调用 pygame.event.get() 方法后，事件队列中不再保留这些事件，会被直接清空</p>
<h2 id="创建画面"><a href="#创建画面" class="headerlink" title="创建画面"></a>创建画面</h2><p>使用 set_mode 方法创建一个游戏窗口</p>
<pre><code class="py">pygame.init()
DISPLAYSURF=pygame.display.set_mode((800,600))
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
</code></pre>
<h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><ol>
<li>image.load 方法加载图片</li>
<li>get_rect 获取矩形</li>
<li>通过举行对象的 center 属性设置矩形中心点</li>
<li>使用 blit 方法绘制图片</li>
</ol>
<pre><code class="py">Image=pygame.image.load(&#39;../pic/red.png&#39;)
Rect=Image.get_rect()
Rect.center=(400,300)
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    pygame.display.update()
</code></pre>
<h3 id="get-rect-方法"><a href="#get-rect-方法" class="headerlink" title="get_rect()方法"></a>get_rect()方法</h3><p>作用：返回一个与图像大小相匹配的矩形对象，这个矩形可以用来定位、处理碰撞检测等操作<br>React 对象：包含了图片的位置和大小信息</p>
<h3 id="blit-image-position-方法"><a href="#blit-image-position-方法" class="headerlink" title="blit(image,position)方法"></a>blit(image,position)方法</h3><p>作用：将图像绘制到屏幕上<br>使用：调用 Surface 对象（比如游戏窗口或者其他画布）的 blit 方法</p>
<h2 id="让图片动起来"><a href="#让图片动起来" class="headerlink" title="让图片动起来"></a>让图片动起来</h2><p>本质上就是修改矩形对象的中心点</p>
<pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
</code></pre>
<h2 id="去掉残影"><a href="#去掉残影" class="headerlink" title="去掉残影"></a>去掉残影</h2><p>原因：每次渲染并不会清除上一帧的渲染结果<br>解决方法：每次渲染之前需要填充一次屏幕,可以使用 fill 方法</p>
<pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.fill((0,0,0))
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
</code></pre>
<h2 id="控制移动"><a href="#控制移动" class="headerlink" title="控制移动"></a>控制移动</h2><p>通过获取用户的输入来控制矩形对象的移动</p>
<pre><code class="py">pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
DISPLAYSURF.fill((0,0,0))
DISPLAYSURF.blit(Image,Rect)
pygame.display.update()
</code></pre>
<h3 id="get-pressed-方法"><a href="#get-pressed-方法" class="headerlink" title="get_pressed()方法"></a>get_pressed()方法</h3><p>作用：获取当前键盘按键状态<br>返回：一个包含所有按键当前状态的元组，对应的元素值是布尔类型。<br>原理：元组中的顺序与 pygame 中定义的键盘按键常量一一对应，所以可以通过 press[key]来判断</p>
<h3 id="Rect-move-ip-x-y-方法"><a href="#Rect-move-ip-x-y-方法" class="headerlink" title="Rect.move_ip(x,y)方法"></a>Rect.move_ip(x,y)方法</h3><p>作用：根据矩形对象当前的位置进行相对移动<br>移动方向：<br>矩形对象 rect，其初始位置为 (x1, y1)，调用 rect.move_ip(5, 10) 之后，矩形的位置将变为 (x1+5, y1+10)。也就是说，矩形会在水平方向上向右移动 5 个单位，在垂直方向上向下移动 10 个单位</p>
<h2 id="增加上下方向移动"><a href="#增加上下方向移动" class="headerlink" title="增加上下方向移动"></a>增加上下方向移动</h2><p>其实就是增加<code>K_UP</code>和<code>K_DOWN</code>的判断</p>
<pre><code class="py">pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
elif pressed[K_UP]:
    Rect.move_ip(0,-1)
elif pressed[K_DOWN]:
    Rect.move_ip(0,1)
</code></pre>
<h2 id="实现方块类"><a href="#实现方块类" class="headerlink" title="实现方块类"></a>实现方块类</h2><p>我们在上一步中绘制了一个方块并不断更新屏幕，而游戏是由很多个这样的方块组成的，所以我们可以将其封装成一个 Class。实现方块类主要有 2 个步骤</p>
<ol>
<li>定义初始化方法__init__,在初始化方法中定义需要的属性</li>
<li>定义方法</li>
</ol>
<p>首先，一个方块，应该有一个图像 image 用于绘制，然后还需要设置它的位置,即 rect。<br>其次，他需要一个 update 的更新方法，用于记录方块的运动，最后需要一个 draw 方法进行方块的绘制</p>
<pre><code class="py">class Block(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image=pygame.image.load(&#39;../pic/red.png&#39;)
        self.rect=self.image.get_rect()
        self.rect.center=(400,300)
    def update(self):
        pressed=pygame.key.get_pressed()
        if pressed[K_LEFT]:
            self.rect.move_ip(-1,0)
        elif pressed[K_RIGHT]:
            self.rect.move_ip(1,0)
        elif pressed[K_UP]:
            self.rect.move_ip(0,-1)
        elif pressed[K_DOWN]:
            self.rect.move_ip(0,1)
    def draw(self,surface):
        surface.blit(self.image,self.rect)
</code></pre>
<h3 id="在主函数中进行调用"><a href="#在主函数中进行调用" class="headerlink" title="在主函数中进行调用"></a>在主函数中进行调用</h3><ol>
<li>新建一个 Block 实例 b</li>
<li>调用 udpate 方法记录运动</li>
<li>调用 draw 方法绘制防窥啊</li>
</ol>
<pre><code class="py">b=Block()
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    b.update()
    DISPLAYSURF.fill((0,0,0))
    b.draw(DISPLAYSURF)
    pygame.display.update()
</code></pre>
<h2 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h2><p>多实例即需要使用不一样的图片和位置初始化 block 实例。所以可以将方块图片和位置作为 init 函数的参数</p>
<pre><code class="py">class BlockType:
    RED=0
    ORANGE=1
    YELLOW=2
    GREEN=3
    CYAN=4
    BLUE=5
    PURPLE=6
    BLOCKMAX=7

BLOCK_RES=&#123;
    BlockType.RED:&#39;../pic/red.png&#39;,
    BlockType.ORANGE:&#39;../pic/orange.png&#39;,
    BlockType.YELLOW:&#39;../pic/yellow.png&#39;,
    BlockType.GREEN:&#39;../pic/green.png&#39;,
    BlockType.CYAN:&#39;../pic/cyan.png&#39;,
    BlockType.BLUE:&#39;../pic/blue.png&#39;,
    BlockType.PURPLE:&#39;../pic/purple.png&#39;,
&#125;
class Block(pygame.sprite.Sprite):
    def __init__(self,blockType,pos):
        super().__init__()
        self.image=pygame.image.load(BLOCK_RES[blockType])
        self.rect=self.image.get_rect()
        self.rect.center=pos
</code></pre>
<h2 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h2><p>到上一步之后，目前的 main.py 代码行数已经较多，且 Block 类作为一个独立的类可以拆分到 block.py，项目中的常量可以拆分到 const.py</p>
<h2 id="逻辑和表现分离"><a href="#逻辑和表现分离" class="headerlink" title="逻辑和表现分离"></a>逻辑和表现分离</h2><p>希望可以根据方块类下、行&#x2F;列坐标、宽&#x2F;高以及相对位置来实现多态。根据传参来确定使用哪张图片、实际尺寸以及确定位置</p>
<pre><code class="py"># block.py
def __init__(self,blockType,rowIdx,colIdx,width,height,relPos):
    super().__init__()
    self.blockType=blockType
    self.rowIdx=rowIdx
    self.colIdx=colIdx
    self.width=width
    self.height=height
    self.relPos=relPos
    self.loadImage()
    self.updateImagePos()
def loadImage(self):
    self.image=pygame.image.load(BLOCK_RES[self.blockType])
    self.image=pygame.transform.scale(self.image,(self.width,self.height))
def updateImagePos(self):
    self.rect=self.image.get_rect()
    self.rect.left=self.relPos[0]+self.width*self.colIdx
    self.rect.top=self.relPos[1]+self.height*self.rowIdx
</code></pre>
<h3 id="transform-scale"><a href="#transform-scale" class="headerlink" title="transform.scale()"></a>transform.scale()</h3><p>作用：缩放图像<br>语法：<code>pygame.transform.scale(Surface, (width, height))</code></p>
<h3 id="生成多个方块"><a href="#生成多个方块" class="headerlink" title="生成多个方块"></a>生成多个方块</h3><pre><code class="py">blcoks=[]
for i in range(GAME_ROW):
    b=[]
    for j in range(GAME_COL):
        currentBlock=Block(random.randint(0,BLEND_MAX),i,j,32,32,(240,50))
        b.append(currentBlock)
    blcoks.append(b)
</code></pre>
<p>最终生成是数据如下(假设 GAME_ROW 为 3，GAME_COL 为 2)：</p>
<pre><code class="JS">[
    [Block(0, 0), Block(1, 0)],
    [Block(0, 1), Block(1, 1)],
    [Block(0, 2), Block(1, 2)]
]
</code></pre>
<h3 id="主流程渲染方块"><a href="#主流程渲染方块" class="headerlink" title="主流程渲染方块"></a>主流程渲染方块</h3><pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].update()
    DISPLAYSURF.fill((0,0,0))
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].draw(DISPLAYSURF)
    pygame.display.update()
</code></pre>
<h3 id="relPos"><a href="#relPos" class="headerlink" title="relPos"></a>relPos</h3><p>relPos 指的是左上方方块的矩形对象位置</p>
<h2 id="组合方块"><a href="#组合方块" class="headerlink" title="组合方块"></a>组合方块</h2><p>常见方块形状：</p>
<img src="/2023/11/10/e-luo-si-fang-kuai/block.png" class="">
<p>坐标含义：<br>每个元组 (x, y) 表示一个方块相对于参考点（通常是旋转中心）的偏移量。例如，(0, 0) 表示方块当前位置，(0, 1) 表示向上移动一个单位，(1, 0) 表示向右移动一个单位，以此类推。</p>
<pre><code class="py">BLOCK_SHAPE=[
    [(0,0),(0,1),(1,0),(1,1)], #方形
    [(0,0),(0,1),(0,2),(0,3)], #长条
    [(0,0),(0,1),(1,1),(1,2)], #z字形
    [(0,1),(1,0),(1,1),(1,2)]  #飞机形
]
</code></pre>
<h3 id="BlockGroup-类"><a href="#BlockGroup-类" class="headerlink" title="BlockGroup 类"></a>BlockGroup 类</h3><p>BlockGroup 需要一个 blockShape 和方块组合的配置</p>
<pre><code class="py">class BlockGroup(object):
    def GenerateBlockConfig(rowIdx,colIdx):
        idx=random.randint(0,len(BLOCK_SHAPE)-1)
        bType=random.randint(0,BlockType.BLOCKMAX-1)
        configList=[]
        for x in range(len(BLOCK_SHAPE[idx])):
            config=&#123;
                &#39;blockType&#39;:bType,
                &#39;rowIdx&#39;:rowIdx+BLOCK_SHAPE[idx][x][0],
                &#39;colIdx&#39;:colIdx+BLOCK_SHAPE[idx][x][1]
            &#125;
            configList.append(config)
        return configList

    def __init__(self,width,height,blockConfigList,relPos):
        super().__init__()
        self.blocks=[]
        for config in blockConfigList:
            blk=Block(config[&#39;blockType&#39;],config[&#39;rowIdx&#39;],config[&#39;colIdx&#39;],width,height,relPos)
            self.blocks.append(blk)

    def draw(self,surface):
        for b in self.blocks:
            b.draw(surface)
</code></pre>
<p>调用：</p>
<pre><code class="py">blockGroups=[]
for x in range(5):
    conf=BlockGroup.GenerateBlockConfig(x*4,x)
    blockGroups.append(BlockGroup(32,32,conf,(240,50)))


while True:
    for i in blockGroups:
       i.draw(DISPLAYSURF)
</code></pre>
<h2 id="模拟下落"><a href="#模拟下落" class="headerlink" title="模拟下落"></a>模拟下落</h2><h3 id="在-Block-的类中实现单个块的-drop-函数"><a href="#在-Block-的类中实现单个块的-drop-函数" class="headerlink" title="在 Block 的类中实现单个块的 drop 函数"></a>在 Block 的类中实现单个块的 drop 函数</h3><pre><code class="py">def drop(self):
    self.rowIdx+=1
    self.updateImagePos()
</code></pre>
<h3 id="在-BlockGroup-的类中实现单个组合块的下落"><a href="#在-BlockGroup-的类中实现单个组合块的下落" class="headerlink" title="在 BlockGroup 的类中实现单个组合块的下落"></a>在 BlockGroup 的类中实现单个组合块的下落</h3><pre><code class="py">def update(self):
    self.time+=1
    if self.time&gt;=1000:
        self.time=0
        for b in self.blocks:
            b.drop()
</code></pre>
<h3 id="在-main-函数中调用"><a href="#在-main-函数中调用" class="headerlink" title="在 main 函数中调用"></a>在 main 函数中调用</h3><pre><code class="py">blockGroups=[]
for x in range(5):
    conf=BlockGroup.GenerateBlockConfig(x*4,x)
    blockGroups.append(BlockGroup(32,32,conf,(240,50)))

while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    for i in blockGroups:
       i.update()
    DISPLAYSURF.fill((0,0,0))
    for i in blockGroups:
       i.draw(DISPLAYSURF)
    pygame.display.update()
</code></pre>
<h2 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h2><p>此时我希望主函数抽象成一个框架，而不需要关心实际游戏逻辑，期望它可以在做其他游戏的时候可以拿过来复用。<br>game 的 update 指的是逻辑帧，game.draw 是渲染帧</p>
<pre><code class="py">import pygame
from pygame.locals import *
import sys
from const import *
from block import *
from blockGroup import *
from game import *

pygame.init()
DISPLAYSURF=pygame.display.set_mode((800,600))
game=Game(DISPLAYSURF)
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    game.update() #逻辑帧
    DISPLAYSURF.fill((0,0,0))
    game.draw() #渲染帧
    pygame.display.update()
</code></pre>
<pre><code class="py">class Game(pygame.sprite.Sprite):
    def __init__(self,surface):
        super().__init__()
        self.surface=surface

    def update(self):
        pass

    def draw(self):
        pass
</code></pre>
<h2 id="确定游戏主逻辑"><a href="#确定游戏主逻辑" class="headerlink" title="确定游戏主逻辑"></a>确定游戏主逻辑</h2><p>俄罗斯方块游戏的实质：</p>
<p>一个静态的 BlockGroup 和一个下落的 BlockGroup 完成碰撞的过程。</p>
<ol>
<li>下落的 BlockGroup 在和静态的 BlockGroup 产生碰撞以后，就会被合并到静态的 BlockGroup</li>
<li>静态的 BlockGroup 从下往上判断，是否有一整行填充的方块，有则播放一个消去的动画，直到找不到整行的为止</li>
<li>继续生成下落的方块,重复上述步骤</li>
<li>当静态 blockGroup 达到一定高度则游戏失败。</li>
</ol>
<h2 id="方块组的多态"><a href="#方块组的多态" class="headerlink" title="方块组的多态"></a>方块组的多态</h2><h3 id="定义方块组类型和一些其他常量"><a href="#定义方块组类型和一些其他常量" class="headerlink" title="定义方块组类型和一些其他常量"></a>定义方块组类型和一些其他常量</h3><pre><code class="py">class BlockGroupType:
    FIXED:0
    DROP:1

BLOCK_SIZE_W=32
BLOCK_SIZE_H=32
</code></pre>
<h3 id="在-BlockGroup-类中增加该-blockGroupType-参数"><a href="#在-BlockGroup-类中增加该-blockGroupType-参数" class="headerlink" title="在 BlockGroup 类中增加该 blockGroupType 参数"></a>在 BlockGroup 类中增加该 blockGroupType 参数</h3><pre><code class="py">
    def __init__(self,blockGroupType,width,height,blockConfigList,relPos):
        super().__init__()
        self.blocks=[]
        self.time=0
        self.blockGroupTyp=blockGroupType
        for config in blockConfigList:
            blk=Block(config[&#39;blockType&#39;],config[&#39;rowIdx&#39;],config[&#39;colIdx&#39;],width,height,relPos)
            self.blocks.append(blk)
</code></pre>
<p>并且只有下落的方块组才执行时间判定</p>
<pre><code class="py">def update(self):
    self.time+=1
    if self.blockGroupType==BlockGroupType.DROP:
        if self.time&gt;=1000:
            self.time=0
            for b in self.blocks:
                b.drop()
</code></pre>
<h3 id="游戏逻辑调整"><a href="#游戏逻辑调整" class="headerlink" title="游戏逻辑调整"></a>游戏逻辑调整</h3><p>在 game 文件中，将 fixedBlockGroup 以及 dropBlockGroup 都实例化出来，update 函数就是执行两者的 update，并且如果没有下落类型，则随机生成一个,渲染函数同上</p>
<pre><code class="py">class Game(pygame.sprite.Sprite):
    def **init**(self,surface):
        super().__init__()
        self.surface=surface
        self.fixedBlockGroup=BlockGroup(BlockGroupType.FIXED,BLOCK_SIZE_W,BLOCK_SIZE_H,[],self.getRelPos())
        self.dropBlockGroup=None

    def generateDropBlockGroup(self):
        conf=BlockGroup.GenerateBlockGroupConfig(0,GAME_COL/2-1)
        self.dropBlockGroup=BlockGroup(BlockGroupType.DROP,BLOCK_SIZE_W,BLOCK_SIZE_H,conf,self.getRelPos())

    def update(self):
        # 执行两者的update
        self.fixedBlockGroup.update()
        if self.dropBlockGroup:
            self.dropBlockGroup.update()
        else :
            self.generateDropBlockGroup()

    def draw(self):
        self.fixedBlockGroup.draw(self.surface)
        if self.dropBlockGroup:
            self.dropBlockGroup.draw(self.surface)

    def getRelPos(self):
        return (240,50)
</code></pre>
<h2 id="模拟碰撞"><a href="#模拟碰撞" class="headerlink" title="模拟碰撞"></a>模拟碰撞</h2><p>原理：<br>计算 fixedBlockGroup 和 dropBlockGroup 的交集，如果 2 个 BlockGroup 集合产生交集，则认为发生了碰撞</p>
<h3 id="封装-blockGroup-中所有-block-的坐标"><a href="#封装-blockGroup-中所有-block-的坐标" class="headerlink" title="封装 blockGroup 中所有 block 的坐标"></a>封装 blockGroup 中所有 block 的坐标</h3><pre><code class="py">def getBlockIndexes(self):
    return [block.getIndex() for block in self.blocks]
def getNextBlockIndexes(self):
    return [block.getNextIndex() for block in self.blocks]
</code></pre>
<h3 id="定义-blockGroup-的增删改查"><a href="#定义-blockGroup-的增删改查" class="headerlink" title="定义 blockGroup 的增删改查"></a>定义 blockGroup 的增删改查</h3><pre><code class="py">def getBlocks(self):
    return self.blocks
def clearBlocks(self):
    self.blocks=[]
def addBlocks(self,blk):
    self.blocks.append(blk)
</code></pre>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><ol>
<li>将固定的 blockGroup 中所有的方块映射到 哈希表中</li>
<li>取下落的 blockGroup 中所有方块下落后的位置</li>
<li>去哈希表中进行查询，一旦找到，这个函数返回 True</li>
<li>如果超过游戏给定的行数，也返回 True，都代表产生了碰撞</li>
</ol>
<pre><code class="py">def willCollide(self):
    # 碰撞检测函数
    hash=&#123;&#125;
    allIndexes=self.fixedBlockGroup.getBlockIndexes()
    for idx in allIndexes:
        hash[idx]=1
    dropIndexes=self.dropBlockGroup.getNextBlockIndexes()
    for dropIdx in dropIndexes:
        if hash.get(dropIdx):
            return True
        if dropIdx[0]&gt;=GAME_ROW:
            return True
    return False
</code></pre>
<h3 id="检测到碰撞以后的处理"><a href="#检测到碰撞以后的处理" class="headerlink" title="检测到碰撞以后的处理"></a>检测到碰撞以后的处理</h3><ol>
<li>获取到所有的下落方块</li>
<li>将他们加入到固定方块中</li>
<li>清除所有的下落方块</li>
<li>将下落方块组对象设置为空即 None</li>
</ol>
<pre><code class="py">if self.willCollide():
    blocks=self.dropBlockGroup.getBlocks()
    for blk in blocks:
        self.fixedBlockGroup.addBlocks(blk)
    self.dropBlockGroup.clearBlocks()
    self.dropBlockGroup=None
</code></pre>
<h2 id="控制左右移动"><a href="#控制左右移动" class="headerlink" title="控制左右移动"></a>控制左右移动</h2><ol>
<li>删除 block 类中用于控制左右移动位移的 update 函数</li>
<li>在 blockGroup 类中增加一个键盘事件处理函数</li>
</ol>
<pre><code class="py">def keyDownHandler(self):
    pressed=pygame.key.get_pressed()
    if pressed[K_LEFT]:
        b=True
        for blk in self.blocks:
            if blk.isLeftBound():
                b=False
                break
        if b:
            for blk in self.blocks:
                blk.doLeft()
    elif pressed[K_RIGHT]:
        # 逻辑同上
</code></pre>
<ol start="3">
<li>在 blockGroup 的 update 函数中增加对上述函数的调用</li>
</ol>
<pre><code class="py">def update(self):
    self.time+=1
    if self.blockGroupType==BlockGroupType.DROP:
        if self.time&gt;=1000:
            self.time=0
            for b in self.blocks:
                b.drop()
        self.keyDownHandler()
</code></pre>
<h2 id="控制左右移动速度"><a href="#控制左右移动速度" class="headerlink" title="控制左右移动速度"></a>控制左右移动速度</h2><h3 id="blockGroup-类新增一个时间检测函数-以毫秒为单位"><a href="#blockGroup-类新增一个时间检测函数-以毫秒为单位" class="headerlink" title="blockGroup 类新增一个时间检测函数(以毫秒为单位)"></a>blockGroup 类新增一个时间检测函数(以毫秒为单位)</h3><p>超过 30 毫秒则为 True</p>
<pre><code class="py"># 检测上次按下时间
def checkAndSetPressTime(self,key):
    ret=False
    if getCurrentTime()-self.pressTime.get(key,0)&gt;30:
        ret=True
    self.pressTime[key]=getCurrentTime()
    return ret
</code></pre>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><pre><code class="py">def keyDownHandler(self):
    pressed=pygame.key.get_pressed()
    if pressed[K_LEFT] and self.checkAndSetPressTime(K_LEFT):
        b=True
        for blk in self.blocks:
            if blk.isLeftBound():
                b=False
                break
        if b:
            for blk in self.blocks:
                blk.doLeft()
</code></pre>
<h2 id="控制下落速度"><a href="#控制下落速度" class="headerlink" title="控制下落速度"></a>控制下落速度</h2><p>之前的下落速度是用自增计数器实现的</p>
<pre><code class="py">def update(self):
    self.time+=1
    if self.blockGroupType==BlockGroupType.DROP:
        if self.time&gt;=1000:
            self.time=0
            for b in self.blocks:
                b.drop()
</code></pre>
<p>这种实现方式取决于算法的执行效率，会导致结果不一样。所以需要用真实时间来做判定。记录当前时间和上一次掉落的时间差，如果大于等于这个时间间隔，则执行一次 drop 并把时间归零</p>
<pre><code class="py">    def update(self):
        oldTime=self.time
        curTime=getCurrentTime()
        diffTime=curTime-oldTime
        if self.blockGroupType==BlockGroupType.DROP:
            if diffTime&gt;=self.dropInterval:
                self.time=getCurrentTime()
                for b in self.blocks:
                    b.drop()
            self.keyDownHandler()
</code></pre>
<p>当用户点击下落见的时候，就把这个时间间隔调整为 100，否则调整 700</p>
<h2 id="方块旋转"><a href="#方块旋转" class="headerlink" title="方块旋转"></a>方块旋转</h2><p>传给 block 的是实际下标（在游戏的世界坐标系做操作），而 block 自身的旋转应该用局部坐标系。所以需要对现有的 Block_SHAPE 进行调整：</p>
<ul>
<li>第一维代表形状</li>
<li>第二维代表各种旋转的情况</li>
<li>第三维代表局部坐标</li>
</ul>
<pre><code class="py"># 方块形态
BLOCK_SHAPE=[
    [((0,0),(0,1),(1,0),(1,1)),], #方形
    [((0,0),(0,1),(0,2),(0,3)),((0,0),(1,0),(2,0),(3,0))], #长条
    [((0,0),(0,1),(1,1),(1,2)),((0,1),(1,0),(1,1),(2,0))], #z字形
    [((0,1),(1,0),(1,1),(1,2)),((0,1),(1,1),(1,2),(2,1)),((1,0),(1,1),(1,2),(2,1)),((0,1),(1,0),(1,1),(2,1))]  #飞机形
]
</code></pre>
<h3 id="修改-block-类的初始化函数"><a href="#修改-block-类的初始化函数" class="headerlink" title="修改 block 类的初始化函数"></a>修改 block 类的初始化函数</h3><pre><code class="py">    def __init__(self,blockType,baseRowIdx,baseColIdx,blockShape,blockRot,blockGroupIdx,width,height,relPos):
        super().__init__()
        self.blockType=blockType #颜色
        self.blockShape=blockShape #形状
        self.blockRot=blockRot # 旋转的下标
        self.baseRowIdx=baseRowIdx
        self.baseColIdx=baseColIdx
        self.blockGroupIdx=blockGroupIdx
        self.width=width
        self.height=height
        self.relPos=relPos
        self.loadImage()
        self.updateImagePos()
</code></pre>
<p>将参数中的全局坐标修改为局部坐标，通过 形状、旋转 以及相对下标就可以确定每个方块的绝对下标，左右移动，下落都应该是操作 相对下标。</p>
<pre><code class="py">def getBlockConfigIndex(self):
    return BLOCK_SHAPE[self.blockShape][self.blockRot][self.blockGroupIdx]
@property
def rowIdx(self):
    return self.baseRowIdx+self.getBlockConfigIndex()[0]
@property
def colIdx(self):
    return self.baseColIdx+self.getBlockConfigIndex()[1]
</code></pre>
<p>接下来还需要修改生成方块组配置的函数</p>
<pre><code class="py">def GenerateBlockGroupConfig(rowIdx,colIdx):
    shapeIdx=random.randint(0,len(BLOCK_SHAPE)-1)
    bType=random.randint(0,BlockType.BLOCKMAX-1)
    configList=[]
    rotIdx=0
    for x in range(len(BLOCK_SHAPE[shapeIdx][rotIdx])):
        config=&#123;
            &#39;blockType&#39;:bType,
            &#39;blockShape&#39;:shapeIdx,
            &#39;blockRot&#39;:rotIdx,
            &#39;blockGroupIdx&#39;:x,
            &#39;rowIdx&#39;:rowIdx,
            &#39;colIdx&#39;:colIdx,
        &#125;
        configList.append(config)
    return configList
</code></pre>
<p>有了这些之后再去修改方块的旋转函数</p>
<pre><code class="py"># 调用
if pressed[K_UP] and self.checkAndSetPressTime(K_UP):
    for blk in self.blocks:
        blk.doRotate()


def doRotate(self):
    self.blockRot+=1
    if self.blockRot&gt;=len(BLOCK_SHAPE[self.blockShape]):
        self.blockRot=0
</code></pre>
<h2 id="方块消除"><a href="#方块消除" class="headerlink" title="方块消除"></a>方块消除</h2><ol>
<li>消除的时候需要给方块一个闪烁效果，所以 block 初始化函数中增加 2 个属性<code>blink</code>和&#96;&#96;blinkCount<code>,记录每个 block 是否闪烁和闪烁次数,以及一个</code>blinkTime&#96;记录闪烁时间。</li>
<li>实现一个 startBlink 方法，并且在 update 的时候更新闪烁次数</li>
</ol>
<pre><code class="py">def startBlink(self):
    self.blink=True
    self.blinkTime=getCurrentTime()
def update(self):
    # 更新闪烁次数
    if self.blink:
        diffTime=getCurrentTime()-self.blinkTime
        self.blinkCount=int(diffTime/30)
</code></pre>
<ol start="3">
<li>在 BlockGroup 的 update 方法中调用</li>
</ol>
<pre><code class="py">def update(self):
    oldTime=self.time
    curTime=getCurrentTime()
    diffTime=curTime-oldTime
    if self.blockGroupType==BlockGroupType.DROP:
        if diffTime&gt;=self.dropInterval:
            self.time=getCurrentTime()
            for b in self.blocks:
                b.drop()
        self.keyDownHandler()
    for blk in self.blocks:
        blk.update()
</code></pre>
<ol start="4">
<li>执行渲染函数</li>
</ol>
<p>在 block 的渲染函数中，如果是闪烁状态且闪烁次数为奇数，则不进行绘制，这样就可以看到闪烁效果</p>
<pre><code class="py">def draw(self,surface):
    self.updateImagePos()
    if self.blink and self.blinkCount%2==1:
        return
    surface.blit(self.image,self.rect)
</code></pre>
<ol start="5">
<li>实现 blockGRoup 消除的逻辑</li>
</ol>
<p>单行 block 的消除</p>
<pre><code class="py">def doEliminate(self,row):
    eliminateRow=&#123;&#125;
    for col in range(0,GAME_COL):
        idx=(row,col)
        eliminateRow[idx]=1
    self.setEliminate(True)
    self.eliminateRow=row
    for blk in self.blocks:
        if eliminateRow.get(blk.getIndex()):
            blk.startBlink()
</code></pre>
<p>多行 block 的消除：</p>
<pre><code class="py">def processEliminate(self):
    hash=&#123;&#125;
    allIndexes=self.getBlockIndexes()
    for idx in allIndexes:
        hash[idx]=1
    for row in range(GAME_ROW-1,-1,-1):
        full=True
        for col in range(0,GAME_COL):
            idx=(row,col)
            if not(hash.get(idx)):
                full=False
                break
        if full:
            self.doEliminate(row)
            return
</code></pre>
<p>定义两个函数作为 isEliminating 的 getter 和 setter</p>
<pre><code class="py">def setEliminate(self,el):
    self.isEliminating=el
def IsEliminating(self):
    return self.isEliminating
</code></pre>
<p>在 game.py 中调用是否消除,如果正在消除状态就不执行接下来的逻辑</p>
<pre><code class="py">def update(self):
    # 执行两者的update
    self.fixedBlockGroup.update()
    if self.fixedBlockGroup.IsEliminating():
        return
    if self.dropBlockGroup:
        self.dropBlockGroup.update()
    else :
        self.generateDropBlockGroup()
    if self.willCollide():
        blocks=self.dropBlockGroup.getBlocks()
        for blk in blocks:
            self.fixedBlockGroup.addBlocks(blk)
        self.dropBlockGroup.clearBlocks()
        self.dropBlockGroup=None
        self.fixedBlockGroup.processEliminate()
</code></pre>
<h2 id="结束消除"><a href="#结束消除" class="headerlink" title="结束消除"></a>结束消除</h2><p>上一步骤中已经开始消除，但是实际上方块并没有消失，需要在 blockGroup 的 update 函数中执行</p>
<pre><code class="py">if self.IsEliminating():
    if getCurrentTime()-self.eliminateTime&gt;500:
        tmpBlocks=[]
        for blk in self.blocks:
            if blk.getIndex()[0]!=self.eliminateRow:
                if blk.getIndex()[0]&lt;self.eliminateRow:
                    blk.drop()
                tmpBlocks.append(blk)
        self.blocks=tmpBlocks
        self.setEliminate(False)
</code></pre>
<h2 id="失败判定"><a href="#失败判定" class="headerlink" title="失败判定"></a>失败判定</h2><p>在 Game 类的 init 函数中加载对应图片，定义一个 isGameOver 属性<br>在 update 函数中判断是否失败,在 draw 函数中通过判断状态展示失败图片</p>
<pre><code class="py">def update(self):
    if self.isGameOver:
        return
    self.checkGameOver()
def checkGameOver(self):
    allIndexes=self.fixedBlockGroup.getBlockIndexes()
    for idx in allIndexes:
        if idx[0]&lt;2:
            self.isGameOver=True

def draw():
    if self.isGameOver:
        self.surface.fill((0,0,0))
        rect=self.gameOverImage.get_rect()
        rect.centerx=GAME_WIDTH_SIZE/2
        rect.centery=GAME_HEIGHT_SIZE/2
        self.surface.blit(self.gameOverImage,rect)
</code></pre>
<h2 id="计分规则"><a href="#计分规则" class="headerlink" title="计分规则"></a>计分规则</h2><p>希望每次在消除一行的时候积分+1</p>
<pre><code class="py">self.scoreFont=pygame.font.Font(None,60)
self.score=0
# 更新
if self.fixedBlockGroup.processEliminate():
    self.score+=1
# 绘制
scoreTextImage=self.scoreFont.render(&#39;Score:&#39;+str(self.score),True,(255,255,255))
self.surface.blit(scoreTextImage,(10,20))
</code></pre>
<h2 id="下个方块"><a href="#下个方块" class="headerlink" title="下个方块"></a>下个方块</h2><pre><code class="py"> self.nextBlockGroup = None
</code></pre>
<p>实现一个生成下一个方块组的函数</p>
<pre><code class="py">def generateNextDropBlockGroup(self):
    conf=BlockGroup.GenerateBlockGroupConfig(0,GAME_COL+3)
    self.nextBlockGroup=BlockGroup(BlockGroupType.DROP,BLOCK_SIZE_W,BLOCK_SIZE_H,conf,self.getRelPos())
</code></pre>
<p>调整下落块和下一个方块组的位置</p>
<pre><code class="py">def setBaseIndexes(self,baseRow,baseCol):
    for blk in self.blocks:
        blk.setBaseIndex(baseRow,baseCol)
</code></pre>

    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-11-10</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/'>
                            游戏开发
                        </a>
                    
                        <a href='/tags/python/'>
                            python
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/python/'>
                            python
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>