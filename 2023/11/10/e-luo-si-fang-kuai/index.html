<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0,  viewport-fit=cover" name="viewport" />
    <meta name="description" content="俄罗斯方块" />
    <meta name="hexo-theme-A4" content="v1.7.1" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Diary</title>

    
        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
            
<link rel="stylesheet" href="/css/waline.css">

        
    
    
<link rel="stylesheet" href="/css/ui.css">
 
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    
<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Diary</a> 
            <span class="description">备忘录/笔记本</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            俄罗斯方块
        </div>
      
    

    <div class="post-md">
        
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-pygame"><span class="post-toc-text">初始化 pygame</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">主循环</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pygame-event-get-%E6%96%B9%E6%B3%95"><span class="post-toc-text">pygame.event.get()方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%BB%E9%9D%A2"><span class="post-toc-text">创建画面</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="post-toc-text">显示图片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-rect-%E6%96%B9%E6%B3%95"><span class="post-toc-text">get_rect()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#blit-image-position-%E6%96%B9%E6%B3%95"><span class="post-toc-text">blit(image,position)方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A9%E5%9B%BE%E7%89%87%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="post-toc-text">让图片动起来</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8E%BB%E6%8E%89%E6%AE%8B%E5%BD%B1"><span class="post-toc-text">去掉残影</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">控制移动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#get-pressed-%E6%96%B9%E6%B3%95"><span class="post-toc-text">get_pressed()方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rect-move-ip-x-y-%E6%96%B9%E6%B3%95"><span class="post-toc-text">Rect.move_ip(x,y)方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%B9%E5%90%91%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">增加上下方向移动</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%9D%97%E7%B1%BB"><span class="post-toc-text">实现方块类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%B0%83%E7%94%A8"><span class="post-toc-text">在主函数中进行调用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="post-toc-text">多实例</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8B%86%E5%88%86%E6%96%87%E4%BB%B6"><span class="post-toc-text">拆分文件</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%BB%E8%BE%91%E5%92%8C%E8%A1%A8%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="post-toc-text">逻辑和表现分离</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#transform-scale"><span class="post-toc-text">transform.scale()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E6%96%B9%E5%9D%97"><span class="post-toc-text">生成多个方块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%B8%B2%E6%9F%93%E6%96%B9%E5%9D%97"><span class="post-toc-text">主流程渲染方块</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#relPos"><span class="post-toc-text">relPos</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%84%E5%90%88%E6%96%B9%E5%9D%97"><span class="post-toc-text">组合方块</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#BlockGroup-%E7%B1%BB"><span class="post-toc-text">BlockGroup 类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%8B%E8%90%BD"><span class="post-toc-text">模拟下落</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81"><span class="post-toc-text">框架代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%B8%B8%E6%88%8F%E4%B8%BB%E9%80%BB%E8%BE%91"><span class="post-toc-text">确定游戏主逻辑</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BlockGroup-%E7%9A%84%E5%A4%9A%E6%80%81"><span class="post-toc-text">BlockGroup 的多态</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%A2%B0%E6%92%9E"><span class="post-toc-text">模拟碰撞</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8"><span class="post-toc-text">控制左右移动</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="post-toc-text">控制左右移动速度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%8B%E8%90%BD%E9%80%9F%E5%BA%A6"><span class="post-toc-text">控制下落速度</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%B9%E5%9D%97%E6%97%8B%E8%BD%AC"><span class="post-toc-text">方块旋转</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%96%B9%E5%9D%97%E6%B6%88%E9%99%A4"><span class="post-toc-text">方块消除</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%BB%93%E6%9D%9F%E6%B6%88%E9%99%A4"><span class="post-toc-text">结束消除</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%B1%E8%B4%A5%E5%88%A4%E5%AE%9A"><span class="post-toc-text">失败判定</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%AE%A1%E5%88%86%E8%A7%84%E5%88%99"><span class="post-toc-text">计分规则</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%8B%E4%B8%AA%E6%96%B9%E5%9D%97"><span class="post-toc-text">下个方块</span></a></li></ol>
        
        <h2 id="初始化-pygame"><a href="#初始化-pygame" class="headerlink" title="初始化 pygame"></a>初始化 pygame</h2><ol>
<li>引入 pygame 包</li>
<li>调用 pygame 的 init 方法进行初始化</li>
</ol>
<pre><code class="py">import pygame
from pygame.locals import *

pygame.init()
</code></pre>
<p>2 个 import 的区别是：第二个 import 导出的变量可以直接使用，不需要加包名前缀</p>
<h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><ol>
<li>使用 set_mode 方法定义一个游戏窗口</li>
<li>使用 while 做一个死循环，使用 udpate 方法不断更新游戏窗口</li>
<li>添加退出机制</li>
</ol>
<pre><code class="py">pygame.init()
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
</code></pre>
<h3 id="pygame-event-get-方法"><a href="#pygame-event-get-方法" class="headerlink" title="pygame.event.get()方法"></a>pygame.event.get()方法</h3><p>作用：从事件队列中获取当前所有<em>挂起的事件</em>(事件队列中等待处理的事件)，并将其从事件队列中移除<br>在调用 pygame.event.get() 方法后，事件队列中不再保留这些事件，会被直接清空</p>
<h2 id="创建画面"><a href="#创建画面" class="headerlink" title="创建画面"></a>创建画面</h2><p>使用 set_mode 方法创建一个游戏窗口</p>
<pre><code class="py">pygame.init()
DISPLAYSURF=pygame.display.set_mode((800,600))
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
</code></pre>
<h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><ol>
<li>image.load 方法加载图片</li>
<li>get_rect 获取矩形</li>
<li>通过举行对象的 center 属性设置矩形中心点</li>
<li>使用 blit 方法绘制图片</li>
</ol>
<pre><code class="py">Image=pygame.image.load(&#39;../pic/red.png&#39;)
Rect=Image.get_rect()
Rect.center=(400,300)
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    pygame.display.update()
</code></pre>
<h3 id="get-rect-方法"><a href="#get-rect-方法" class="headerlink" title="get_rect()方法"></a>get_rect()方法</h3><p>作用：返回一个与图像大小相匹配的矩形对象，这个矩形可以用来定位、处理碰撞检测等操作<br>React 对象：包含了图片的位置和大小信息</p>
<h3 id="blit-image-position-方法"><a href="#blit-image-position-方法" class="headerlink" title="blit(image,position)方法"></a>blit(image,position)方法</h3><p>作用：将图像绘制到屏幕上<br>使用：调用 Surface 对象（比如游戏窗口或者其他画布）的 blit 方法</p>
<h2 id="让图片动起来"><a href="#让图片动起来" class="headerlink" title="让图片动起来"></a>让图片动起来</h2><p>本质上就是修改矩形对象的中心点</p>
<pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
</code></pre>
<h2 id="去掉残影"><a href="#去掉残影" class="headerlink" title="去掉残影"></a>去掉残影</h2><p>原因：每次渲染并不会清除上一帧的渲染结果<br>解决方法：每次渲染之前需要填充一次屏幕,可以使用 fill 方法</p>
<pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.fill((0,0,0))
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
</code></pre>
<h2 id="控制移动"><a href="#控制移动" class="headerlink" title="控制移动"></a>控制移动</h2><p>通过获取用户的输入来控制矩形对象的移动</p>
<pre><code class="py">pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
DISPLAYSURF.fill((0,0,0))
DISPLAYSURF.blit(Image,Rect)
pygame.display.update()
</code></pre>
<h3 id="get-pressed-方法"><a href="#get-pressed-方法" class="headerlink" title="get_pressed()方法"></a>get_pressed()方法</h3><p>作用：获取当前键盘按键状态<br>返回：一个包含所有按键当前状态的元组，对应的元素值是布尔类型。<br>原理：元组中的顺序与 pygame 中定义的键盘按键常量一一对应，所以可以通过 press[key]来判断</p>
<h3 id="Rect-move-ip-x-y-方法"><a href="#Rect-move-ip-x-y-方法" class="headerlink" title="Rect.move_ip(x,y)方法"></a>Rect.move_ip(x,y)方法</h3><p>作用：根据矩形对象当前的位置进行相对移动<br>移动方向：<br>矩形对象 rect，其初始位置为 (x1, y1)，调用 rect.move_ip(5, 10) 之后，矩形的位置将变为 (x1+5, y1+10)。也就是说，矩形会在水平方向上向右移动 5 个单位，在垂直方向上向下移动 10 个单位</p>
<h2 id="增加上下方向移动"><a href="#增加上下方向移动" class="headerlink" title="增加上下方向移动"></a>增加上下方向移动</h2><p>其实就是增加<code>K_UP</code>和<code>K_DOWN</code>的判断</p>
<pre><code class="py">pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
elif pressed[K_UP]:
    Rect.move_ip(0,-1)
elif pressed[K_DOWN]:
    Rect.move_ip(0,1)
</code></pre>
<h2 id="实现方块类"><a href="#实现方块类" class="headerlink" title="实现方块类"></a>实现方块类</h2><p>我们在上一步中绘制了一个方块并不断更新屏幕，而游戏是由很多个这样的方块组成的，所以我们可以将其封装成一个 Class。实现方块类主要有 2 个步骤</p>
<ol>
<li>定义初始化方法__init__,在初始化方法中定义需要的属性</li>
<li>定义方法</li>
</ol>
<p>首先，一个方块，应该有一个图像 image 用于绘制，然后还需要设置它的位置,即 rect。<br>其次，他需要一个 update 的更新方法，用于记录方块的运动，最后需要一个 draw 方法进行方块的绘制</p>
<pre><code class="py">class Block(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image=pygame.image.load(&#39;../pic/red.png&#39;)
        self.rect=self.image.get_rect()
        self.rect.center=(400,300)
    def update(self):
        pressed=pygame.key.get_pressed()
        if pressed[K_LEFT]:
            self.rect.move_ip(-1,0)
        elif pressed[K_RIGHT]:
            self.rect.move_ip(1,0)
        elif pressed[K_UP]:
            self.rect.move_ip(0,-1)
        elif pressed[K_DOWN]:
            self.rect.move_ip(0,1)
    def draw(self,surface):
        surface.blit(self.image,self.rect)
</code></pre>
<h3 id="在主函数中进行调用"><a href="#在主函数中进行调用" class="headerlink" title="在主函数中进行调用"></a>在主函数中进行调用</h3><ol>
<li>新建一个 Block 实例 b</li>
<li>调用 udpate 方法记录运动</li>
<li>调用 draw 方法绘制防窥啊</li>
</ol>
<pre><code class="py">b=Block()
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    b.update()
    DISPLAYSURF.fill((0,0,0))
    b.draw(DISPLAYSURF)
    pygame.display.update()
</code></pre>
<h2 id="多实例"><a href="#多实例" class="headerlink" title="多实例"></a>多实例</h2><p>多实例即需要使用不一样的图片和位置初始化 block 实例。所以可以将方块图片和位置作为 init 函数的参数</p>
<pre><code class="py">class BlockType:
    RED=0
    ORANGE=1
    YELLOW=2
    GREEN=3
    CYAN=4
    BLUE=5
    PURPLE=6
    BLOCKMAX=7

BLOCK_RES=&#123;
    BlockType.RED:&#39;../pic/red.png&#39;,
    BlockType.ORANGE:&#39;../pic/orange.png&#39;,
    BlockType.YELLOW:&#39;../pic/yellow.png&#39;,
    BlockType.GREEN:&#39;../pic/green.png&#39;,
    BlockType.CYAN:&#39;../pic/cyan.png&#39;,
    BlockType.BLUE:&#39;../pic/blue.png&#39;,
    BlockType.PURPLE:&#39;../pic/purple.png&#39;,
&#125;
class Block(pygame.sprite.Sprite):
    def __init__(self,blockType,pos):
        super().__init__()
        self.image=pygame.image.load(BLOCK_RES[blockType])
        self.rect=self.image.get_rect()
        self.rect.center=pos
</code></pre>
<h2 id="拆分文件"><a href="#拆分文件" class="headerlink" title="拆分文件"></a>拆分文件</h2><p>到上一步之后，目前的 main.py 代码行数已经较多，且 Block 类作为一个独立的类可以拆分到 block.py，项目中的常量可以拆分到 const.py</p>
<h2 id="逻辑和表现分离"><a href="#逻辑和表现分离" class="headerlink" title="逻辑和表现分离"></a>逻辑和表现分离</h2><p>希望可以根据方块类下、行&#x2F;列坐标、宽&#x2F;高以及相对位置来实现多态。根据传参来确定使用哪张图片、实际尺寸以及确定位置</p>
<pre><code class="py"># block.py
def __init__(self,blockType,rowIdx,colIdx,width,height,relPos):
    super().__init__()
    self.blockType=blockType
    self.rowIdx=rowIdx
    self.colIdx=colIdx
    self.width=width
    self.height=height
    self.relPos=relPos
    self.loadImage()
    self.updateImagePos()
def loadImage(self):
    self.image=pygame.image.load(BLOCK_RES[self.blockType])
    self.image=pygame.transform.scale(self.image,(self.width,self.height))
def updateImagePos(self):
    self.rect=self.image.get_rect()
    self.rect.left=self.relPos[0]+self.width*self.colIdx
    self.rect.top=self.relPos[1]+self.height*self.rowIdx
</code></pre>
<h3 id="transform-scale"><a href="#transform-scale" class="headerlink" title="transform.scale()"></a>transform.scale()</h3><p>作用：缩放图像<br>语法：<code>pygame.transform.scale(Surface, (width, height))</code></p>
<h3 id="生成多个方块"><a href="#生成多个方块" class="headerlink" title="生成多个方块"></a>生成多个方块</h3><pre><code class="py">blcoks=[]
for i in range(GAME_ROW):
    b=[]
    for j in range(GAME_COL):
        currentBlock=Block(random.randint(0,BLEND_MAX),i,j,32,32,(240,50))
        b.append(currentBlock)
    blcoks.append(b)
</code></pre>
<p>最终生成是数据如下(假设 GAME_ROW 为 3，GAME_COL 为 2)：</p>
<pre><code class="JS">[
    [Block(0, 0), Block(1, 0)],
    [Block(0, 1), Block(1, 1)],
    [Block(0, 2), Block(1, 2)]
]
</code></pre>
<h3 id="主流程渲染方块"><a href="#主流程渲染方块" class="headerlink" title="主流程渲染方块"></a>主流程渲染方块</h3><pre><code class="py">while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].update()
    DISPLAYSURF.fill((0,0,0))
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].draw(DISPLAYSURF)
    pygame.display.update()
</code></pre>
<h3 id="relPos"><a href="#relPos" class="headerlink" title="relPos"></a>relPos</h3><p>relPos 指的是左上方方块的矩形对象位置</p>
<h2 id="组合方块"><a href="#组合方块" class="headerlink" title="组合方块"></a>组合方块</h2><p>常见方块形状：</p>
<img src="/2023/11/10/e-luo-si-fang-kuai/block.png" class="">
<p>坐标含义：<br>每个元组 (x, y) 表示一个方块相对于参考点（通常是旋转中心）的偏移量。例如，(0, 0) 表示方块当前位置，(0, 1) 表示向上移动一个单位，(1, 0) 表示向右移动一个单位，以此类推。</p>
<pre><code class="py">BLOCK_SHAPE=[
    [(0,0),(0,1),(1,0),(1,1)], #方形
    [(0,0),(0,1),(0,2),(0,3)], #长条
    [(0,0),(0,1),(1,1),(1,2)], #z字形
    [(0,1),(1,0),(1,1),(1,2)]  #飞机形
]
</code></pre>
<h3 id="BlockGroup-类"><a href="#BlockGroup-类" class="headerlink" title="BlockGroup 类"></a>BlockGroup 类</h3><p>BlockGroup 需要一个 blockShape 和方块组合的配置</p>
<pre><code class="py">class BlockGroup(object):
    def GenerateBlockConfig(rowIdx,colIdx):
        idx=random.randint(0,len(BLOCK_SHAPE)-1)
        bType=random.randint(0,BlockType.BLOCKMAX-1)
        configList=[]
        for x in range(len(BLOCK_SHAPE[idx])):
            config=&#123;
                &#39;blockType&#39;:bType,
                &#39;rowIdx&#39;:rowIdx+BLOCK_SHAPE[idx][x][0],
                &#39;colIdx&#39;:colIdx+BLOCK_SHAPE[idx][x][1]
            &#125;
            configList.append(config)
        return configList

    def __init__(self,width,height,blockConfigList,relPos):
        super().__init__()
        self.blocks=[]
        for config in blockConfigList:
            blk=Block(config[&#39;blockType&#39;],config[&#39;rowIdx&#39;],config[&#39;colIdx&#39;],width,height,relPos)
            self.blocks.append(blk)

    def draw(self,surface):
        for b in self.blocks:
            b.draw(surface)
</code></pre>
<p>调用：</p>
<pre><code class="py">blockGroups=[]
for x in range(5):
    conf=BlockGroup.GenerateBlockConfig(x*4,x)
    blockGroups.append(BlockGroup(32,32,conf,(240,50)))


while True:
    for i in blockGroups:
       i.draw(DISPLAYSURF)
</code></pre>
<h2 id="模拟下落"><a href="#模拟下落" class="headerlink" title="模拟下落"></a>模拟下落</h2><h2 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h2><h2 id="确定游戏主逻辑"><a href="#确定游戏主逻辑" class="headerlink" title="确定游戏主逻辑"></a>确定游戏主逻辑</h2><h2 id="BlockGroup-的多态"><a href="#BlockGroup-的多态" class="headerlink" title="BlockGroup 的多态"></a>BlockGroup 的多态</h2><h2 id="模拟碰撞"><a href="#模拟碰撞" class="headerlink" title="模拟碰撞"></a>模拟碰撞</h2><h2 id="控制左右移动"><a href="#控制左右移动" class="headerlink" title="控制左右移动"></a>控制左右移动</h2><h2 id="控制左右移动速度"><a href="#控制左右移动速度" class="headerlink" title="控制左右移动速度"></a>控制左右移动速度</h2><h2 id="控制下落速度"><a href="#控制下落速度" class="headerlink" title="控制下落速度"></a>控制下落速度</h2><h2 id="方块旋转"><a href="#方块旋转" class="headerlink" title="方块旋转"></a>方块旋转</h2><h2 id="方块消除"><a href="#方块消除" class="headerlink" title="方块消除"></a>方块消除</h2><h2 id="结束消除"><a href="#结束消除" class="headerlink" title="结束消除"></a>结束消除</h2><h2 id="失败判定"><a href="#失败判定" class="headerlink" title="失败判定"></a>失败判定</h2><h2 id="计分规则"><a href="#计分规则" class="headerlink" title="计分规则"></a>计分规则</h2><h2 id="下个方块"><a href="#下个方块" class="headerlink" title="下个方块"></a>下个方块</h2>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-11-10</span>
            
                <span>该篇文章被 Moon</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/'>
                            游戏开发
                        </a>
                    
                        <a href='/tags/python/'>
                            python
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/python/'>
                            python
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    
        
    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        以上。 
    </div>
    
        

    <div id="waline"></div>
    <script type="module"  >
        import { init } from 'https://npm.elemecdn.com/hexo-theme-a4@latest/source/js/waline.mjs'; 
        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://comment-hexo-waline.vercel.app/',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
                search: false, // 禁止表情包搜索
                reaction: false, // 对文章打分
                pageview: false, // 浏览量统计
                comment: false, // 评论数统计

                locale: {
                    placeholder: '正确的邮箱地址，回复将能得到邮件通知。', 
                    sofa: ''
                },
            });
            
        }
        window.addEventListener('DOMContentLoaded', loadWaline);
    </script>



    
    
    
    </div>


     
</div>



                    
                    
                    <div class="footer">
    
        <span> 
            ©2021-2023 China 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
    
</div>


    
<link rel="stylesheet" href="/css/a11y-dark.min.css">

    
<script src="/js/highlight.min.js"></script>

    
<script src="/js/highlightjs-line-numbers.js"></script>



<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
                </div>
            
    </body>
</html>