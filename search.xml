<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pygame笔记</title>
      <link href="/2023/10/20/pygame-bi-ji/"/>
      <url>/2023/10/20/pygame-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="如何在本地阅读-pygame-文档"><a href="#如何在本地阅读-pygame-文档" class="headerlink" title="如何在本地阅读 pygame 文档"></a>如何在本地阅读 pygame 文档</h2><p>执行<code>python -m pygame.docs</code></p><h2 id="python-适合哪些游戏开发"><a href="#python-适合哪些游戏开发" class="headerlink" title="python 适合哪些游戏开发"></a>python 适合哪些游戏开发</h2><p>游戏&#x3D;游戏引擎+游戏逻辑<br>过去：引擎（汇编语言）+逻辑（c 语言）<br>现在：引擎（c 语言）+ 逻辑（更高级的脚本语言）<br>pygame:</p><ul><li>适合 2D 游戏开发</li><li>可以跨平台运行</li></ul><h2 id="导入和初始化"><a href="#导入和初始化" class="headerlink" title="导入和初始化"></a>导入和初始化</h2><ul><li><code>import pygame</code>：导入 pygame 包，里面包含所有可用的模块</li><li><code>pygame.init()</code>：初始化导入的所有模块</li><li><code>pygame.display.set_mode((1280, 720))</code>：设置游戏窗口大小并新建游戏的图形窗口<blockquote><p>创建了一个新的 Surface 对象代表实际展示的图形化窗口</p></blockquote></li><li><code>img=pygame.image.load(&quot;intro_ball.gif&quot;)</code>：加载图片</li><li><code>img.get_react()</code>：工具对象类型<code>Rect</code>,代表 1 块矩形区域</li><li><code>ballrect = ballrect.move([2,2])</code>：移动图像 ballrect</li><li><code>screen.fill(black)</code>：清空屏幕<blockquote><p>电脑的动画是一系列的单图实现的，它们依次展示，让人视觉上是移动的。如果不使用 fill()方法，视觉上就会是运动轨迹</p><img src="/2023/10/20/pygame-bi-ji/no_fill.png" class=""></blockquote></li><li><code>screen.blit(sourceImg, Distination,area=None,)</code>：将图片绘制到另一个图像或者屏幕上</li><li><code>pygame.display.flip()</code>：更新屏幕展示</li></ul><h3 id="超出图形化窗口边界成处理"><a href="#超出图形化窗口边界成处理" class="headerlink" title="超出图形化窗口边界成处理"></a>超出图形化窗口边界成处理</h3><pre><code class="py">if ballrect.left &lt; 0 or ballrect.right &gt; width:    speed[0] = -speed[0]if ballrect.top &lt; 0 or ballrect.bottom &gt; height:    speed[1] = -speed[1]</code></pre><h2 id="如何使得游戏循环运行"><a href="#如何使得游戏循环运行" class="headerlink" title="如何使得游戏循环运行"></a>如何使得游戏循环运行</h2><p>FPS:游戏画面每秒更新的次数</p><pre><code class="py">import pygame# pygame设置pygame.init()screen = pygame.display.set_mode((1280, 720))clock = pygame.time.Clock()running = Truewhile running:    # poll for events    # pygame.QUIT 事件意味着用户点击X关闭了弹窗    for event in pygame.event.get():        if event.type == pygame.QUIT:            running = False    # 使用一种颜色填充屏幕，清除上一帧留下的所有东西    screen.fill(&quot;purple&quot;)    # 此处渲染游戏    # ...    # flip() 将成果展示在屏幕上    pygame.display.flip()    clock.tick(60)  # 限制 FPS 为 60pygame.quit()</code></pre><h2 id="pygame-移动游戏元素"><a href="#pygame-移动游戏元素" class="headerlink" title="pygame 移动游戏元素"></a>pygame 移动游戏元素</h2><pre><code class="py">import pygamepygame.init()screen=pygame.display.set_mode((800,600))clock=pygame.time.Clock()running=Truedt=0player_pos=pygame.Vector2(screen.get_width()/2,screen.get_height()/2)while running:    for event in pygame.event.get():        if event.type==pygame.QUIT:            running=False    screen.fill(&quot;purple&quot;)    # 游戏代码==========================================    pygame.draw.circle(screen,&quot;red&quot;,player_pos,40)    keys=pygame.key.get_pressed()    if keys[pygame.K_w]:        player_pos.y-= 300 * dt    if keys[pygame.K_s]:        player_pos.y+= 300 * dt    if keys[pygame.K_a]:        player_pos.x-=300*dt    if keys[pygame.K_d]:        player_pos.x+=300*dt           # dt is delta time in seconds since last frame, used for framerate-    # independent physics.    # 两个连续帧之间的时间差（秒）    dt = clock.tick(60)    pygame.display.flip()pygame.quit()</code></pre><h2 id="pygame-如何处理文件系统路径"><a href="#pygame-如何处理文件系统路径" class="headerlink" title="pygame 如何处理文件系统路径"></a>pygame 如何处理文件系统路径</h2><p>TODO</p><h2 id="pygame-display-update-VS-pygame-display-flip"><a href="#pygame-display-update-VS-pygame-display-flip" class="headerlink" title="pygame.display.update() VS pygame.display.flip()"></a>pygame.display.update() VS pygame.display.flip()</h2><p>相同点：两者都是用于更新屏幕显示的函数<br>区别：</p><ul><li><p><code>pygame.display.update()</code>：根据需要更新指定的区域或整个屏幕。它接受一个可选的参数，该参数是一个矩形列表，表示要更新的区域。如果不提供参数，它将更新整个屏幕。这个函数的优点是可以选择性地更新屏幕的特定区域，从而减少更新帧的计算量，提高性能。</p></li><li><p><code>pygame.display.flip()</code>：将当前内存中的所有改变刷新到屏幕上。它没有任何参数，每次调用它都会更新整个屏幕。这个函数的优点是简单易用，适用于大多数情况下。</p></li></ul><h2 id="blit"><a href="#blit" class="headerlink" title="blit()"></a>blit()</h2><p>语法：<code>target_surface.blit(source_surface, position)</code><br>作用：将图像（Surface 对象）绘制到其他 Surface 上的函数<br>示例代码</p><pre><code class="py">img=pygame.image.load(&#39;../pic/yellow.png&#39;)rect=img.get_rect()rect.center=(400,300)screen.blit(img,rect)</code></pre><h2 id="移动对象"><a href="#移动对象" class="headerlink" title="移动对象"></a>移动对象</h2><h3 id="move-ip"><a href="#move-ip" class="headerlink" title="move_ip()"></a>move_ip()</h3><p>语法：<code>rect.move_ip(dx, dy)</code></p><blockquote><p>dx 和 dy 分别代表 x、y 轴上的偏移量，y 方向上 <code>up</code> 为-1，x 方向上 <code>right</code> 为 1</p></blockquote><p>作用：移动图像或矩形的位置。是在 Rect 对象上调用的方法，而不是直接在 Surface 上使用的。直接修改原始对象的位置<br>示例代码</p><pre><code class="py">pressed=pygame.key.get_pressed()if pressed[K_LEFT]:    rect.move_ip(-1,0)elif pressed[K_RIGHT]:    rect.move_ip(1,0)elif pressed[K_UP]:    rect.move_ip(0,-1)elif pressed[K_DOWN]:    rect.move_ip(0,1)</code></pre><h3 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h3><p>语法：<code>rect.move(dx, dy)</code><br>作用：move() 方法返回一个新的矩形对象，而不直接修改原始对象。如果要保留原始矩形对象并获得移动后的副本，可以使用 move()</p><pre><code class="py">pressed=pygame.key.get_pressed()if pressed[K_LEFT]:    rect=rect.move_ip(-1,0)elif pressed[K_RIGHT]:    rect=rect.move(1,0)elif pressed[K_UP]:    rect=rect.move(0,-1)elif pressed[K_DOWN]:    rect=rect.move_ip(0,1)</code></pre><h2 id="scale"><a href="#scale" class="headerlink" title="scale()"></a>scale()</h2><p>语法：<code>scaled_surface = pygame.transform.scale(surface, size)</code><br>作用：缩放图像或 Surface 的大小。它可以按照指定的比例因子来缩放图像，也可以根据给定的目标尺寸进行缩放。<br>参数：size 是一个元组，表示目标尺寸 (width, height)<br>示例代码：</p><pre><code class="py">def loadImage(self):    self.img=pygame.image.load(BLOCK_RES[self.blockType])    self.img=pygame.transform.scale(self.img,(self.width,self.height))</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pygame </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法</title>
      <link href="/2023/10/16/python-ji-chu-yu-fa/"/>
      <url>/2023/10/16/python-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="c2-解释器"><a href="#c2-解释器" class="headerlink" title="c2. 解释器"></a>c2. 解释器</h2><p>前提：安装 python 并将安装路径添加到环境变量中</p><h3 id="调用解释器"><a href="#调用解释器" class="headerlink" title="调用解释器"></a>调用解释器</h3><h4 id="启动解释器方式："><a href="#启动解释器方式：" class="headerlink" title="启动解释器方式："></a>启动解释器方式：</h4><ol><li><code>py xx.py</code> 或者 <code>python xx.py</code></li><li><code>python -c command [arg] ...</code>,命令最好用引号包裹</li><li><code>python -m module [arg] ...</code>,在命令行下直接运行 Python 模块</li></ol><blockquote><p>区别：方法 2 是执行 command 中的语句,类似于 shell -c,方法 3 会将模块作为主程序运行，模块通过名称区分</p></blockquote><pre><code class="py"># my_module.pydef greet(name):    print(f&quot;Hello, &#123;name&#125;!&quot;)# 外部调用python -m my_module</code></pre><h4 id="退出解释器方法："><a href="#退出解释器方法：" class="headerlink" title="退出解释器方法："></a>退出解释器方法：</h4><ol><li><code>CTRL+Z</code>+<code>Enter</code></li><li><code>exit()</code></li></ol><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><ol><li>主提示符<code>&gt;&gt;&gt;</code>:提示输入下一条指令</li><li>次要提示符<code>...</code>:提示输入连续行</li></ol><blockquote><p>输入多行架构的语句时，要用连续行</p></blockquote><h3 id="解释器和环境"><a href="#解释器和环境" class="headerlink" title="解释器和环境"></a>解释器和环境</h3><p>默认编码：UTF-8<br>指定编码方式：通过注释实现：<code># -*- coding: encoding -*-</code></p><blockquote><p>指定编码需要和 vscode 底部的编码方式保持一致，否则会报错 SyntaxError: encoding problem: GB2312 或者乱码</p></blockquote><pre><code class="py">#!/usr/bin/env python3# -*- coding: gb2312 -*-</code></pre><h2 id="c3-Python-非正式介绍"><a href="#c3-Python-非正式介绍" class="headerlink" title="c3. Python 非正式介绍"></a>c3. Python 非正式介绍</h2><h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p>注释：python 注释以<code>#</code>开头，直到该行结束</p><h4 id="算术运算符："><a href="#算术运算符：" class="headerlink" title="算术运算符：+,-,*,/"></a>算术运算符：<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code></h4><p>特殊算术运算符：</p><ul><li><code>//</code>：取整 5&#x2F;&#x2F;2&#x3D;2</li><li><code>%</code>：取余 5%2&#x3D;1</li><li><code>**</code>：乘方 5**2&#x3D;25</li><li><code>=</code>：赋值 a&#x3D;3</li></ul><blockquote><ol><li>普通除法的返回值一直是浮点数。</li><li>交互模式下，前一次输出的表达式会赋值给变量<code>_</code>,并且避免给这个变量显式赋值</li></ol></blockquote><h4 id="文本类型-str"><a href="#文本类型-str" class="headerlink" title="文本类型 str"></a>文本类型 str</h4><p>单行字符串：使用单引号或者双引号包裹<br>多行字符串：使用三重引号包裹<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>或者<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code><br>转义：<code>\</code>+字符<br>不转义：<code>print(r&#39;a\b&#39;)</code><br>合并重复: +和*<br>字符串长度：<code>len(str1)</code></p><blockquote><p>自动合并：相邻的两个或多个 字符串<strong>字面值</strong> （引号标注的字符）会自动合并。</p></blockquote><blockquote><p>支持下标(正负数)访问和切片<code>word[0:3]</code>:包含 0-2 的字符的子串<br>word[0:],word[-2:]包含了<code>stop</code>下标,字符串中单个字符不可修改</p></blockquote><pre><code class="py"># 3 times &#39;un&#39;, followed by &#39;ium&#39;3 * &#39;un&#39; + &#39;ium&#39;# 输出结果：&#39;unununium&#39;s=&#39;Py&#39; &#39;thon&#39;# 输出结果：Python</code></pre><h4 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h4><p>使用<code>[]</code>进行包裹，支持不同类型数据组合,可以嵌套<br>单个元素可以通过下标或者切片修改<br>获取列表长度：<code>len(list1)</code><br>列表末尾添加新元素：<code>cubes.append(216) </code><br>合并列表:<code>squares + [36, 49, 64, 81, 100]</code></p><h3 id="python-编程第一步"><a href="#python-编程第一步" class="headerlink" title="python 编程第一步"></a>python 编程第一步</h3><p>缩进是 python 组织语句结构的方式<br>print()可以传多个参数，通过<code>,</code>分隔，比如 <code>print(&#39;a&#39;,&#39;b&#39;)</code>打印出来的结果是：<code>a b</code></p><h2 id="c4-控制流"><a href="#c4-控制流" class="headerlink" title="c4. 控制流"></a>c4. 控制流</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><pre><code class="py">x=input(&#39;请输入：&#39;)x=int(x)if x &lt; 0:    x = 0    print(&#39;Negative changed to zero&#39;)elif x == 0:    print(&#39;Zero&#39;)else:    print(&#39;More&#39;)</code></pre><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>形式：<code>for item in 列表/字符串</code><br>注意点：</p><ul><li>python 本身不支持通过下标进行迭代，即<code>for (int i = 0; i &lt; 10; i++)</code>这样的形式，而是按顺序遍历可迭代对象（如列表、字符串等）中的元素。</li></ul><pre><code class="py">words = [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]for w in words:    print(w, len(w))</code></pre><ul><li>如果需要下标进行迭代的话，可使用<code>enumerate</code>将列表或字符串作为参数</li></ul><pre><code class="py">words = [&#39;cat&#39;, &#39;window&#39;, &#39;defenestrate&#39;]for index,value in enumerate(words):    print(&#39;index&#39;,index,&#39;value&#39;,value)</code></pre><h4 id="修改迭代对象中的内容"><a href="#修改迭代对象中的内容" class="headerlink" title="修改迭代对象中的内容"></a>修改迭代对象中的内容</h4><p>推荐方法：迭代多项集的副本或者创建新的多项集<br>不推荐：通过下标修改<br>原因：如果在循环体中修改了该集合的内容（增删改），可能会导致迭代过程出现意外的行为。因为修改集合后，原始集合的长度和结构发生了变化，而迭代器无法正确地处理这种变化。</p><pre><code class="py"># 正确做法users = &#123;&#39;Hans&#39;: &#39;active&#39;, &#39;Éléonore&#39;: &#39;inactive&#39;, &#39;景太郎&#39;: &#39;active&#39;&#125;# Strategy:  迭代副本for user, status in users.copy().items():    if status == &#39;inactive&#39;:        del users[user]# Strategy:  创建一个新的集合active_users = &#123;&#125;for user, status in users.items():    if status == &#39;active&#39;:        active_users[user] = statusprint(users,active_users)</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><p>作用：用于生成等差数列,生成的数列左闭右开</p><ul><li>&#96;&#96;range(num)&#96;:从 0 开始生成 0 一直到 num-1 的数列</li><li><code>range(start,end)</code>:从 start 开始生成一直到 end-1 的数列</li><li><code>range(start,end,step)</code>:从 start 开始按照 step 步长生成一直到 end-1 的数列<br>应用：按照索引迭代序列</li></ul><pre><code class="py">a = [&#39;Mary&#39;, &#39;had&#39;, &#39;a&#39;, &#39;little&#39;, &#39;lamb&#39;]for i in range(len(a)):    print(i, a[i])</code></pre><h3 id="break-x2F-continue-语句和循环上的-else-子句"><a href="#break-x2F-continue-语句和循环上的-else-子句" class="headerlink" title="break&#x2F;continue 语句和循环上的 else 子句"></a>break&#x2F;continue 语句和循环上的 else 子句</h3><p>break 语句：跳出最近一层的 for&#x2F;while 循环<br>continue 语句：执行循环的下一次迭代<br>else 子句：for 或 while 循环可以包括 else 子句</p><pre><code class="py">for n in range(2, 10):    for x in range(2, n):        if n % x == 0:            print(n, &#39;equals&#39;, x, &#39;*&#39;, n//x)            break    else:        # loop fell through without finding a factor        print(n, &#39;is a prime number&#39;)</code></pre><h4 id="for-x2F-while-中的-else-子句"><a href="#for-x2F-while-中的-else-子句" class="headerlink" title="for&#x2F;while 中的 else 子句"></a>for&#x2F;while 中的 else 子句</h4><p>else 子句和 for&#x2F;while 同级</p><pre><code class="py"># for 循环中的 else 子句for item in iterable:    # 循环体else:    # 循环正常完成时执行的逻辑# while 循环中的 else 子句while condition:    # 循环体else:    # 循环条件为假时执行的逻辑</code></pre><p>执行时机不一样<br>for：如果 for 循环正常完成（即<strong>没有通过 break 语句</strong>提前退出），则执行 else 块中的代码</p><pre><code class="py"># for 循环中的 else 子句for i in range(5):    print(i)else:    print(&quot;For loop completed&quot;)# 结果01234For loop completed</code></pre><p>while：如果 while 循环的条件为假，即<strong>终止了循环（不再满足循环条件）</strong>，则执行 else 块中的代码.同样如果中途有 break 语句则不会执行 else 子句</p><pre><code class="py"># while 循环中的 else 子句x = 0while x &lt; 5:    print(x)    x += 1else:    print(&quot;While loop condition is false&quot;)</code></pre><h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>不执行任何动作。<br>使用场景：语法上需要语句，但程序不需要执行任何动作</p><ol><li>在定义一个函数或类时，如果函数或类体内还没有具体的实现，可以使用 pass 语句来占位</li></ol><pre><code class="py">def my_function():    passclass MyClass:    pass</code></pre><ol start="2"><li>开发过程中，当你想跳过某些代码块的执行时，可以使用 pass 语句作为占位符，以后再进行实现</li></ol><pre><code class="py">if condition_1:    # 处理condition_1的情况elif condition_2:    pass  # 暂时不需要处理condition_2的情况else:    # 处理其他情况</code></pre><h3 id="match-语句"><a href="#match-语句" class="headerlink" title="match 语句"></a>match 语句</h3><p>作用：接受一个表达式并把它的值与一个或多个 case 块给出的一系列模式进行比较<br>本质：模式匹配<br>如果都不匹配，会执行<code>case _</code>,这个相当于 js 中的 default 分支</p><pre><code class="py">def http_error(status):    match status:        case 400|500:            return &quot;Bad request&quot;        case 404:            return &quot;Not found&quot;        case 418:            return &quot;I&#39;m a teapot&quot;        case _:            return &quot;Something&#39;s wrong with the internet&quot;def http_error2(point):    match point:        case (0, 0):            print(&quot;Origin&quot;)        case (0, y):            print(f&quot;Y=&#123;y&#125;&quot;)        case (x, 0):            print(f&quot;X=&#123;x&#125;&quot;)        case (x, y):            print(f&quot;X=&#123;x&#125;, Y=&#123;y&#125;&quot;)        case _:            raise ValueError(&quot;Not a point&quot;)# http_error2((0,3)) =&gt;Y=3</code></pre><blockquote><p>Todo:此处需要二次学习</p></blockquote><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>形式：<code>def funcName(形参列表)</code><br>函数体第一条语句为字符串的时候，它就是<code>docstring</code>。作用是自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档</p><pre><code class="py">def fib(n):    # write Fibonacci series up to n    &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;    a, b = 0, 1    while a &lt; n:        print(a, end=&#39; &#39;)        a, b = b, a+b    print()# Now call the function we just defined:fib(2000)</code></pre><ul><li>返回值：return 语句返回函数的值。return 语句不带表达式参数时，返回 None。函数执行完毕退出也返回 None</li><li>实参：按值调用 进行传递</li></ul><blockquote><p>此处值指的始终是对象的 引用 而不是对象的值</p></blockquote><h3 id="定义函数-2"><a href="#定义函数-2" class="headerlink" title="定义函数 2"></a>定义函数 2</h3><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>用于：函数定义</p><pre><code class="py">def ask_ok(prompt, retries=4, reminder=&#39;Please try again!&#39;):    while True:        ok = input(prompt)        if ok in (&#39;y&#39;, &#39;ye&#39;, &#39;yes&#39;):            return True        if ok in (&#39;n&#39;, &#39;no&#39;, &#39;nop&#39;, &#39;nope&#39;):            return False        retries = retries - 1        if retries &lt; 0:            raise ValueError(&#39;invalid user response&#39;)        print(reminder)</code></pre><p>调用方式：</p><ol><li>只给出必选实参：<code>ask_ok(&#39;Do you really want to quit?&#39;)</code></li><li>给出一个可选实参：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2)</code></li><li>给出所有实参：<code>ask_ok(&#39;OK to overwrite the file?&#39;, 2, &#39;Come on, only yes or no!&#39;)</code></li></ol><blockquote><p>默认参数值只在函数定义之前生效</p></blockquote><pre><code class="py">i = 5def f(arg=i):    print(arg)i = 6f() #此时结果为5</code></pre><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>在函数调用中前面带有标识符（例如 name&#x3D;）或者作为包含在前面带有 ** 的字典里的值传入<br>用于：函数调用</p><blockquote><p>positional 参数 vs keyword 参数</p></blockquote><pre><code class="py">def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;, type=&#39;Norwegian Blue&#39;):    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;)    print(&quot;-- Lovely plumage, the&quot;, type)    print(&quot;-- It&#39;s&quot;, state, &quot;!&quot;)# 有效调用parrot(1000)                                          # 1 positional argumentparrot(voltage=1000)                                  # 1 keyword argumentparrot(voltage=1000000, action=&#39;VOOOOOM&#39;)             # 2 keyword argumentsparrot(action=&#39;VOOOOOM&#39;, voltage=1000000)             # 2 keyword argumentsparrot(&#39;a million&#39;, &#39;bereft of life&#39;, &#39;jump&#39;)         # 3 positional argumentsparrot(&#39;a thousand&#39;, state=&#39;pushing up the daisies&#39;)  # 1 positional, 1 keyword# 无效调用parrot()                     # required argument missingparrot(voltage=5.0, &#39;dead&#39;)  # non-keyword argument after a keyword argumentparrot(110, voltage=220)     # duplicate value for the same argumentparrot(actor=&#39;John Cleese&#39;)  # unknown keyword argument</code></pre><h5 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h5><ol><li>调用时，关键字参数必须跟在位置参数后面</li><li>关键字参数都必须匹配定义时候的参数名称</li><li>不能对同一个参数多次赋值</li><li>最后一个形参为<code>**name</code>形式的时候，接收一个字典 dict</li><li><code>**name</code> 形参可以与 <code>*name</code> 形参组合使用（<code>*name</code> 必须在 <code>**name</code> 前面）， <code>*name</code> 形参接收一个 元组，该元组包含形参列表之外的位置参数。</li></ol><pre><code class="py">def cheeseshop(kind, *arguments, **keywords):    print(&quot;-- Do you have any&quot;, kind, &quot;?&quot;)    print(&quot;-- I&#39;m sorry, we&#39;re all out of&quot;, kind)    for arg in arguments:        print(arg)    print(&quot;-&quot; * 40)    for kw in keywords:        print(kw, &quot;:&quot;, keywords[kw])cheeseshop(&quot;Limburger&quot;, &quot;It&#39;s very runny, sir.&quot;,           &quot;It&#39;s really very, VERY runny, sir.&quot;,           shopkeeper=&quot;Michael Palin&quot;,           client=&quot;John Cleese&quot;,           sketch=&quot;Cheese Shop Sketch&quot;)</code></pre><h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h4><ol><li>函数定义中未使用<code>/</code>和<code>*</code>时，参数按照位置或关键词传递给函数</li><li>仅限位置传参：<code>/</code></li><li>仅限关键字传参：<code>*</code></li></ol><pre><code class="py"># 正常传参def standard_arg(arg):    print(arg)# 仅限使用位置形参def pos_only_arg(arg, /):    print(arg)# 仅限关键词传参def kwd_only_arg(*, arg):    print(arg)# 混合使用def combined_example(pos_only, /, standard, *, kwd_only):    print(pos_only, standard, kwd_only)#报错：combined_example() takes 2 positional arguments but 3 were givencombined_example(1, 2, 3)#正确：1，2，3combined_example(1, 2, kwd_only=3)#正确：1，2，3combined_example(1, standard=2, kwd_only=3)#报错：combined_example() got some positional-only arguments passed as keyword arguments: &#39;pos_only&#39;combined_example(pos_only=1, standard=2, kwd_only=3)</code></pre><pre><code class="bash">def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):      -----------    ----------     ----------        |             |                  |        |        Positional or keyword   |        |                                - Keyword only         -- Positional only</code></pre><h4 id="任意实参列表"><a href="#任意实参列表" class="headerlink" title="任意实参列表"></a>任意实参列表</h4><p><code>*args</code> 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：</p><pre><code class="py">def write_multiple_items(file, separator, *args):    file.write(separator.join(args))</code></pre><h4 id="解包实参列表"><a href="#解包实参列表" class="headerlink" title="解包实参列表"></a>解包实参列表</h4><p>使用场景：函数调用要求独立的位置参数，但实参在列表或元组里<br>使用语法：</p><ul><li><code>*参数</code>：列表&#x2F;元组</li><li><code>**参数</code>：字典（对象）</li></ul><pre><code class="py"># 此处参数为列表args = [3, 6] # args = (3, 6)也可以list(range(*args))# 解包字典def parrot(voltage, state=&#39;a stiff&#39;, action=&#39;voom&#39;):    print(&quot;-- This parrot wouldn&#39;t&quot;, action, end=&#39; &#39;)    print(&quot;if you put&quot;, voltage, &quot;volts through it.&quot;, end=&#39; &#39;)    print(&quot;E&#39;s&quot;, state, &quot;!&quot;)d = &#123;&quot;voltage&quot;: &quot;four million&quot;, &quot;state&quot;: &quot;bleedin&#39; demised&quot;, &quot;action&quot;: &quot;VOOM&quot;&#125;parrot(**d)</code></pre><h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>作用：用于创建匿名函数,常规函数定义的语法糖<br>语法：只能是单个表达式，返回值是是一个函数<br>不适合场景：创建逻辑复杂的函数<br>例子：<br><code>lambda a, b: a+b</code>函数返回两个参数之和</p><pre><code class="py">def make_incrementor(n):    return lambda x: x + nf = make_incrementor(42)f(0) #42f(1) #43</code></pre><h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>特殊注释形式，对函数、类、模块等代码元素进行文档说明<br>访问：<code>__doc__</code><br>作用：</p><ol><li>自动生成代码的 api 文档</li><li>提供代码使用说明</li><li>提供内部实现说明</li></ol><p>docstring 约定：</p><ul><li>多行时，隔一行应为空白行</li><li>必须以大写字符开头，以<code>.</code>结尾</li></ul><h4 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h4><p>作用：为函数参数和返回值添加元数据或类型提示</p><blockquote><p>不会影响函数的实际行为，而是提供了额外的信息，可以被工具、IDE 和静态类型检查器等利用<br>函数注解使用<code>冒号（:）</code>后跟一个表达式来指定注解的内容。通常，注解可以是一个类型，也可以是任何其他有效的 Python 表达式。<br>和 TS 区别：这个不会影响运行，且不会强制执行</p></blockquote><pre><code class="py">def greet(name) :    return f&quot;Hello, &#123;name&#125;!&quot;def greet(name: str) -&gt; str:    return f&quot;Hello, &#123;name&#125;!&quot;# 鼠标悬浮到函数名称上可发现第一个里面的name显示为any类型# 第二个显示为str</code></pre><h2 id="c5-数据结构"><a href="#c5-数据结构" class="headerlink" title="c5. 数据结构"></a>c5. 数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li>list.append(x)：末尾添加元素，<code>a[len(a):] = [x] </code></li><li>list.extend(iterable)：用可迭代对象的元素扩展列表。 <code>a[len(a):] = iterable </code></li><li>list.insert(index, value):指定位置插入元素</li><li>list.remove(x):从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常</li><li>list.pop([index]):删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素,[]表示这是个可选参数</li><li>list.clear():删除列表里的所有元素</li><li>list.index(x[, start[, end]]):返回列表中第一个值为 x 的元素的零基索引.未找到指定元素时，触发 ValueError 异常。<blockquote><p>可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。</p></blockquote></li><li>list.count(x):返回列表中元素 x 出现的次数</li><li>list.sort(*, key&#x3D;None, reverse&#x3D;False):就地排序列表中的元素</li><li>list.reverse():反转列表元素</li><li>list.copy()：返回列表的浅拷贝。相当于 a[:]</li></ol><h4 id="实现堆栈"><a href="#实现堆栈" class="headerlink" title="实现堆栈"></a>实现堆栈</h4><p>特点：先进后出<br>借助 append 和 pop 方法</p><h4 id="实现队列"><a href="#实现队列" class="headerlink" title="实现队列"></a>实现队列</h4><p>特点：先进先出<br>借助 collections.deque</p><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>概念：通过对现有列表进行迭代和筛选，快速生成一个新的列表</p><pre><code class="py">squares = []for x in range(10):    squares.append(x**2)# squares-&gt;[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p>语法：new_list &#x3D; <code>[expression for item in iterable if condition]</code></p><ul><li>expression：应用于每个迭代项的表达式</li><li>item：从可迭代对象中取出的每个元素</li><li>iterable：表示可迭代对象</li><li>condition：可选的 条件表达式，用于筛选满足条件的元素</li></ul><pre><code class="py">numbers = [1, 2, 3, 4, 5]squared_numbers = [num**2 for num in numbers if num % 2 == 0]print(squared_numbers)  # 输出: [4, 16]tuple=[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]# tuple值：[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code></pre><p>列表推导式可嵌套</p><pre><code class="py">matrix = [    [1, 2, 3, 4],    [5, 6, 7, 8],    [9, 10, 11, 12],]a= [[row[i] for row in matrix] for i in range(4)]# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</code></pre><h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a>del 语句</h3><p>按索引而不是值从列表中移除条目</p><pre><code class="py">a = [-1, 1, 66.25, 333, 333, 1234.5]del a[0]# a:[1, 66.25, 333, 333, 1234.5]del a[2:4]# a:[1, 66.25, 1234.5]del a[:]# a:[]del a# 删除整个变量，之后不能再使用</code></pre><h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p>序列：列表、字符串、元组、range<br>形式：元组由多个用逗号隔开的值组成</p><pre><code class="py">t = 12345, 54321, &#39;hello!&#39;u = t, (1, 2, 3, 4, 5)print(u)</code></pre><p>元组可嵌套，所以上述最终结果为<code>((12345, 54321, &#39;hello!&#39;), (1, 2, 3, 4, 5))</code></p><h4 id="元组和列表区别"><a href="#元组和列表区别" class="headerlink" title="元组和列表区别"></a>元组和列表区别</h4><ol><li>元组是不可变的，适合存储一些不希望被修改的数据，如坐标、日期等</li><li>列表是可修改的，适合存储一些需要频繁修改的数据</li><li>元素在内存占用和访问上更有优势</li></ol><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>概念：由不重复元素组成的无序容器<br>作用：</p><ol><li>消除重复元素</li></ol><pre><code class="py">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;print(basket)# &#123;&#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;a = set(&#39;abracadabra&#39;)print(a)# &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;&#125;</code></pre><ol start="2"><li>成员检测</li></ol><pre><code class="py">isExist=&#39;orange&#39; in basket #True</code></pre><p>打印出来的值去除了重复的 apple 元素</p><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>语法：使用<code>set()</code>函数或<code>&#123;&#125;</code></p><blockquote><p>创建空集合只能用 set()方法<br><code>&#123;&#125;</code>创建的是空字典</p></blockquote><pre><code class="py">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;a = set(&#39;abracadabra&#39;)</code></pre><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><ol><li><code>a-b</code>：差集，从 a 中去除 b 后剩余的集合</li><li><code>a|b</code>: 并集</li><li><code>a&amp;b</code>: 交集</li><li><code>a^b</code>: 异或</li></ol><h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><pre><code class="py">a = &#123;x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;&#125;# &#123;r,d&#125;</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>本质：键值对 的集合，但键必须唯一<br>作用：通过 key 存取值<br>删除：使用 <code>del</code>，<br>返回所有键的列表：<code>list(dic)</code>,按插入次序排列<br>检查字典里是否有某个键：使用<code>in</code>关键字</p><h4 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h4><ol><li>字面值创建</li><li>dict()函数：<code>dict([(&#39;sape&#39;, 4139), (&#39;guido&#39;, 4127), (&#39;jack&#39;, 4098)])</code></li></ol><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><p>{x: x**2 for x in (2, 4, 6)}<br>结果：{2: 4, 4: 16, 6: 36}</p><h3 id="循环技巧"><a href="#循环技巧" class="headerlink" title="循环技巧"></a>循环技巧</h3><ol><li>items()方法：字典提取键及其对应的值</li></ol><pre><code class="py">knights = &#123;&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;&#125;for k, v in knights.items():    print(k, v)</code></pre><ol start="2"><li>enumerate()方法：在集合中同时取出位置索引和对应的值</li></ol><pre><code class="py">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):    print(i, v)</code></pre><ol start="3"><li>zip()方法：同时循环两个或多个序列时，将其内的元素一一匹配</li></ol><pre><code class="py">questions = [&#39;name&#39;, &#39;quest&#39;, &#39;favorite color&#39;]answers = [&#39;lancelot&#39;, &#39;the holy grail&#39;, &#39;blue&#39;]for q, a in zip(questions, answers):    print(&#39;What is your &#123;0&#125;?  It is &#123;1&#125;.&#39;.format(q, a))# q,a分别是2个列表的对应元素</code></pre><h3 id="条件控制-deep"><a href="#条件控制-deep" class="headerlink" title="条件控制 deep"></a>条件控制 deep</h3><ol><li>in &amp; not in：成员检测</li><li>is &amp; is not：比较两个对象是否是同一个对象</li><li>所有比较运算符优先级相同且低于任何数值运算符</li><li>比较运算符支持链式操作<blockquote><p>a &lt; b &#x3D;&#x3D; c 校验 a 是否小于 b，且 b 是否等于 c。</p></blockquote></li><li>比较操作可以用布尔运算符 <code>and</code> 和 <code>or</code> 组合，并且，比较操作（或其他布尔运算）的结果都可以用 <code>not</code> 取反。not 的优先级最高， or 的优先级最低。</li><li>and&#x2F;or 是短路运算符，从左到右，一旦可以确定结果，求值就会立刻停止</li></ol><p>赋值：</p><ol><li>普通赋值</li><li>海象运算符：<code>:=</code><blockquote><p>第二种主要用于同时存在赋值和比较的情况</p></blockquote></li></ol><h2 id="c6-模块"><a href="#c6-模块" class="headerlink" title="c6. 模块"></a>c6. 模块</h2><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 <strong>模块</strong><br>使用：模块中的定义可以导入到其他模块或者主模块<br>命名：文件名&#x3D;模块名+’.py’</p><h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h3><p>作用：查找模块定义的名称。返回结果是经过排序的字符串列表<br>有参数：查找指定模块定义的名称<br>无参数：列出当前已定义的名称</p><blockquote><p>不会列出内置函数和变量的名称。这些内容的定义在标准模块 builtins 中</p></blockquote><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>概念：通过使用“带点号模块名”来构造 Python 模块命名空间的一种方式<br>例子：模块名 <code>A.B</code> 表示名为 A 的包中名为 B 的子模块<br>作用：避免不同包的模块名冲突</p><h4 id="从包中导入"><a href="#从包中导入" class="headerlink" title="从包中导入"></a>从包中导入</h4><ol><li><code>import sound.effects.echo</code></li><li><code>from sound.effects import echo</code></li><li><code>from sound.effects import * </code><blockquote><p>导入方式 3 中：模块中的所有公开对象和函数导入当前命名空间。这意味着可以直接使用模块中的对象和函数，而不需要使用模块前缀。</p></blockquote></li></ol><h4 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h4><pre><code class="py"># 绝对导入import sound.effects.echoimport sound.effects.surroundfrom sound.effects import *# 相对导入（对于 surround 模块）from . import echofrom .. import formatsfrom ..filters import equalizer</code></pre><h2 id="c7-输入和输出"><a href="#c7-输入和输出" class="headerlink" title="c7. 输入和输出"></a>c7. 输入和输出</h2><p>TODO</p><h2 id="c8-错误和异常"><a href="#c8-错误和异常" class="headerlink" title="c8. 错误和异常"></a>c8. 错误和异常</h2><p>TODO</p><h2 id="c9-类"><a href="#c9-类" class="headerlink" title="c9. 类"></a>c9. 类</h2><p>作用：将数据和功能绑定在一起<br>特性：</p><ol><li>类的继承机制支持多个基类</li><li>派生的类能覆盖基类的方法</li><li>类的方法能够调用基类中的同名方法</li><li>在运行时创建，创建后还可修改</li></ol><h3 id="作用域和命名空间"><a href="#作用域和命名空间" class="headerlink" title="作用域和命名空间"></a>作用域和命名空间</h3><p>TODO:需要二次学习理解</p><h3 id="类定义语法"><a href="#类定义语法" class="headerlink" title="类定义语法"></a>类定义语法</h3><pre><code class="py">class 类名:    语句</code></pre><blockquote><p>TODO:与函数定义 (def 语句) 一样，类定义必须先执行才能生效。把类定义放在 if 语句的分支里或函数内部试试。[没理解]</p></blockquote><p>进入类定义时，会创建一个新的命名空间，将它作为局部作用域。</p><h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><p>类对象包括两种操作：</p><ul><li>属性引用：<code>obj.name</code></li><li>实例化：<code>obj()</code></li></ul><pre><code class="py">class MyClass:    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;    i = 12345    def f(self):        return &#39;hello world&#39;</code></pre><p>上述代码，可以通过<code>MyClass.i</code>或者<code>MyClass.f</code>进行属性引用，分别返回一个 number 和一个 function，可以通过<code>MyClass.i=newValue</code>来修改它的值，但修改后会影响实例对应的值。<br>可以通过<code>MyClass()</code>进行实例化,返回一个类对象，可赋值给变量。本质是创建一个空对象。</p><h4 id="希望通过指定初始状态创建实例"><a href="#希望通过指定初始状态创建实例" class="headerlink" title="希望通过指定初始状态创建实例"></a>希望通过指定初始状态创建实例</h4><p>方法：定义<code>__init__()</code>方法</p><pre><code class="py">class A:    def __init__(self,data):        self.data=data</code></pre><h3 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h3><p>作用:属性引用-数据属性+方法</p><h3 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h3><p>MyClass.f：函数对象<br>m.f:方法对象<br>区别：实例对象会作为函数的第一个参数被传入</p><h3 id="类和实例变量"><a href="#类和实例变量" class="headerlink" title="类和实例变量"></a>类和实例变量</h3><p>实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法<br>如果类定义中有同名的实例变量和类变量，各个实例将共享该变量，比如</p><pre><code class="py">class Dog:    tricks = []             # mistaken use of a class variable    def __init__(self, name):        self.name = name    def add_trick(self, trick):        self.tricks.append(trick)d = Dog(&#39;Fido&#39;)e = Dog(&#39;Buddy&#39;)d.add_trick(&#39;roll over&#39;)e.add_trick(&#39;play dead&#39;)d.tricks</code></pre><p>此时类的实例对象 d 和 e 共享 tricks 这个变量</p><h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p><pre><code class="py">class Warehouse:   purpose = &#39;storage&#39;   region = &#39;west&#39;w1 = Warehouse()print(w1.purpose, w1.region)w2 = Warehouse()w2.region = &#39;east&#39;print(w2.purpose, w2.region)print(w1.purpose, w1.region)</code></pre><p>此时第二次的 w1.region 依旧为 west</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>语法：</p><pre><code class="py">class 类名(基类模块名.基类名):class 类名(基类名):    &lt;statement-1&gt;    &lt;statement-N&gt;</code></pre><p>查询属性：<br>如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。<br>内置函数：</p><ol><li><p>isinstance() ：检查一个实例的类型: isinstance(obj, int) 仅会在 obj.<strong>class</strong> 为 int 或某个派生自 int 的类时为 True。</p></li><li><p>issubclass() ：检查类的继承关系: issubclass(bool, int) 为 True，因为 bool 是 int 的子类。 但是，issubclass(float, int) 为 False，因为 float 不是 int 的子类</p></li></ol><h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>含义：一个类继承自多个类</p><pre><code class="py">class DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    &lt;statement-N&gt;</code></pre><p>理论上：D-&gt;B1-&gt;B1-super-&gt;B2-&gt;B2-super<br>实际上：方法解析顺序会动态改变以支持对 super() 的协同调用，只调用每个父类一次，并且保持单调</p><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>python 不存在实际意义上的私有变量（仅限一个对象内部访问）<br>日常开发中会以一个<strong>带下划线的名称</strong>，比如<code>_var</code>来表示这个函数&#x2F;方法&#x2F;数据成员应该被看作是非公有部分</p><pre><code class="py">class Mapping:    def __init__(self, iterable):        self.items_list = []        self.__update(iterable)    def update(self, iterable):        for item in iterable:            self.items_list.append(item)    __update = update   # 私有化拷贝class MappingSubclass(Mapping):    def update(self, keys, values):        # 提供update（）的新签名        # 不会破坏 __init__()        for item in zip(keys, values):            self.items_list.append(item)</code></pre><p>上面的代码中，</p><blockquote><p>名称改写：任何形式为 <code>__spam</code> 的标识符的文本将被替换为<code>_classname__spam</code>，其中<code>_classname</code>为去除了前缀下划线的当前类名称。支持需要私有变量的场景，避免父类和子类的名称冲突</p></blockquote><h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><h2 id="c10-标准库-part1"><a href="#c10-标准库-part1" class="headerlink" title="c10. 标准库-part1"></a>c10. 标准库-part1</h2><h2 id="c11-标准库-part2"><a href="#c11-标准库-part2" class="headerlink" title="c11. 标准库-part2"></a>c11. 标准库-part2</h2><h2 id="c12-虚拟环境和包"><a href="#c12-虚拟环境和包" class="headerlink" title="c12. 虚拟环境和包"></a>c12. 虚拟环境和包</h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序自动化部署</title>
      <link href="/2023/09/18/ying-yong-cheng-xu-zi-dong-hua-bu-shu/"/>
      <url>/2023/09/18/ying-yong-cheng-xu-zi-dong-hua-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>在现代软件开发中使用 Dokcer 进行前后端程序的部署已经成为一种常见的做法。但是每次 push 代码后都需要手动更新镜像并重新创建容器，这不仅麻烦且浪费时间。为了解决这个问题，我们可以利用 github actions 实现自动化部署流程。</p><h1 id="第一步：创建工作流相关文件"><a href="#第一步：创建工作流相关文件" class="headerlink" title="第一步：创建工作流相关文件"></a>第一步：创建工作流相关文件</h1><p>在项目的根目录下新建 <code>.github/workflows/xxx.yaml</code>文件<br>我们的预期有两个：</p><ol><li>根据最新的代码构建最新的前后端镜像</li><li>将容器部署到虚拟机上<br>所以新建两个文件<code>build-image.yaml</code>和<code>deploy.yml</code></li></ol><h3 id="踩坑："><a href="#踩坑：" class="headerlink" title="踩坑："></a>踩坑：</h3><p>文件夹名称必须是<code>.github/workflows</code>，且必须放在项目根目录下,否则 github 不会将其识别为 github actions 的配置文件。</p><h2 id="第二步：创建镜像构建配置文件-build-image-yml"><a href="#第二步：创建镜像构建配置文件-build-image-yml" class="headerlink" title="第二步：创建镜像构建配置文件 build-image.yml"></a>第二步：创建镜像构建配置文件 build-image.yml</h2><h3 id="一些配置项"><a href="#一些配置项" class="headerlink" title="一些配置项"></a>一些配置项</h3><ul><li>on:指定触发工作流程的事件,大部分情况下设置为 push，当然还有其他可选值：pull_request,issue_comment 等</li><li>jobs:定义一个或多个 job</li><li>runs-on:指定 job 运行的操作系统环境</li><li>steps:定义完成当前 job 所需要的步骤<ul><li>name: 步骤名称</li><li>uses：指定预定义的动作或自定义的操作所在的仓库和版本，一般形式为<code>仓库所有者/仓库地址@版本</code></li><li>run:指定具体的命令或脚本来执行</li><li>env：定义环境变量</li></ul></li></ul><h3 id="build-vue-app-image-总共有-3-个步骤："><a href="#build-vue-app-image-总共有-3-个步骤：" class="headerlink" title="build_vue_app_image,总共有 3 个步骤："></a>build_vue_app_image,总共有 3 个步骤：</h3><ol><li>通过<code>actions/checkout@v3</code>拉取代码仓库</li><li>构建前端镜像</li><li>构建后端镜像</li></ol><p>此处有两个环境变量<code>DOCKER_USERNAME</code>,<code>DOCKER_PASSWORD</code>,这两个变量都是通过配置 github 该项目仓库的<code>secrets</code>获取到的，设置路径为：<a href="https://github.com/earthaYan/resume_generator_front/settings/secrets/actions">项目-settings-Security-Actions secrets and variables-Repository secrets</a></p><h3 id="此处有两个地方需要注意【容易踩坑】："><a href="#此处有两个地方需要注意【容易踩坑】：" class="headerlink" title="此处有两个地方需要注意【容易踩坑】："></a>此处有两个地方需要注意【容易踩坑】：</h3><ol><li>这里两个环境变量应该设置的是两个<code>secret</code>，而不是Name 为你的 Docker Hub 账号，Value 为 Docker Hub 的 access token<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>DOCKER_USERNAME</td><td>Docker Hub 账号名</td></tr><tr><td>DOCKER_PASSWORD</td><td>Docker Hub Access Token</td></tr></tbody></table></li><li>第一次执行的时候报错：<code>invalid workflow file,you have error in your yaml syntax on line11</code>，报错部分代码如下：</li></ol><pre><code class="yaml">env:  DOCKER_USERNAME: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;      DOCKER_PASSWORD: $&#123;&#123; secrets.DOCKER_PASSWORD &#125;&#125;</code></pre><p>错误的原因是 yaml 文件中使用缩进表示层级关系，相同层级的元素必须左对齐，而这里 env下面的环境变量是 env 的下一级，但是却和它放在了同一行，所以报错了，修改为：</p><pre><code class="yml">name: Build vue_app imageenv:    DOCKER_USERNAME: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;    DOCKER_PASSWORD: $&#123;&#123; secrets.DOCKER_PASSWORD &#125;&#125;</code></pre><p>完整代码如下：</p><pre><code class="yml">name: build-imagerun-name: $&#123;&#123; github.actor &#125;&#125; is building latest imageon: [push]jobs:  build_vue_app_image:    runs-on: ubuntu-latest    steps:      - name: Checkout repository        uses: actions/checkout@v3      - name: Build vue_app image        env:          DOCKER_USERNAME: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;          DOCKER_PASSWORD: $&#123;&#123; secrets.DOCKER_PASSWORD &#125;&#125;        run: |          docker build -t yanyue1215/vue_app .          docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD          docker push yanyue1215/vue_app      - name: build_resume_service        env:          DOCKER_USERNAME: $&#123;&#123; secrets.DOCKER_USERNAME &#125;&#125;          DOCKER_PASSWORD: $&#123;&#123; secrets.DOCKER_PASSWORD &#125;&#125;        run: |          cd Backend/    # 后端代码所在目录          docker build -t yanyue1215/resume_service .          docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD          docker push yanyue1215/resume_service</code></pre><h2 id="第三步：创建-deploy-配置文件-deploy-yml"><a href="#第三步：创建-deploy-配置文件-deploy-yml" class="headerlink" title="第三步：创建 deploy 配置文件 deploy.yml"></a>第三步：创建 deploy 配置文件 deploy.yml</h2><p>如此之后，每当 push 代码到对应分支后，github 就会自动构建最新镜像并推送到 Docker Hub。但是这个时候你还是需要自己去虚拟机上拉取最新镜像并重建容器，依旧很麻烦，如果这个过程也能能自动化就最好了。<br>一开始考虑是否和 umc-ui 项目一样使用MakeFile,但是最后还是希望能把更新和部署都集成到 github 的工作流程中。但是由于 github action 本身并不支持直接将应用程序部署到私人的虚拟机上，需要和其他工具相结合。最终采用的方法是：</p><blockquote><p>在 yml 文件中编写一个部署脚本，通过 ssh 连接到虚拟机并执行对应的部署命令</p></blockquote><h3 id="一些配置项-1"><a href="#一些配置项-1" class="headerlink" title="一些配置项"></a>一些配置项</h3><ul><li>workflows: 依赖的workflow</li><li>types:指定只有在依赖工作流程完成后才触发该工作流程</li></ul><h3 id="push-to-private-machine总共有个步骤"><a href="#push-to-private-machine总共有个步骤" class="headerlink" title="push-to-private-machine总共有个步骤"></a>push-to-private-machine总共有个步骤</h3><ol><li>通过<code>actions/checkout@v3</code>拉取代码仓库</li><li>将虚拟机密钥添加到 GitHub Runner 的 “known_hosts” 文件中</li><li>移除旧容器</li><li>拉取最新镜像</li><li>创建新容器</li></ol><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul><li><code>docker ps -a | grep yanyue1215/vue_app | awk &#39;&#123;print $1&#125;&#39; | xargs -r docker rm -f</code><ul><li>docker ps -a：列出所有的Dokcer容器</li><li>grep yanyue1215&#x2F;vue_app：在容器列表中过滤出名称为 “yanyue1215&#x2F;vue_app” 的容器</li><li>awk ‘{print $1}’:从过滤结果中提取第一列（即容器 ID）</li><li>xargs -r docker rm -f：将容器 ID 作为参数传递给 docker rm -f 命令，以强制删除容器</li></ul></li><li>ssh-keyscan 116.204.108.126 &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts<ul><li>使用 <code>ssh-keyscan</code> 命令扫描主机 116.204.108.126 的公钥，并将结果追加到 <code>~/.ssh/known_hosts</code> 文件中。<code>&gt;&gt; </code>操作符表示将输出重定向并追加到文件末尾</li></ul></li></ul><p>完整代码如下：</p><pre><code class="yml">name: push-to-private-machinerun-name: $&#123;&#123; github.actor &#125;&#125; is deployingon:  workflow_run:    workflows: [&quot;build-image&quot;] #依赖的工作流程文件的名称    types:      - completedjobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout repository        uses: actions/checkout@v3      - name: Add known hosts        run: | # 将虚拟机密钥添加到 GitHub Runner 的 &quot;known_hosts&quot; 文件中          mkdir -p ~/.ssh          ssh-keyscan 116.204.108.126 &gt;&gt; ~/.ssh/known_hosts      - name: remove old container        run: |          sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;docker ps -a | grep yanyue1215/vue_app | awk &#39;&#123;print $1&#125;&#39; | xargs -r docker rm -f&quot;          sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;docker ps -a | grep yanyue1215/resume_service | awk &#39;&#123;print $1&#125;&#39; | xargs -r docker rm -f&quot;          sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;docker system prune -a&quot;      - name: pull latest front_image        run: sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;docker pull yanyue1215/vue_app:latest&quot;      - name: pull latest backend_image        run: sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;docker pull yanyue1215/resume_service:latest&quot;      - name: Deploy to Virtual Machine        run: sshpass -p $&#123;&#123; secrets.SSH_PASSWORD &#125;&#125; ssh root@116.204.108.126 &quot;cd /root/resume_generator_front &amp;&amp; /usr/local/git/bin/git pull origin master &amp;&amp; docker-compose up -d&quot;</code></pre><h3 id="容易踩坑的点"><a href="#容易踩坑的点" class="headerlink" title="容易踩坑的点"></a>容易踩坑的点</h3><h4 id="虚拟机上安装了-git，但是执行到git-pull-xx却报错"><a href="#虚拟机上安装了-git，但是执行到git-pull-xx却报错" class="headerlink" title="虚拟机上安装了 git，但是执行到git pull xx却报错:"></a>虚拟机上安装了 git，但是执行到<code>git pull xx</code>却报错:</h4><blockquote><p>git: command not found<br>error:Process completed with exit code 127</p></blockquote><p>猜测原因是 Github Actions 的工作流程中无法找到 git 命令。解决方案是在虚拟机上执行<code>which git</code>命令获取到 git 的实际位置，然后将其替换到命令中。</p><pre><code class="bash"># 原来的命令：git pull origin master# 修改后的命令：/usr/local/git/bin/git pull origin master</code></pre><h4 id="第一个流程执行完之后并没有执行自动化部署"><a href="#第一个流程执行完之后并没有执行自动化部署" class="headerlink" title="第一个流程执行完之后并没有执行自动化部署"></a>第一个流程执行完之后并没有执行自动化部署</h4><p>原因：需要两个工作流程文件的名称正确且匹配<br>解决方案：是将所有 yml 文件和他们里面的<code>name</code>值保持一致</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo菜单栏增加yuque专栏</title>
      <link href="/2023/09/05/hexo-cai-dan-lan-zeng-jia-yuque-zhuan-lan/"/>
      <url>/2023/09/05/hexo-cai-dan-lan-zeng-jia-yuque-zhuan-lan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何获取一个函数的返回值类型</title>
      <link href="/2023/08/03/ru-he-huo-qu-yi-ge-han-shu-de-fan-hui-zhi-lei-xing/"/>
      <url>/2023/08/03/ru-he-huo-qu-yi-ge-han-shu-de-fan-hui-zhi-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>使用 Modal.confirm()方法创建了一个弹窗，但是由于一些原因导致需要手动关闭弹窗</p><pre><code class="JavaScript"> const modal = Modal.confirm(&#123;  onCancel:()=&gt;handleCancel(modal) &#125;)  const handleCancel = (modal?: any) =&gt; &#123;    if (!!modal) &#123;      modal.destroy();    &#125;  &#125;;</code></pre><p>代码复审时，复审人提出这里可以使用<code>(typeof Modal)[&#39;confirm&#39;]</code>,而不使用不严谨的<code>any</code>。翻阅文档后发现 antd 提供了现成的类型定义<code>ModalFunc</code></p><pre><code class="javascript">export declare type ModalFunc = (props: ModalFuncProps) =&gt; &#123;  destroy: () =&gt; void;  update: (configUpdate: ConfigUpdate) =&gt; void;&#125;;</code></pre><p>换上去以后发现<code>modal.destroy()</code>报错，报错信息为：</p><blockquote><p>类型“ModalFunc”上不存在属性“destroy”。</p></blockquote><p>通过上述的类型定义可看出 modal 的类型不应该是<code>ModalFunc</code>，而应该是这个函数的返回类型。通过查阅 TS 文档可知：我们可以通过<code>ReturnType</code>去解决问题。<br>所以源码修改为：</p><pre><code class="javascript">const handleCancel = (modal?: ReturnType&lt;ModalFunc&gt;) =&gt; &#123;  if (!!modal) &#123;    modal.destroy();  &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd自定义页脚Modal</title>
      <link href="/2023/08/02/antd-zi-ding-yi-ye-jiao-modal/"/>
      <url>/2023/08/02/antd-zi-ding-yi-ye-jiao-modal/</url>
      
        <content type="html"><![CDATA[<p>需求：</p><img src="/2023/08/02/antd-zi-ding-yi-ye-jiao-modal/need.jpg" class="" title="需求"><h2 id="前置背景："><a href="#前置背景：" class="headerlink" title="前置背景："></a>前置背景：</h2><p>用户登录成功后，如果当前状态为初始密码状态，则跳转到目标页面且展示弹窗提示用户修改密码。由于之前产品希望 modal 可以跨页面展示，所以没有使用 Modal 组件，而是使用了 Modal.confirm:</p><pre><code class="javascript">Modal.confirm(&#123;  content:    res.is_user_password_expired === IsUserPasswordExpiredEnum.EXPIRE_SOON      ? i18n.t(&#39;Login.Login.index.LOCALE_DEFAULT_SUFFIX3836&#39;)      : i18n.t(&#39;Login.Login.index.firstLoginModifyPwd&#39;),  okText: i18n.t(&#39;commonGenerator.confirm_3&#39;),  cancelText: i18n.t(&#39;commonGenerator.cancel&#39;),  onOk: () =&gt; &#123;    // 防止用户在修改密码界面点击浏览器返回键或者取消，程序卡死    dispatch(setIsLogin(&#123; isLogin: true, token: res.token ?? &#39;&#39; &#125;));    history.push(&#39;/password_modify&#39;);  &#125;,  onCancel: () =&gt; &#123;    dispatch(setIsLogin(&#123; isLogin: true, token: res.token ?? &#39;&#39; &#125;));    if (target) &#123;      window.location.href = target;    &#125;  &#125;,&#125;);</code></pre><h2 id="本次需求"><a href="#本次需求" class="headerlink" title="本次需求"></a>本次需求</h2><p>产品希望在底部增加一个取消和确认之外的忽略按钮，点击忽略按钮时，调用新增的忽略密码提示接口，然后自动关闭弹窗。</p><h3 id="首选方案：使用自定义页脚-footer-属性"><a href="#首选方案：使用自定义页脚-footer-属性" class="headerlink" title="首选方案：使用自定义页脚 footer 属性"></a>首选方案：使用自定义页脚 footer 属性</h3><pre><code class="javascript">Modal.confirm(&#123;  // ...  footer:[&#123;    &lt;Button key=&#39;1&#39;&gt;忽略&lt;/Button&gt;,    &lt;Button key=&#39;2&#39;&gt;取消&lt;/Button&gt;,    &lt;Button key=&#39;3&#39;&gt;确认&lt;/Button&gt;  &#125;]&#125;)</code></pre><p>问题：目前项目使用的 antd 版本为 4.x,而 antd5.x 才支持 footer 属性，所以有两个选择：</p><ol><li>升级项目依赖库版本【暂时没有升级计划，直接忽略】</li><li>通过非正常方式实现支持自定义页脚的 Modal</li></ol><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><h4 id="使用-Modal-组件封装一个支持自定义页脚的弹窗"><a href="#使用-Modal-组件封装一个支持自定义页脚的弹窗" class="headerlink" title="使用 Modal 组件封装一个支持自定义页脚的弹窗"></a>使用 Modal 组件封装一个支持自定义页脚的弹窗</h4><pre><code class="javascript">const [visible, setVisible] = useState(false);const showModal = () =&gt; &#123;  setVisible(true);&#125;;const handleOk = () =&gt; &#123;  // ...handling&#125;;const handleCancel = () =&gt; &#123;  // ...handling&#125;;const handleIgnore = () =&gt; &#123;  // ...handling&#125;;return (  &lt;&gt;    &lt;Button onClick=&#123;showModal&#125;&gt;Open Modal&lt;/Button&gt;    &lt;Modal      visible=&#123;visible&#125;      onOk=&#123;handleOk&#125;      onCancel=&#123;handleCancel&#125;      footer=&#123;[        &lt;Button key=&quot;cancel&quot; onClick=&#123;handleCancel&#125;&gt;          取消        &lt;/Button&gt;,        &lt;Button key=&quot;ignore&quot; onClick=&#123;handleIgnore&#125;&gt;          忽略        &lt;/Button&gt;,        &lt;Button key=&quot;submit&quot; type=&quot;primary&quot; onClick=&#123;handleOk&#125;&gt;          确认        &lt;/Button&gt;,      ]&#125;    &gt;      &lt;p&gt;Modal Content&lt;/p&gt;    &lt;/Modal&gt;  &lt;/&gt;);</code></pre><p>由于 antd4.x 的 Modal 组件支持 footer 属性，所以可以通过该组件封装。但是问题是我们需要弹窗能跨页面展示。需要做到这一点，可以采用方案：使用 redux 将 modal 的显示状态提升到全局</p><pre><code class="jsx">// store.jsexport const store = createStore( reducer: (state, action) =&gt; &#123;  // ... handles modal visibility state&#125;)// App.js&lt;Provider store=&#123;store&#125;&gt;  &lt;Router&gt;    &#123;/* 根据 redux state 来渲染 Modal */&#125;    &lt;Modal /&gt;    &lt;Route path=&quot;/a&quot; component=&#123;PageA&#125; /&gt;    &lt;Route path=&quot;/b&quot; component=&#123;PageB&#125; /&gt;  &lt;/Router&gt;&lt;/Provider&gt;// PageA.jsimport &#123; showModal &#125; from &#39;./actions&#39;const openModal = () =&gt; &#123;  dispatch(showModal()) // 开启 modal&#125;// PageB.js// 这里不需要做任何处理,modal 会继续显示</code></pre><p>但是这个弹窗并不是全局的功能，所以并不希望将其放置在全局的路由中，且这样做的话修改成本较高，所以放弃此方案。</p><h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>思路：cancelText 属性类型支持 ReactNode，所以可以考虑将忽略按钮和取消按钮同一看做是 cancelText,通过 CSS 和点击事件设置达到相同效果</p><pre><code class="javascript">const handleIgnore = async (modal: any) =&gt; &#123;  const token = localStorage.getItem(&#39;token&#39;);  dispatch(setIsLogin(&#123; isLogin: true, token: token ?? &#39;&#39; &#125;));  const ignore = UserService.ignorePasswdChangeAlarm();  modal.destroy();  ignore.catch((err) =&gt; message.error(getErrorMessage(err)));  if (target) &#123;    window.location.href = target;  &#125;&#125;;const handleCancel = (modal?: any) =&gt; &#123;  const token = localStorage.getItem(&#39;token&#39;);  dispatch(setIsLogin(&#123; isLogin: true, token: token ?? &#39;&#39; &#125;));  if (target) &#123;    window.location.href = target;  &#125;  if (!!modal) &#123;    modal.destroy();  &#125;&#125;;const modal = Modal.confirm(&#123;  // ....  className: &#39;need-modify-modal&#39;,  cancelText: (    &lt;&gt;      &lt;Button onClick=&#123;() =&gt; handleIgnore(modal)&#125;&gt;忽略&lt;/Button&gt;      &lt;Button onClick=&#123;() =&gt; handleCancel(modal)&#125;&gt;取消&lt;/Button&gt;    &lt;/&gt;  ),  cancelButtonProps: &#123;    className: &#39;cancel-ignore-btns&#39;,    onClick: () =&gt; &#123;&#125;,    type: &#39;text&#39;,  &#125;,&#125;);</code></pre><p>此时再设置样式即可</p><pre><code class="less">.need-modify-modal &#123;  .ant-modal-confirm-btns &#123;    display: flex;    justify-content: end;    align-items: center;    border: none;    .cancel-ignore-btns &#123;      border: none;      display: flex;      align-items: end;      padding: 0;      justify-content: end;      width: 80%;      cursor: default;      &gt; span &#123;        width: 100%;        display: flex;        justify-content: space-between;        background-color: #fff;      &#125;    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> antd </tag>
            
            <tag> Modal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>umc-ui表格筛选不生效</title>
      <link href="/2023/07/31/axios-qing-qiu-bu-sheng-xiao/"/>
      <url>/2023/07/31/axios-qing-qiu-bu-sheng-xiao/</url>
      
        <content type="html"><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>偶然发现项目中一个表格筛选没有生效,传参字段值为<code> filter_redis_sentinel_instance_ids: tableFilterInfo.redis_sentinel_instance_id ?? undefined</code></p><img src="/2023/07/31/axios-qing-qiu-bu-sheng-xiao/fail.jpg" class="" title="表格筛选不生效"><p>上报缺陷以后，自己用 postman 试了一下，发现接口<code>v4/redis/sentinel_instance/list?page_index=1&amp;page_size=20&amp;filter_redis_sentinel_instance_ids[]=redis-sentinel-u97bvd</code>,当<code>filter_redis_sentinel_instance_ids</code>字段传入单个值的时候，是可以有效筛选出对应的节点 ID 数据的。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>寻求后端帮助，后端发现如果将<code>filter_redis_sentinel_instance_ids</code>参数值用逗号分隔开，而不是直接传数组，此时筛选是有效的。但是实践后发现由于后端将其定义为字符串数组类型，所以前端将它使用<code>join()</code>方法转换为字符串后，TS 语法检查过不去。此时解决方案是后端重新定义接口字段类型，将其从<code>string[]</code>转换为<code>string</code>,将参数修改为<code>filter_redis_sentinel_instance_ids:tableFilterInfo.redis_sentinel_instance_id?.[0]</code>。此时可以修复问题。</p><h2 id="类似问题"><a href="#类似问题" class="headerlink" title="类似问题"></a>类似问题</h2><p>发现项目中有很多类似的问题，比如 uProxy 页面实例列表有一个实例 id 筛选:</p><pre><code class="javascript">  React.useEffect(() =&gt; &#123;    if (!!selectData) &#123;      const groupId = selectData?.uproxy_group_id ?? &#39;&#39;;      UproxyService.listUproxyInstancesV6(&#123;        // 该参数类型定义为Array&lt;string&gt;，但传递数组是无效的，只能传递字符串。        filter_uproxy_group_ids: groupId as any,      &#125;).then((res) =&gt; &#123;        if (res.data &amp;&amp; res.data.length === 1) &#123;          setIsLast(true);        &#125; else &#123;          setIsLast(false);        &#125;      &#125;);    &#125;  &#125;, [selectData]);</code></pre><p>这里根据后端 swagger 文档生成的 api 接口定义里,<code>filter_uproxy_group_ids</code>字段是一个字符串数组，但是此时前端传递数组是无效的，只能传递字符串，但是 TS 检查过不去，所以这里使用了<code>as any</code>，这也是大部分同类问题没有出现问题的原因，比如：</p><pre><code class="javascript">const params: IListUproxyInstancesV6Params = &#123;  filter_uproxy_group_ids: info.uproxy_group_id?.[0],&#125;;</code></pre><p>由于<code>info</code>是<code>FilteredInfo</code>类型,所以此时传给<code>filter_uproxy_group_ids</code>的实际上是<code>any</code>类型,躲过了 TS 检查。但如果后续需求有多值筛选的时候，就无法躲过 TS 检查：</p><pre><code class="javascript">export type FilteredInfo = &#123;  [key: string]: any[] | null,&#125;;</code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>有后端同事反馈，这种重新定义接口的解决方案修复成本较高，因为每次修改接口定义都需要新增一个 v1-&gt;v2 这种类似的接口，但是内部逻辑是不变的。所以需要从前端角度再找一找其他的解决方案，降低以后修改项目里其他类似缺陷的修复成本。询问其他前端同事得到以下信息：</p><blockquote><p>问题本质原因是 axios 对 query 类型的参数的 format 格式与后端使用的 parse params 方式不匹配。axios 默认会将 query 中的 array 格式化城?a[]&#x3D;1&amp;a[]&#x3D;2 的格式，但是后端使用的 parse 只支持 ?a&#x3D;1,2 的格式。</p></blockquote><p>查阅了<a href="https://axios-http.com/zh/docs/req_config">axios 的官方文档</a> ,发现了配置项：</p><pre><code class="javascript">import qs from &#39;query-string&#39;paramsSerializer: function (params) &#123;  return qs.stringify(params, &#123;arrayFormat: &#39;brackets&#39;&#125;)&#125;</code></pre><p><code>arrayFormat</code>的默认值是<code>brackets</code>,所以出现了 url 中 a[]&#x3D;1 这种现象，导致筛选失败，将其修改为<code>comma</code>即可。</p><pre><code class="javascript">qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;indices&#39; &#125;);// &#39;a[0]=b&amp;a[1]=c&#39;qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;brackets&#39; &#125;);// &#39;a[]=b&amp;a[]=c&#39;qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;repeat&#39; &#125;);// &#39;a=b&amp;a=c&#39;qs.stringify(&#123; a: [&#39;b&#39;, &#39;c&#39;] &#125;, &#123; arrayFormat: &#39;comma&#39; &#125;);// &#39;a=b,c&#39;</code></pre><p>所以最终修改方式是修改 request 属性值</p><pre><code class="javascript">return handleTableRequestError(  RedisService.ListRedisSentinelInstancesV5(cleanEmptyParams(params)));// ----变更为--------return handleTableRequestError(  RedisService.ListRedisSentinelInstancesV5(cleanEmptyParams(params), &#123;    paramsSerializer(paramsAll) &#123;      return qs.stringify(paramsAll, &#123;        arrayFormat: &#39;comma&#39;,      &#125;);    &#125;,  &#125;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL必知必会笔记</title>
      <link href="/2023/07/17/sql-bi-zhi-bi-hui-bi-ji/"/>
      <url>/2023/07/17/sql-bi-zhi-bi-hui-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="在运行数据库增删改查脚本前预期创建一个新的数据库，报错："><a href="#在运行数据库增删改查脚本前预期创建一个新的数据库，报错：" class="headerlink" title="在运行数据库增删改查脚本前预期创建一个新的数据库，报错："></a>在运行数据库增删改查脚本前预期创建一个新的数据库，报错：</h2><blockquote><p>Error Code：1044，Access denied for user ‘root‘@’%’ to database ‘dbName’(Mysql::Error)</p></blockquote><p>解决方法：修改 mysql 数据库下的 user 表的 root 用户权限</p><pre><code class="bash">UPDATE mysql.user SET Grant_priv=&#39;Y&#39;, Super_priv=&#39;Y&#39; WHERE User=&#39;root&#39;;FLUSH PRIVILEGES;</code></pre><h2 id="删除行数据的时候报错："><a href="#删除行数据的时候报错：" class="headerlink" title="删除行数据的时候报错："></a>删除行数据的时候报错：</h2><p><code>DELETE FROM Customers WHERE cust_id = 1000000006</code></p><blockquote><p>Error Code：1142 - DELETE command denied to user ‘root‘@’222.71.242.202’ for table ‘Customers’</p></blockquote><p>解决办法：</p><ol><li>查看当前登录用户信息</li></ol><pre><code class="SQL">SELECT user, host, db, commandFROM information_schema.processlist</code></pre><p>结果：<br>user:root<br>host:222.71.242.202:54120<br>db:10Minute</p><ol start="2"><li>增加权限 <code>Delete_priv=&#39;Y&#39;</code></li></ol><h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2><p>MySQL 的日期类型有 5 个，分别是： date、time、year、datetime、timestamp。<br>Now(),CURRENT_TIMESTAMP(),CURRENT_DATE()</p><h3 id="MySQL-的日期类型如何设置当前时间为其默认值"><a href="#MySQL-的日期类型如何设置当前时间为其默认值" class="headerlink" title="MySQL 的日期类型如何设置当前时间为其默认值"></a>MySQL 的日期类型如何设置当前时间为其默认值</h3><p>使用 timestamp 类型，且 默认值设为 now() 或 current_timestamp()</p><h2 id="存储-url"><a href="#存储-url" class="headerlink" title="存储 url"></a>存储 url</h2><p>mysql 版本<br>低于 5.0.3：TEXT<br>5.0.3 及其以上：varChar(2083)</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><pre><code class="sql">CREATE PROCEDURE MailingListCount (OUT listCount INT)# 存储过程体开始BEGINDECLARE v_rows INT;SELECT COUNT(*) INTO v_rowsFROM CustomersWHERE NOT cust_email IS NULL;SET listCount=v_rows;END;# 存储过程体结束</code></pre><p>报错：Error code:1193,Unknown system variable ‘listCount’<br>解决：</p><pre><code class="sql">delimiter $$CREATE PROCEDURE MailingListCount (OUT `listCount` INT)BEGINDECLARE v_rows INT; SELECT COUNT(*) INTO v_rowsFROM CustomersWHERE NOT cust_email IS NULL;SET listCount=v_rows;END $$delimiter ;CALL MailingListCount(@result);SELECT @result;</code></pre><p>[注意]：out参数必须以<code>@</code>开头</p><h3 id="创建一个新订单"><a href="#创建一个新订单" class="headerlink" title="创建一个新订单"></a>创建一个新订单</h3><pre><code class="sql">delimiter $$CREATE PROCEDURE NewOrder(IN `cust_id` VARCHAR(10))BEGIN#为订单号声明一个变量DECLARE new_order_num INT; # 获取当前最大订单号,决定下一个订单号SET  new_order_num= MAX(order_num)+1;# 插入新订单INSERT INTO Orders(order_num, order_date, cust_id) VALUES(new_order_num, CURRENT_TIMESTAMP(),@cust_id); END $$delimiter ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环机制</title>
      <link href="/2023/07/13/shi-jian-xun-huan-ji-zhi/"/>
      <url>/2023/07/13/shi-jian-xun-huan-ji-zhi/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 在 chrome 的运行环境是 Google 的 V8 引擎，它的结构如下图所示：</p><img src="/2023/07/13/shi-jian-xun-huan-ji-zhi/js.png" class="" title="运行环境示意图"><p>从上图可以看出，V8 引擎主要包含 2 部分：</p><ul><li>内存堆：进行内存分配</li><li>调用栈：存储执行上下文<br>同时也可以发现我们平时用的 setTimeout 或者 DOM，并不存在于 V8 引擎内部，而是浏览器提供的，它们统称为 webAPI。</li></ul><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>JS 是单线程语言，这就意味着它只有一个调用栈，即同一时间只能执行一个任务。当程序进入一个函数时候，将其放在调用栈顶层，如果执行完这个函数，就将它从调用栈顶层弹出。</p><pre><code class="javascript">function multiply(a, b) &#123;  return a * b;&#125;function square(n) &#123;  return multiply(n, n);&#125;function printSquare(n) &#123;  var squared = square(n);  console.log(squared);&#125;printSquare(4);</code></pre><p>对应的调用栈：</p><img src="/2023/07/13/shi-jian-xun-huan-ji-zhi/stack.png" class="" title="栈过程示意图"><p>堆栈溢出就是因为调用中的函数数量超出了调用栈的实际大小</p><img src="/2023/07/13/shi-jian-xun-huan-ji-zhi/error.png" class=""><img src="/2023/07/13/shi-jian-xun-huan-ji-zhi/overflow.jpg" class="" title="栈溢出"><h2 id="单线程带来的问题"><a href="#单线程带来的问题" class="headerlink" title="单线程带来的问题"></a>单线程带来的问题</h2><p>由于 JS 只有一个调用栈，如果有函数需要花费大量时间处理，比如 http 请求,请求期间不能做其他任何操作，导致页面卡住运行不流畅。可能浏览器还会弹出错误，询问是否应该终止页面。</p><h2 id="解决方法：异步回调函数"><a href="#解决方法：异步回调函数" class="headerlink" title="解决方法：异步回调函数"></a>解决方法：异步回调函数</h2><p>产生了事件循环和任务队列的概念<br>事件循环的本质是：监视调用栈和任务队列。如果调用栈为空，它将从队列中获取第一个事件，并将其推送到调用堆栈，然后运行它。</p><p>异步任务主要包括宏任务和微任务：<br>宏任务：setTimeout&#x2F;setInterval,回调函数将在下一个事件循环中执行<br>微任务：Promise,process.nextTick,回调函数将会在下一个事件循环之前执行,作为本次事件循环的 task queue 的附加</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ol><li>主线程执行所有的同步任务，碰到异步任务放到任务队列中</li><li>调用栈清空后，查看异步任务队列</li><li>查看本次事件循环中是否有微任务，如果有，就立刻执行微任务</li><li>微任务执行完成后，再去宏任务队列中取新的宏任务放入栈中</li></ol><pre><code class="javascript">console.log(&quot;1&quot;);setTimeout(function () &#123;  console.log(&quot;2&quot;);  process.nextTick(function () &#123;    console.log(&quot;3&quot;);  &#125;);  new Promise(function (resolve) &#123;    console.log(&quot;4&quot;);    resolve();  &#125;).then(function () &#123;    console.log(&quot;5&quot;);  &#125;);&#125;);process.nextTick(function () &#123;  console.log(&quot;6&quot;);&#125;);new Promise(function (resolve) &#123;  console.log(&quot;7&quot;);  resolve();&#125;).then(function () &#123;  console.log(&quot;8&quot;);&#125;);setTimeout(function () &#123;  console.log(&quot;9&quot;);  process.nextTick(function () &#123;    console.log(&quot;10&quot;);  &#125;);  new Promise(function (resolve) &#123;    console.log(&quot;11&quot;);    resolve();  &#125;).then(function () &#123;    console.log(&quot;12&quot;);  &#125;);&#125;);// 1,7,6,8,2,4,3,5,9,11,10,12</code></pre><h2 id="关于-asnyc…await-的一些细节"><a href="#关于-asnyc…await-的一些细节" class="headerlink" title="关于 asnyc…await 的一些细节"></a>关于 asnyc…await 的一些细节</h2><p>async…await 的出现是为了简化使用和编写链式 promise 的过程,但是 async 函数会根据返回值的类型，V8 引擎的处理方式也不一样。async 函数在抛出返回值时，会根据<strong>返回值类型</strong>开启<strong>不同数目的微任务</strong>。</p><h3 id="async函数返回值："><a href="#async函数返回值：" class="headerlink" title="async函数返回值："></a>async函数返回值：</h3><ol><li>返回值非 thenable（非 promise）：不等待</li></ol><pre><code class="javascript">async function testA() &#123;  return 1;&#125;testA().then(() =&gt; console.log(1));Promise.resolve()  .then(() =&gt; console.log(2))  .then(() =&gt; console.log(3));// (不等待)最终结果👉: 1 2 3</code></pre><ol start="2"><li>返回值为 thenable：等待 1 个 then 的时间</li></ol><pre><code class="javascript">async function testB () &#123;    return &#123;        then (cb) &#123;            cb();        &#125;    &#125;;&#125;testB().then(() =&gt; console.log(1));Promise.resolve()    .then(() =&gt; console.log(2))    .then(() =&gt; console.log(3));​// (等待一个then)最终结果👉: 2 1 3</code></pre><ol start="3"><li>返回值为 promise:等待 2 个 then 时间</li></ol><pre><code class="javascript">async function testC() &#123;  return new Promise((resolve, reject) =&gt; &#123;    resolve();  &#125;);&#125;testC().then(() =&gt; console.log(1));Promise.resolve()  .then(() =&gt; console.log(2))  .then(() =&gt; console.log(3))  .then(() =&gt; console.log(4));// (等待两个then)最终结果👉: 2 3 1 4</code></pre><h3 id="await-右值类型的区别"><a href="#await-右值类型的区别" class="headerlink" title="await 右值类型的区别"></a>await 右值类型的区别</h3><ol><li>接非thenable类型：会立即向微任务队列中添加一个微任务then,但是不需要等待</li></ol><pre><code class="javascript">async function test () &#123;    console.log(1);    await 1;    console.log(2);&#125;test();console.log(3);// 最终结果👉: 1 3 2</code></pre><ol start="2"><li>接thenable类型：需要等待一个 then 的时间之后执行</li></ol><pre><code class="javascript">async function test () &#123;    console.log(1);    await &#123;        then (cb) &#123;            cb();        &#125;,    &#125;;    console.log(2);&#125;​test();console.log(3);​Promise.resolve()    .then(() =&gt; console.log(4))    .then(() =&gt; console.log(5))    .then(() =&gt; console.log(6))    .then(() =&gt; console.log(7));​// 最终结果👉: 1 3 4 2 5 6 7</code></pre><ol start="3"><li>接promise类型（有确定的返回值）：立即向微任务队列添加一个微任务then，但不需等待</li></ol><pre><code class="javascript">async function test () &#123;    console.log(1);    await new Promise((resolve, reject) =&gt; &#123;        resolve()    &#125;)    console.log(2);&#125;​test();console.log(3);​Promise.resolve()    .then(() =&gt; console.log(4))    .then(() =&gt; console.log(5))    .then(() =&gt; console.log(6))    .then(() =&gt; console.log(7));​// 最终结果👉: 1 3 2 4 5 6 7</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>event-loop</title>
      <link href="/2023/07/11/event-loop/"/>
      <url>/2023/07/11/event-loop/</url>
      
        <content type="html"><![CDATA[<p>画图工具：<a href="https://www.liuchengtu.com/charts/">https://www.liuchengtu.com/charts/</a></p><h3 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h3><h4 id="单线程："><a href="#单线程：" class="headerlink" title="单线程："></a>单线程：</h4><p>单线程&#x3D;&#x3D;有且仅有一个调用栈&#x3D;&#x3D;一次做一件事情&#x3D;&#x3D;程序每次只可以运行一段代码</p><h4 id="调用栈："><a href="#调用栈：" class="headerlink" title="调用栈："></a>调用栈：</h4><p>记录当前程序所在位置的数据结构。如果当前进入了某个函数，这个函数就会被放入栈中，如果当前离开了某个函数，这个函数就会被弹出栈外</p><pre><code class="javascript">function multiply(a, b) &#123;  return a * b;&#125;function square(n) &#123;  return multiply(n, n);&#125;function printSquare(n) &#123;  var squared = square(n);  console.log(squared);&#125;printSquare(4);</code></pre><ol><li>main():指代文件自身，放入栈中</li><li>从上到下查看声明的函数，最后是<code>printSquare</code>，最终是其被调用</li><li>将<code>printSquare</code>推入栈中，<code>printSquare</code>调用了<code>square</code></li><li>将<code>square</code>推入栈中，<code>square</code>调用了<code>multiply</code></li><li>将<code>multiply</code>推入栈中</li><li>得到<code>multiply</code>返回值，将<code>multiply</code>推出栈</li><li>依次执行并将函数推出栈</li></ol><img src="/2023/07/11/event-loop/stack.png" class="" title="栈过程示意图"><p>如果我们在 <code>multiply</code>中使用 throw 抛出错误，则控制台会出现：</p><pre><code class="javascript">preview-9c596f222c88a.js:2 Error: 报错信息    at multiply (script.js:2:11)    at square (script.js:5:12)    at printSquare (script.js:8:19)    at script.js:11:1</code></pre><p>典型场景：内存溢出</p><img src="/2023/07/11/event-loop/overflow.jpg" class="" title="栈溢出"><p>报错信息：</p><pre><code class="javascript">RangeError: Maximum call stack size exceeded    at foo (script.js:12:5)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)    at foo (script.js:12:12)</code></pre><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞:"></a>阻塞:</h4><p>定义：没有严格定义，仅仅指的是代码运行的很慢，即在栈里表现很慢的东西都叫阻塞</p><pre><code class="javascript">var foo = fetch(&quot;//foo.com&quot;);var boo = fetch(&quot;//boo.com&quot;);var coo = fetch(&quot;//coo.com&quot;);console.log(foo);console.log(boo);console.log(coo);</code></pre><img src="/2023/07/11/event-loop/fetch.png" class="" title="网络请求导致的阻塞"><p>如上所示：当上面所有的代码都跑一遍，栈才会被清空。而 JS 是单线程语言，所以我们如果请求一个资源，就只能等着请求完成。<br>导致的问题：代码需要在浏览器上运行，请求期间不能做其他任何操作，导致页面卡住运行不流畅</p><h3 id="V8-运行环境"><a href="#V8-运行环境" class="headerlink" title="V8 运行环境"></a>V8 运行环境</h3><img src="/2023/07/11/event-loop/js.png" class="" title="运行环境示意图"><h4 id="V8-引擎【V8-chrome-中的运行环境】"><a href="#V8-引擎【V8-chrome-中的运行环境】" class="headerlink" title="V8 引擎【V8 chrome 中的运行环境】"></a>V8 引擎【V8 chrome 中的运行环境】</h4><ul><li>堆 heap:记录内存分配</li><li>栈 stack: 存储执行上下文</li></ul><h4 id="V8-外部【浏览器提供】"><a href="#V8-外部【浏览器提供】" class="headerlink" title="V8 外部【浏览器提供】"></a>V8 外部【浏览器提供】</h4><ul><li>webAPI<ul><li>DOM</li><li>Ajax</li><li>SetTimeout</li></ul></li><li>Callback queue</li><li>event loop</li></ul><h2 id="阻塞的解决方法"><a href="#阻塞的解决方法" class="headerlink" title="阻塞的解决方法"></a>阻塞的解决方法</h2><h3 id="提供回调函数"><a href="#提供回调函数" class="headerlink" title="提供回调函数"></a>提供回调函数</h3><p>前提：浏览器和 node 中几乎没有阻塞的函数,都是非同步（异步）的</p><pre><code class="javascript">console.log(&quot;hi&quot;);setTimeout(() =&gt; &#123;  console.log(&quot;there&quot;);&#125;, 5000);console.log(&quot;end&quot;);</code></pre><img src="/2023/07/11/event-loop/timout.png" class="" title="setTimeout的栈"><p>为什么呢？原因是一次做一件事情指的是 js Runtime 只能同时做一件事，但浏览器不止有 RuntTime，还提供了其他的东西。所以我们可以同时做多件事,ajax 请求等其他 webAPI 同理</p><img src="/2023/07/11/event-loop/loop.png" class=""><p>注意：任务队列中的回调函数必须等 stack 中清空了才能入栈执行。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>宏任务：setTimeout&#x2F;setInterval,回调函数将在下一个事件循环中执行<br>微任务：Promise,回调函数将会在下一个事件循环之前执行,作为本次事件循环的 task queue 的附加</p><h3 id="asyn…await"><a href="#asyn…await" class="headerlink" title="asyn…await"></a>asyn…await</h3><p>简化使用和编写链式 promise 的过程，返回值为 promise<br>多个请求写法：</p><pre><code class="javascript">async function getAdd() &#123;  let [street, city, state] = await Promise.all([getStreet, getCity, getState]);&#125;</code></pre><h2 id="async-函数返回值"><a href="#async-函数返回值" class="headerlink" title="async 函数返回值"></a>async 函数返回值</h2><p>根据返回值的类型，V8 引擎对返回值的处理方式也不一样<br>结论：async 函数在抛出返回值时，会根据<strong>返回值类型</strong>开启<strong>不同数目的微任务</strong></p><h3 id="thenable"><a href="#thenable" class="headerlink" title="thenable"></a>thenable</h3><p>是一个对象或者函数<br>判断标准：某个对象或者函数是否具有 then(…)方法来判断</p><pre><code class="javascript">if (  p !== null &amp;&amp;  (typeof p === &quot;object&quot; || typeof p === &quot;function&quot;) &amp;&amp;  typeof p.then === &quot;function&quot;) &#123;  //thenable&#125; else &#123;  //非thenable&#125;</code></pre><ul><li>非 thenable，非 promise：不等待</li></ul><pre><code class="js">async function testA() &#123;  return 1;&#125;testA().then(() =&gt; console.log(1));Promise.resolve()  .then(() =&gt; console.log(2))  .then(() =&gt; console.log(3));// (不等待)最终结果👉: 1 2 3</code></pre><ul><li>thenable：等待 1 个 then 的时间</li></ul><pre><code class="javascript">async function testB () &#123;     return &#123;         then (cb) &#123;             cb();         &#125;     &#125;; &#125; testB().then(() =&gt; console.log(1)); Promise.resolve()     .then(() =&gt; console.log(2))     .then(() =&gt; console.log(3));// (等待一个then)最终结果👉: 2 1 3</code></pre><ul><li>promise:等待 2 个 then 的时间</li></ul><pre><code class="javascript">async function testC () &#123;    return new Promise((resolve, reject) =&gt; &#123;        resolve()    &#125;)&#125;testC().then(() =&gt; console.log(1));Promise.resolve()    .then(() =&gt; console.log(2))    .then(() =&gt; console.log(3));// (等待两个then)最终结果👉: 2 3 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useEffectEvent的前世今生</title>
      <link href="/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/"/>
      <url>/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/</url>
      
        <content type="html"><![CDATA[<p>去年 React 团队分享了一个新 Hook <code>useEvent</code> 的<a href="https://github.com/reactjs/rfcs/pull/220">RFC220</a>,完整 RFC 内容见<a href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md">useEvent</a>。这个 Hook 的来源是<a href="https://github.com/facebook/react/issues/14099">#14099</a>。 useEvent 的<a href="https://github.com/facebook/react/pull/25229">原型</a>已经实现，但是今年 1 月份关闭了<code>useEvent</code>提案，为什么会关闭呢，主要有以下几个原因：</p><ol><li>将渲染优化和“修复”Effect 耦合在一个提案下，很难实现</li><li>容易诱导开发者将当前使用 <code>useCallback</code> 包裹的函数都替换成 <code>useEvent</code></li></ol><p>但是关闭提案并不意味着全盘否定，事实上，只是对其进行了拆分。针对渲染优化，React 团队准备开发一个<a href="https://www.youtube.com/watch?v=lGEMwh32soc">自动记忆编译器</a>，而针对修复 Effect，则发布了一个 <code>useEffectEvent</code>的新的 Hook。</p><p>官方之前在 RFC 给出的 useEvent 的大概实现如下所示，当然这不是真正的实现，真正的实现肯定比这个复杂得多：</p><pre><code class="javascript">// (!) Approximate behaviorfunction useEvent(handler) &#123;  const handlerRef = useRef(null);  // 渲染之前运行  useLayoutEffect(() =&gt; &#123;    handlerRef.current = handler;  &#125;);  return useCallback((...args) =&gt; &#123;    // 渲染期间执行的话，会抛出错误    const fn = handlerRef.current;    return fn(...args);  &#125;, []);&#125;</code></pre><p>下面就借助代码来讲述一下这个新的 Hook 应该怎么使用。<br>当前存在的问题：<br>你创建了一个聊天连接，把当前的 message 存储在 state 变量中，每次输入的时候更新 message,当用户准备好后就可以发送。</p><pre><code class="javascript">function Chat() &#123;  const [message, setMessage] = React.useState(&quot;&quot;);  const sendMessage = (val) =&gt; &#123;    console.log(val);  &#125;;  const onSend = () =&gt; &#123;    sendMessage(message);  &#125;;  return (    &lt;&gt;      &lt;Input onSend=&#123;onSend&#125; setMessage=&#123;setMessage&#125; /&gt;    &lt;/&gt;  );&#125;</code></pre><p>在上面的例子中，由于 <code>onSend</code> 的函数引用每次都会变化，即每次的 <code>onSend</code> 都是重新创建的不同的函数，这会直接破坏 Input 组件的 memo 效果，原因是当一个组件被 memoize 后,会对 props 进行浅层比较来决定是否需要重新渲染。如果 props 是“浅相等”(同一个引用),就跳过重新渲染。而 <code>onSend</code> 每次都跟上一次不一样。</p><p>那如何优化呢？很明显可以使用<code>useCallback</code>包裹<code>onSend</code>函数，保证只有 state 变量变化时，<code>onSend</code>函数才会被重新创建。</p><pre><code class="javascript">const onSend = React.useCallback(() =&gt; &#123;  sendMessage(message);&#125;, [message]);</code></pre><p>通过这个修改，Input 组件只有在 <code>onSend</code> 函数重新创建的时候 <code>Input</code> 组件才会重新渲染。但是这样并不完全契合我们的预期，因为每当 message 变化， <code>onSend</code> 函数还是会被重新创建。但是如果去掉依赖项，就获取不到最新的 message 值。</p><img src="/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/recreate.png" class=""><p>还可以通过 ref 修复这个问题:使用 sendRef 存储事件处理函数，这样你输入的时候 onSend 函数会一直保持为同一个函数标识符</p><pre><code class="javascript">const sendRef = React.useRef(null);React.useLayoutEffect(() =&gt; &#123;  sendRef.current = () =&gt; sendMessage(message);&#125;);const onSend = React.useCallback((...args) =&gt; &#123;  return sendRef.current(...args);&#125;, []);</code></pre><p>尽管这个方法能解决我们的问题，但是很明显牺牲了代码可读性。基于以上的问题，React 团队推出了一个新的 Hook <code>useEffectEvent</code>，使用起来非常方便。</p><p>但是因为这个 Hook 目前还没有在稳定版 React 中发布，所以需要先安装实验版本的 React</p><pre><code class="bash">npm install react@experimentalnpm install react-dom@experimentalnpm install eslint-plugin-react-hooks@experimental</code></pre><p>现在只需要直接用 <code>useEffectEvent</code> 将回调函数包裹起来就可以</p><pre><code class="javascript">import &#123; experimental_useEffectEvent as useEffectEvent &#125; from &quot;react&quot;;const onSend = React.experimental_useEffectEvent(() =&gt; &#123;  sendMessage(message);&#125;);</code></pre><p>新的 Hook useEffectEvent 允许用户定义一个函数，可以一直读取到最新的 props&#x2F;state，但是和这个函数会有一个稳定的标识符，所以他不会破坏缓存，也不会重新触发 Effect,可以减少不必要的渲染。它和 <code>useCallback</code> 的区别是:</p><ol><li>重渲染次数的显著不同：<img src="/2023/07/06/useeffectevent-de-qian-shi-jin-sheng/retrigger.png" class=""></li><li>useEffectEvent 不需要依赖项列表</li></ol><p>useEvent 的返回值，它的行为就和普通函数一样，所以也可以给他传递参数，比如 <code>roomID</code></p><pre><code class="javascript">const onSend = useEffectEvent((roomID) =&gt; &#123;  sendMessage(roomID, message);&#125;);onSend(roomID);</code></pre><p>回到 Chat 组件，每当 roomID 变化时就展示一个成功的 alert 并清空 message,使用 useEffect 可以达到目的。</p><pre><code class="javascript">function Chat() &#123;  const [message, setMessage] = React.useState(&quot;&quot;);  const [roomID, setRoomID] = React.useState(&quot;reavel&quot;);  const sendMessage = (val) =&gt; &#123;    console.log(val);  &#125;;  const onSend = React.experimental_useEffectEvent(() =&gt; &#123;    sendMessage(message);  &#125;);  React.useEffect(() =&gt; &#123;    if (!!roomID) &#123;      showNotification(&quot;Changed room-&gt;&quot; + roomID, &quot;dark&quot;);      setMessage(&quot;&quot;);    &#125;  &#125;, [roomID]);  return (    &lt;&gt;      &lt;div&gt;        &lt;select          onChange=&#123;(e) =&gt; &#123;            setRoomID(e.target.value);          &#125;&#125;        &gt;          &lt;option value=&quot;travel&quot;&gt;travel room&lt;/option&gt;          &lt;option value=&quot;music&quot;&gt;music room&lt;/option&gt;          &lt;option value=&quot;sport&quot;&gt;sport room&lt;/option&gt;        &lt;/select&gt;      &lt;/div&gt;      &lt;Input onSend=&#123;onSend&#125; setMessage=&#123;setMessage&#125; message=&#123;message&#125; /&gt;    &lt;/&gt;  );&#125;</code></pre><p>但是如果 toast 是从当前的主题上下文中读取的话，代码检查工具会提示你需要将 theme 添加到依赖项中</p><pre><code class="javascript">function Chat() &#123;  const theme = useContext(ThemeContext);  const [message, setMessage] = useState(&quot;&quot;);  const onSend = useEffectEvent(() =&gt; &#123;    setMessage(message);  &#125;);  React.useEffect(() =&gt; &#123;    if (!!roomID) &#123;      showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);      setMessage(&quot;&quot;);    &#125;  &#125;, [roomID, theme]);  return &lt;Input onSend=&#123;onSend&#125; /&gt;;&#125;</code></pre><p>实际上主题色变化的时候，连接的房间并没发生变化，所以实际上我们并不需要重新展示消息。我们可以使用 <code>useCallback</code> 将代码从 <code>useEffect</code> 中提取出来。</p><pre><code class="javascript">const theme = useContext(ThemeContext);const onChangedRoom = useCallback(() =&gt; &#123;  showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);  setMessage(&quot;&quot;);&#125;, [theme]);useEffect(() =&gt; &#123;  onChangedRoom();&#125;, [roomID]);return &lt;Input onSend=&#123;onSend&#125; /&gt;;</code></pre><p>但是因为 <code>useEffectEvent</code> 在防止不必要的重渲染上更有意义,所以我们使用 <code>useEffectEvent</code> 包裹对应的代码，使它变成非响应式代码。</p><pre><code class="javascript">const theme = useContext(ThemeContext);const onChangedRoom = useEffectEvent(() =&gt; &#123;  showNotification(&quot;Changed room-&gt;&quot; + roomID, theme);  setMessage(&quot;&quot;);&#125;);useEffect(() =&gt; &#123;  onChangedRoom();&#125;, [roomID]);return &lt;Input onSend=&#123;onSend&#125; /&gt;;</code></pre><p>这样既减少了不必要的重渲染，代码可读性也得到了改善。</p><p>那哪些情况不适合用 useEffectEvent 呢？即需要在渲染期间调用的函数,因为 useEffectEvent 在渲染期间运行会抛出错误</p><pre><code class="javascript">function ThemedGrid() &#123;  const theme = useContext(ThemeContext);  const renderItem = useCallback(    (item) =&gt; &#123;      // 渲染期间调用，所以他不是一个事件      return &lt;Row &#123;...item&#125; theme=&#123;theme&#125; /&gt;;    &#125;,    [theme]  );  return &lt;Grid renderItem=&#123;renderItem&#125; /&gt;;&#125;</code></pre><p>代码：<a href="https://stackblitz.com/edit/stackblitz-starters-ida8fu">https://stackblitz.com/edit/stackblitz-starters-ida8fu</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-useEffectEvent-is-coming-to-React</title>
      <link href="/2023/07/03/fan-yi-useeffectevent-is-coming-to-react/"/>
      <url>/2023/07/03/fan-yi-useeffectevent-is-coming-to-react/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://vived.io/useeffectevent-is-coming-to-react-frontend-weekly-vol-118/">https://vived.io/useeffectevent-is-coming-to-react-frontend-weekly-vol-118/</a></p><h2 id="useEvent-已死-useEffectEvent-万岁！"><a href="#useEvent-已死-useEffectEvent-万岁！" class="headerlink" title="useEvent 已死, useEffectEvent 万岁！"></a>useEvent 已死, useEffectEvent 万岁！</h2><p>六个多月前，React 团队向全世界分享了一个有关新 hook <code>useEvent</code> 的意见征求。它本该返回一个稳定的函数引用。同时函数内的 state 也应该总是对应组件的当前 state。这种行为可以非常有效地优化不必要的渲染。</p><pre><code class="javascript">function Chat() &#123;  const [text, setText] = useState(&#39;&#39;);  // 🟡 只要`text` 变化，就返回一个不同的函数  const onClick = useCallback(() =&gt; &#123;    sendMessage(text);  &#125;, [text]);  return &lt;SendButton onClick=&#123;onClick&#125; /&gt;;&#125;</code></pre><pre><code class="javascript">function Chat() &#123;  const [text, setText] = useState(&#39;&#39;);  // ✅总是返回相同的函数 (即使 `text` 变化)  const onClick = useEvent(() =&gt; &#123;    sendMessage(text);  &#125;);  return &lt;SendButton onClick=&#123;onClick&#125; /&gt;;&#125;</code></pre><p>不幸的是，RFC 完成了它的工作并展开了许多讨论。最终，这些讨论引发了了 Hook 创建者心里的疑虑，他们决定暂停其实现。此时两个反对的论据浮出了水面。首先，用户可能会这个新 Hook 当做优化版的<code>useCallback</code>，将两者混淆。事实上，这两个 hook 本应该有稍微不同的功能。其次，除了 <code>useEvent</code> 之外，开发者还致力于开发一个能够实现函数调用自动缓存的编译器。同时处理这两个功能太麻烦了。</p><blockquote><p>当一个函数接收相同的参数时,并不需要重新计算结果,而是直接使用缓存的结果。这就是 memoization 的工作原理。</p></blockquote><p>所有迹象都表明 <code>useEvent</code> 将会以另一种形式回到我们视野。一个神秘的PR出现在了React的仓库中。它将 <code>useEvent</code> 重命名为  <code>useEffectEvent</code> ,且稍微改变了一下它的行为。从现在起，这个函数不会返回一个稳定的引用，但是你仍然可以在<code>useEffect</code> 中引用它，而不需要将其指定为依赖项。</p><pre><code class="javascript">function Chat() &#123;  const [text, setText] = useState(&#39;&#39;);  const [state, setState] = useState&lt;State&gt;(&#39;INITIAL&#39;);  const onHappened = useEffectEvent(() =&gt; &#123;    logValueToAnalytics(text);  &#125;);  useEffect(() =&gt; &#123;    onHappened();  &#125;, [state]);  return (/*...*/);&#125;</code></pre><p>现在这个PR还没有完整的RFC文档描述，所以很难预测<code>useEffectEvent</code> 的未来或者对他的功能做出更清楚的结论。毫无疑问，当RFC最终出现的时候，会提供更多的上下文，并且你肯定会在我们的周报中读到它。</p><p>参考链接：</p><ol><li><a href="https://github.com/facebook/react/pull/25881">useEvent 命名为 useEffectEvent</a></li><li><a href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md">useEvent 完整提案</a></li><li><a href="https://github.com/reactjs/rfcs/pull/220">useEvent 提案描述</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做自己的github介绍页面</title>
      <link href="/2023/06/27/ru-he-zuo-zi-ji-de-github-jie-shao-ye-mian/"/>
      <url>/2023/06/27/ru-he-zuo-zi-ji-de-github-jie-shao-ye-mian/</url>
      
        <content type="html"><![CDATA[<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>新建同名仓库，比如 GitHub 的用户名是<code>earthaYan</code>，则新建仓库<code>earthaYan</code>，而不是<code>earthaYan.github.io</code></li><li>新建时仓库选择 public 并且生成 README.md</li><li>编辑 README 文件</li></ol><h2 id="文章编辑"><a href="#文章编辑" class="headerlink" title="文章编辑"></a>文章编辑</h2><h3 id="添加-banner-图片"><a href="#添加-banner-图片" class="headerlink" title="添加 banner 图片"></a>添加 banner 图片</h3><pre><code class="html">&lt;picture&gt;  &lt;source    media=&quot;(prefers-color-scheme: dark)&quot;    srcset=&quot;https://github.com/earthaYan/earthaYan/blob/main/3072.webp&quot;  /&gt;  &lt;source    media=&quot;(prefers-color-scheme: light)&quot;    srcset=&quot;https://github.com/earthaYan/earthaYan/blob/main/3072.webp&quot;  /&gt;  &lt;img    alt=&quot;Shows an illustrated sun in light mode and a moon with stars in dark mode.&quot;    src=&quot;https://github.com/earthaYan/earthaYan/blob/main/3072.webp&quot;  /&gt;&lt;/picture&gt;</code></pre><h3 id="添加-github-stats"><a href="#添加-github-stats" class="headerlink" title="添加 github stats"></a>添加 github stats</h3><pre><code class="md">[![earthaYan的 GitHub](https://github-readme-stats.vercel.app/api?username=earthaYan&amp;show_icons=true&amp;title_color=fff&amp;icon_color=79ff97&amp;text_color=9f9f9f&amp;bg_color=151515)](https://github.com/earthaYan)</code></pre><h3 id="添加使用的语言"><a href="#添加使用的语言" class="headerlink" title="添加使用的语言"></a>添加使用的语言</h3><pre><code class="md">&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;https://github-readme-stats-crlnmfdzg-tifan.vercel.app/api/top-langs/?username=earthaYan&amp;langs_count=8&amp;layout=compact&quot; height=&quot;160&quot; /&gt;&lt;/a&gt;</code></pre><h3 id="添加技能"><a href="#添加技能" class="headerlink" title="添加技能"></a>添加技能</h3><pre><code class="md">[![My Skills](https://skillicons.dev/icons?i=go,docker,express)](https://skillicons.dev)</code></pre><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/managing-your-profile-readme">manage github profile</a><br><a href="https://github.com/anuraghazra/github-readme-stats">github stats</a><br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">emoji</a><br><a href="https://github.com/tandpfun/skill-icons">skills icon</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在centos上运行cobra创建的命令</title>
      <link href="/2023/05/24/ru-he-zai-centos-shang-yun-xing-cobra-chuang-jian-de-ming-ling/"/>
      <url>/2023/05/24/ru-he-zai-centos-shang-yun-xing-cobra-chuang-jian-de-ming-ling/</url>
      
        <content type="html"><![CDATA[<ol><li>编写源码</li></ol><pre><code class="go">package mainimport (  &quot;fmt&quot;  &quot;github.com/spf13/cobra&quot;)var rootCmd = &amp;cobra.Command&#123;  Use:   &quot;demo&quot;,  Short: &quot;A brief description of your application&quot;,  Run: func(cmd *cobra.Command, args []string) &#123;    fmt.Println(&quot;Hello CentOS!&quot;)  &#125;,&#125;func main() &#123;  rootCmd.Execute()&#125;</code></pre><ol start="2"><li>本地编译，生成可执行文件<br><code>go build -o demo main.go</code></li><li>运行demo命令<br><code>./demo</code></li><li>非必选：将demo命令添加到centos的全局环境中<br><code>mv demo /usr/local/bin </code></li><li>接下来就可以直接通过demo命令在任何目录下执行该应用</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React_Router中的Prompt</title>
      <link href="/2023/05/23/react-router-zhong-de-prompt/"/>
      <url>/2023/05/23/react-router-zhong-de-prompt/</url>
      
        <content type="html"><![CDATA[<p>web 中的<code>Prompt</code>组件是从核心的<code>Prompt</code>中二次导出的。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>作用：在从一个页面导航离开之前给用户提示。</li><li>场景：应用处在一个应该阻止用户离开当前页面的状态</li><li>实际场景：表单填了一半，用户想要离开</li><li>使用：</li></ul><pre><code class="jsx">&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=&quot;Are you sure you want to leave?&quot; /&gt;</code></pre><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><p>可以直接传写死的布尔值，而不是有条件地在守卫后面渲染<code>Prompt</code></p><ol><li>true:阻止导航</li><li>false：允许导航</li></ol><h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>当用户试图离开当前页时，会给用户这个字符串信息</p><img src="/2023/05/23/react-router-zhong-de-prompt/prompt.jpeg" class=""><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><pre><code class="jsx">export function Users() &#123;  return (    &lt;React.Fragment&gt;      &lt;Prompt        message=&#123;(nextLocation, action) =&gt; &#123;          if (action === &#39;POP&#39;) &#123;            console.log(&#39;Backing up...&#39;);          &#125;          return nextLocation.pathname.startsWith(&#39;/app&#39;)            ? false            : `Are you sure you want to go to $&#123;location.pathname&#125;?`;        &#125;&#125;      /&gt;      &lt;h2&gt;Users&lt;/h2&gt;    &lt;/React.Fragment&gt;  );&#125;</code></pre><p>会在进入用户试图导航进入的下一个 <code>location</code>和 <code>action</code>之前被调用。<br>返回值：</p><ol><li>string：向用户展示一个提示,用户点击确定后跳转，点击取消停留在原地</li><li>true：允许这个过度，直接跳转到nextLocation</li><li>false:不允许过度，且点击link无反应</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pflag笔记</title>
      <link href="/2023/05/19/pflag-bi-ji/"/>
      <url>/2023/05/19/pflag-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>前提：pflag 是完全兼容 flag 的</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装：<code>go get github.com/spf13/pflag</code><br>测试：<code>go test github.com/spf13/pflag</code></p><h2 id="在包中引入并定义-flag"><a href="#在包中引入并定义-flag" class="headerlink" title="在包中引入并定义 flag"></a>在包中引入并定义 flag</h2><p><code>import flag &quot;github.com/spf13/pflag&quot;</code></p><ul><li>使用 lag.String(),Bool(),Int()等声明 flag<br><code>var ip *int = flag.Int(&quot;flagName&quot;, 1234, &quot;help message for flagName&quot;)</code></li><li>使用 Var()函数将 flag 绑定到一个变量</li></ul><pre><code class="go">var ipFlag intflag.IntVar(&amp;ipFlag,&quot;flagName&quot;,1234,&quot;help message from flagName&quot;)</code></pre><ul><li>创建满足 Value 接口的自定义 flag</li></ul><pre><code class="go">type Duration time.Durationfunc (d *Duration) Set(s string) error &#123;  // 解析s为 Duration 并保存&#125;func (d *Duration) Type() string &#123;  return &quot;duration&quot;&#125;func (d *Duration) String() string &#123;  return time.Duration(*d).String()&#125;var duration Durationpflag.Var(&amp;duration, &quot;duration&quot;, &quot;Some duration&quot;)</code></pre><p>当你在命令行参数中传入<code>--duration=1m30s</code>后:</p><ol><li>pflag 找到 Duration 类型并调用 Set(“1m30s”)</li><li>Set()方法使用指针接收器解析该值并保存在 Duration 的内部字段中</li><li>duration 现在保存传递的值(90 秒)</li><li>通过 duration.String()或直接使用 duration 的值访问解析后的值</li></ol><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>前提：所有的 flag 都定义好了<br>方法：<code>flag.Parse()</code></p><pre><code class="go">    var ip *int = flag.Int(&quot;ip&quot;, 123, &quot;help message from ip&quot;)    var ipFlag int    flag.IntVar(&amp;ipFlag, &quot;ipFlag&quot;, 1234, &quot;help message from ipFlag&quot;)    flag.Parse()    fmt.Println(*ip,ipFlag)</code></pre><p>执行<code>go run . --ipFlag=12 --ip=345</code>,运行结果为 345,12</p><h3 id="flagSet"><a href="#flagSet" class="headerlink" title="flagSet"></a>flagSet</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github的常用操作</title>
      <link href="/2023/05/05/github-de-chang-yong-cao-zuo/"/>
      <url>/2023/05/05/github-de-chang-yong-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/FrontEndGitHub/FrontEndGitHub/issues/4">https://github.com/FrontEndGitHub/FrontEndGitHub/issues/4</a></p><p>issue 标签页：</p><ul><li>查询所有状态为 open 的 issue<br><code>is:issue is:open</code></li><li>查询所有状态为 open 的 PR<br><code>is:pr is:open</code></li><li>查询指定发布者的 issue<br><code>is:issue author:_author_name_</code></li><li>查询自己的 issue<br><code>is:issue author:@me</code></li><li>查询指定标签的 issue<br><code>is:issue label:&quot;_label_name_&quot;</code></li><li>查询没有指定标签的issue<br><code>is:issue no:label</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的createPortal</title>
      <link href="/2023/04/25/react-de-createportal/"/>
      <url>/2023/04/25/react-de-createportal/</url>
      
        <content type="html"><![CDATA[<h1 id="React-createPortal"><a href="#React-createPortal" class="headerlink" title="React.createPortal()"></a>React.createPortal()</h1><p>作用：把部分子组件渲染到不同于父组件 DOM 节点的指定 DOM 节点</p><p>使用：<br><code>React.createPortal(children,domNode)</code></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><pre><code class="javascript">import &#123; createPortal &#125; from &#39;react-dom&#39;;&lt;div&gt;  &lt;p&gt;This child is placed in the parent div.&lt;/p&gt;  &#123;createPortal(    &lt;p&gt;This child is placed in the document body.&lt;/p&gt;,    document.body  )&#125;&lt;/div&gt;;</code></pre><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>portal 只会改变 DOM 节点的物理位置，但是渲染成 portal 的 JSX 仍然是渲染 JSX 的 React 组件的子节点。</p><ul><li>子组件仍然可以访问父组件树提供的上下文</li><li>事件根据 React 树从子级冒泡到父级</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h3><ol><li>children:可以使用 React 渲染的：JSX 片段，&lt;&gt;&lt;&#x2F;&gt;,字符串，数字，或者一组这些元素</li><li>domNode:已经存在的 DOM 节点，在更新期间传不同的 DOM 节点会导致不断重建 portal 内容</li></ol><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回一个可以包含在 JSX 中或者可以从 React 组件返回的 React 节点</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>来自 portal 的事件是根据 React 树传播而不是 DOM 树。</li></ul><pre><code class="html">&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;div id=&quot;name&quot;&gt;111&lt;/div&gt;&lt;script&gt;  //点击Demo组件portal组件中的p时，点击事件不会冒泡到dom树的节点，这里不会执行  document.getElementById(&#39;name&#39;).onclick = function () &#123;    console.log(&#39;hello world&#39;);  &#125;;&lt;/script&gt;</code></pre><pre><code class="jsx">import &#123; createPortal &#125; from &#39;react-dom&#39;;const Demo = () =&gt; &#123;  return (    // 点击Demo组件portal组件中的p时，这里的onClick会执行，因为React组件树的事件冒泡    &lt;div style=&#123;&#123; border: '2px solid black' &#125;&#125; onClick=&#123;()=&gt;console.log(&quot;root div click&quot;)&#125;&gt;      &lt;p&gt;This child is placed in the parent div.&lt;/p&gt;      &#123;createPortal(        &lt;p onClick=&#123;() =&gt; console.log(&#39;portal click&#39;)&#125;&gt;          This child is placed in the name        &lt;/p&gt;,        document.getElementById(&#39;name&#39;) as Element      )&#125;    &lt;/div&gt;  );&#125;;</code></pre><ul><li>挂载节点必须是已经存在的节点，不可以是当前 JSX 片段中的 dom 节点</li></ul><pre><code class="jsx">// 正常展示const App1 = () =&gt; &#123;  const [popupContainer, setPopupContainer] = React.useState(null);  React.useEffect(() =&gt; &#123;    const popupDiv = document.getElementById(&#39;sister&#39;);    setPopupContainer(popupDiv);  &#125;, []);  return (    &lt;React.Fragment&gt;      &lt;div id=&quot;sister&quot;&gt;外部兄弟&lt;/div&gt;      &lt;div id=&quot;container&quot;&gt;        &lt;div id=&quot;inner&quot;&gt;内部兄弟&lt;/div&gt;        &#123;/* 正常展示1 */&#125;        &#123;!!popupContainer &amp;&amp; createPortal(&lt;p&gt;portal内容&lt;/p&gt;, popupContainer)&#125;        &#123;/* 正常展示2 */&#125;        &#123;document.getElementById(&#39;sister&#39;) &amp;&amp;          createPortal(&lt;p&gt;portal内容&lt;/p&gt;, document.getElementById(&#39;sister&#39;))&#125;        &#123;/* 报错:Target container is not a DOM element. */&#125;        &#123;createPortal(&lt;p&gt;portal内容&lt;/p&gt;, document.getElementById(&#39;sister&#39;))&#125;      &lt;/div&gt;    &lt;/React.Fragment&gt;  );&#125;;export default App1;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建-portal"><a href="#创建-portal" class="headerlink" title="创建 portal"></a>创建 portal</h3><pre><code class="jsx">import &#123; createPortal &#125; from &#39;react-dom&#39;;export default function MyComponent() &#123;  return (    &lt;div style=&#123;&#123; border: '2px solid black' &#125;&#125;&gt;      &lt;p&gt;This child is placed in the parent div.&lt;/p&gt;      &#123;createPortal(        &lt;p&gt;This child is placed in the document body.&lt;/p&gt;,        document.body      )&#125;    &lt;/div&gt;  );&#125;</code></pre><img src="/2023/04/25/react-de-createportal/portal1.jpg" class=""><h3 id="使用-portal-渲染对话框弹窗"><a href="#使用-portal-渲染对话框弹窗" class="headerlink" title="使用 portal 渲染对话框弹窗"></a>使用 portal 渲染对话框弹窗</h3><p>可以避免调用在对话框的组件使用了 overflow:hidden 或者其他样式的情况下，不能展示悬浮对话框</p><h3 id="在非-React-服务端页面标记渲染-React-组件"><a href="#在非-React-服务端页面标记渲染-React-组件" class="headerlink" title="在非 React 服务端页面标记渲染 React 组件"></a>在非 React 服务端页面标记渲染 React 组件</h3><p>React root 如果是非 React 构建的静态页面或者服务端渲染页面的一部分，就可以利用 portals 在静态区域创建交互区域，比如 sideBars</p><p>与多 React root 的区别：</p><ul><li>即使内部渲染成 DOM 的不同部分，portal 也可以将这个应用作为一个<font color="red">状态共享</font>的 React 树去对待</li></ul><p>完整代码见:<a href="https://stackblitz.com/edit/react-ts-cwfhhp?file=index.html,style.css">https://stackblitz.com/edit/react-ts-cwfhhp?file=index.html,style.css</a></p><h3 id="在非-React-的-DOM-节点渲染-React-组件"><a href="#在非-React-的-DOM-节点渲染-React-组件" class="headerlink" title="在非 React 的 DOM 节点渲染 React 组件"></a>在非 React 的 DOM 节点渲染 React 组件</h3><p>用 portal 管理 React 外部的 DOM 节点的内容。</p><pre><code class="jsx">const App = () =&gt; &#123;  // 1. 定义状态变量popupContainer存储要渲染的目标节点  const [popupContainer, setPopupContainer] = useState(null);  useEffect(() =&gt; &#123;    if (mapRef.current === null) &#123;      const map = createMapWidget(containerRef.current);      mapRef.current = map;      // 2. 当创建第三方组件时，存储组件返回的DOM 节点，这样你可以将内容渲染到这个DOM节点      const popupDiv = addPopupToMapWidget(map);      setPopupContainer(popupDiv);    &#125;  &#125;, []);  return (    &lt;div style=&#123;&#123; width: 250, height: 250 &#125;&#125; ref=&#123;containerRef&#125;&gt;      &#123;/* 一旦popupContainer变成可访问状态，    使用createPortal渲染React内容到popupContainer容器中 */&#125;      &#123;popupContainer !== null &amp;&amp;        createPortal(&lt;p&gt;Hello from React!&lt;/p&gt;, popupContainer)&#125;    &lt;/div&gt;  );&#125;;</code></pre><p>完整例子见：<a href="https://stackblitz.com/edit/react-ts-cwfhhp?file=App.tsx">https://stackblitz.com/edit/react-ts-cwfhhp?file=App.tsx</a></p><pre><code class="jsx">// 核心代码export default function App() &#123;  const containerRef = React.useRef(null);  const mapRef = React.useRef(null);  const [popupContainer, setPopupContainer] = React.useState(null);  React.useEffect(() =&gt; &#123;    if (mapRef.current === null) &#123;      const map = createMapWidget(containerRef.current);      mapRef.current = map;      const popupDiv = addPopupToMapWidget(map);      setPopupContainer(popupDiv);    &#125;  &#125;, []);  return (    &lt;div style=&#123;&#123; width: 250, height: 250 &#125;&#125; ref=&#123;containerRef&#125;&gt;      &#123;popupContainer !== null &amp;&amp;        createPortal(&lt;p&gt;Hello from React!&lt;/p&gt;, popupContainer)&#125;    &lt;/div&gt;  );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unit-test-with-react</title>
      <link href="/2023/04/18/fan-yi-unit-test-with-react/"/>
      <url>/2023/04/18/fan-yi-unit-test-with-react/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<br><a href="https://blog.openreplay.com/unit-testing-with-the-react-testing-library/">https://blog.openreplay.com/unit-testing-with-the-react-testing-library/</a></p><h1 id="使用-React-Testing-Library-进行单元测试"><a href="#使用-React-Testing-Library-进行单元测试" class="headerlink" title="使用 React Testing Library 进行单元测试"></a>使用 React Testing Library 进行单元测试</h1><p>单元测试是一种用来测试单独的代码片段的测试方法，比如 function 或者 class,通过这种测试方法来确保代码正常工作。当在 React 中执行单元测试时，我们将组件与应用其他部分隔离，对这个组件进行单独测试。单元测试目的是在开发进程早期就可以捕获 bug，避免问题出现在最终的生产环境中。它给我们带来了许多好处，这让单元测试在 web 开发进程中变成了必需品。下面是执行这个过程的一些原因：</p><ul><li><strong>早期 bug 检测</strong>: 单元测试可以帮助我们在开发过程早期识别出 bug，避免变得更复杂和不容易修复。</li><li><strong>增强对修改的信心</strong>:单元测试提供了一个简单的途径证明代码修改不会破坏已存在的功能。</li><li><strong>能够起到文档的作用</strong>: 单元测试作为代码文档的一种形式而存在，为我们对于代码如何工作提供了清晰的认识。</li><li><strong>使开发更快</strong>: 单元测试提供了在某段时间内只测试一小部分代码的方法。这让开发者在某一时间内只需要专注于那一段代码，也让debug更简单。</li><li><strong>持续集成</strong>: 单元测试可以包含在可持续集成系统中，这个系统可以自动进行测试并且当代码发生变化时提供反馈，以确保代码修改在部署之前总是被测试过的。</li></ul><p>开发人员知道如何在他们的应用中执行测试，这是再怎么强调也不过分的，因为测试可以识别任何和实际需求相反的差距，错误或者缺失的需求，从而确认应用为公众使用做好准备。借助下面这些例子，这篇文章旨在教会你如何在React应用中使用React Testing Library执行单元测试   </p><h2 id="React-Testing-Library"><a href="#React-Testing-Library" class="headerlink" title="React Testing Library"></a>React Testing Library</h2><p><a href="https://testing-library.com/docs/react-testing-library/intro/">React Testing Library</a> 是一个React库，为测试React组件提供直观和高效的API。它基于<a href="https://testing-library.com/docs/ecosystem-jest-dom/">DOM Testing Library</a>构建，并且提供了更加以用户为中心的测试React组件的方式。这个库提供了一系列工具函数，这些让写测试断言React组件的行为更加容易。RTL函数被设计成和React渲染的真实DOM元素一起使用而不是虚拟DOM，所以测试会模仿用户如何和应用交互。你可以在<a href="https://testing-library.com/docs/react-testing-library/intro/">这里</a>了解更多关于React testing library的知识。</p><h2 id="使用-React-testing-library在React中单元测试的构建块"><a href="#使用-React-testing-library在React中单元测试的构建块" class="headerlink" title="使用 React testing library在React中单元测试的构建块"></a>使用 React testing library在React中单元测试的构建块</h2><p>React中使用React testing library的单元测试如下所示：</p><pre><code class="javascript">import &#123; render, screen &#125; from &#39;@testing-library/react&#39;;import App from &#39;./App&#39;;test(&#39;renders learn react link&#39;, () =&gt; &#123;  render(&lt;App /&gt;);  const linkElement = screen.getByText(/learn react/i);  expect(linkElement).toBeInTheDocument();&#125;);</code></pre><ul><li>从上面的例子可以看出，首先看到的就是一些必要的模块必须被导入，比如render,screen和被测试的组件(App)。render方法返回一个对象，这个对象提供对渲染组件的访问，以及多个可以查询组件和与组件交互的工具函数</li><li>其次，测试块包含两部分；第一部分是描述测试的文本内容，第二部分是一个回调函数。</li><li>在测试块中，使用render方法渲染将要被测试的组件。</li><li>渲染完组件后，我们需要在待测试的组件中找到特定的元素。在一个渲染的组件中查找元素主要有三种方法：getBy, findBy和 queryBy。<ul><li><ul><li>getBy 方法被用来获取符合条件的单个元素。如果使用同一个属性找不到或者找到多个元素，会抛出错误。当测试一个元素是否在DOM上时这个方法非常有用，我们希望只有一个元素满足这个条件。比如：<br> This method is useful when testing if an element is present in the DOM and we expect only one element to match the condition. For example:</li></ul></li></ul></li></ul><pre><code class="javascript">const &#123; getByText &#125; = render(&lt;MyComponent /&gt;);const element = getByText(&#39;Hello World&#39;);</code></pre><p>在上述例子中，getByText会查询DOM找一个包含 ‘Hello World’文本内容 的元素，返回第一个符合条件的元素。如果没有一个元素包含‘Hello World’或者有多个元素包含它，就会抛出一个错误。</p><ul><li>findBy方法被用来获取满足条件的单个元素。如果没有找到则返回null,如果找到多个就抛出错误。当你不确定这个元素是否在DOM中或者你希望只有一个元素符合条件的时候这个方法非常有用，比如：</li></ul><pre><code class="javascript">const &#123; findByText &#125; = render(&lt;MyComponent /&gt;);const element = await findByText(&#39;Hello World&#39;);</code></pre><p>在上面这个例子中，findByText会查询DOM找一个包含 ‘Hello World’文本内容 的元素，返回第一个符合的元素或者如果元素未找到的话返回null。如果有多个则会抛出错误。</p><ul><li>queryBy被用来获取满足条件的所有元素。如果没有找到元素则返回null,否则以数组的形式返回。当你希望找到多个满足条件的元素时候，这个方法非常有用。例如：</li></ul><pre><code class="javascript">const &#123; queryByText &#125; = render(&lt;MyComponent /&gt;);const elements = queryByText(&#39;Hello World&#39;);</code></pre><p>在这个例子中，queryByText会查询DOM寻找包含文本 ‘Hello World’的所有元素，返回一组符合条件的元素，或者如果没有找到的话会返回null。这些方法都接受一个条件作为参数，这个条件可以是一个字符串（按元素文本搜索），组件，角色或者你需要查询的其他属性。你也可以串联多个条件来进行更精确的搜索。这里是一个例子：</p><pre><code class="javascript">const &#123; getByRole, getByLabelText &#125; = render(&lt;MyComponent /&gt;);const element = getByRole(&#39;button&#39;, &#123; name: &#39;Save&#39; &#125;).getByLabelText(&#39;Save&#39;);</code></pre><p>在这个例子中，getByRole将会查询DOM寻找角色为button，name是Save的元素。然后getByLabelText会遍历getByRole返回的所有元素；它将返回label文本为‘Save’的相同元素，如果没有找到元素或找到多个元素，就抛出错误。</p><ul><li>找到元素后，测试期间我们可以使用来自 @testing-library&#x2F;react 库的fireEvent 函数在React组件的元素上模拟用户事件（如：click,input等）。这里是一个使用fireEvent模拟点击按钮事件的例子：</li></ul><pre><code class="javascript">import &#123; render, fireEvent &#125; from &#39;@testing-library/react&#39;;import MyComponent from &#39;./MyComponent&#39;;test(&#39;clicking the button calls the onClick prop&#39;, () =&gt; &#123;  const onClick = jest.fn();  const &#123; getByText &#125; = render(&lt;MyComponent onClick=&#123;onClick&#125; /&gt;);  const button = getByText(&#39;Click me&#39;);  fireEvent.click(button);  expect(onClick).toHaveBeenCalled();&#125;);</code></pre><p>在这个例子中，我们从@testing-library&#x2F;react导入了render和fireEvent 功能，然后我们导入想要测试的组件。在测试函数中，我们创建了mock函数来作为组件的onClick属性使用。然后使用render函数来渲染组件，使用getByText 方法来找到包含文本”click me”的按钮元素。通过使用fireEvent.click函数，我们模拟了点击按钮，最终，预期检查mock的函数应该被调用。你可以使用fireEvent.change模拟input的change 事件，使用fireEvent.submit模拟表单的提交事件以及其他事件。</p><ul><li>随着找到元素和事件fire,我们随后检查他们行为是否与预期一致或者他们应该在哪里被找到。这个检查被称为断言，断言被用来测试在渲染的组件里某个条件是否满足。这些断言典型的用法是检查元素状态，文本或者属性以及组件行为。RTL提供了一系列内置的断言比如toHaveBeenCalled，toHaveBeenCalledTimes, 和 toHaveBeenCalledWith，断言函数行为比如事件处理器。举个例子：</li></ul><pre><code class="javascript">test(&#39;simulate and test click event on a button&#39;, () =&gt; &#123;  const handleClick = jest.fn();  const &#123; getByTestId &#125; = render(&lt;MyComponent onClick=&#123;handleClick&#125; /&gt;);  fireEvent.click(getByTestId(&#39;my-button&#39;));  expect(handleClick).toHaveBeenCalled();  expect(handleClick).toHaveBeenCalledTimes(1);  expect(handleClick).toHaveBeenCalledWith(expect.anything());&#125;);</code></pre><p>这个例子中，我们使用jest.fn() 创建一个我们可以断言的mock函数。然后我们将它作为prop传递给组件，接着使用fireEvent.click 模拟点击按钮。再断言。使用 toHaveBeenCalled()方法，检查当点击按钮时，函数handleClick是否被调用。 使用toHaveBeenCalledTimes(1)，我们测试当按钮点击的时候，handleClick是否只被调用过一次。最后，使用toHaveBeenCalledWith()测试他是否只被调用一次且带有参数的调用。</p><p>注意RTL目的是提供最小且灵活的一系列断言，并且你可以使用任何断言库，类似chai，jest等断言组件状态。</p><h2 id="使用-React-Testing-Library编写有效的单元测试的步骤"><a href="#使用-React-Testing-Library编写有效的单元测试的步骤" class="headerlink" title="使用 React- Testing Library编写有效的单元测试的步骤"></a>使用 React- Testing Library编写有效的单元测试的步骤</h2><p>这里是使用React Testing Library编写综合有效的单元测试需要遵循的步骤：</p><ul><li>导入需要的模块：你必须导入React和React Testing Library。你也需要导入你想测试的组件。</li><li>写测试：使用Jest的描述和他的方法来为组件写测试。你会使用React Testing Library的render方法来渲染测试中的组件。</li><li>从组件获取元素：使用来自返回的渲染对象getBy 和queryBy方法从已经渲染的组件中获取元素。你可以使用这些方法通过文本，展示值，label文本或者联合体获取元素。</li><li>和组件交互：使用fireEvent 方法和组件交互。你可以使用fireEven模拟类似点击按钮，提交表单或者修改输入值这样的用户事件。</li><li>做出断言：使用Jest的expect方法对组件的状态做出断言。举例来说，你可能会断言表单已经成功提交或者展示错误信息。</li><li>清理：在进入下一个测试之前，确保清理干净任意的spy,mock或者给组件添加的事件监听器。</li><li>为每个组件重复这个过程：为每一个你想测试的组件写一个单独的测试。为每个测试重复上述步骤。现在我们自己来写一些测试。</li></ul><h2 id="写单元测试"><a href="#写单元测试" class="headerlink" title="写单元测试"></a>写单元测试</h2><p>为了测试，我们还会创建简单的联系表单，校验每一个field。<br><img src="https://blog.openreplay.com/images/unit-testing-with-the-react-testing-library/images/UHSZlyc.png"><br>为了测试，我们将创建一个简单的表单，校验每一个field。如果空白表单被提交就会展示错误信息。<br><img src="https://blog.openreplay.com/images/unit-testing-with-the-react-testing-library/images/yHK5HIa.png"></p><p>做完这些之后，我们将为这个表单写一些单元测试：</p><ul><li>测试label和输入域是否正确渲染：</li></ul><pre><code class="javascript">it(&#39;renders the form with correct labels and inputs&#39;, () =&gt; &#123;  const &#123; getByLabelText, getByRole &#125; = render(&lt;App /&gt;);  expect(getByLabelText(&#39;Name:&#39;)).toBeInTheDocument();  expect(getByLabelText(&#39;Email:&#39;)).toBeInTheDocument();  expect(getByLabelText(&#39;Message:&#39;)).toBeInTheDocument();  expect(getByRole(&#39;textbox&#39;, &#123; name: &#39;Name:&#39; &#125;)).toBeInTheDocument();  expect(getByRole(&#39;textbox&#39;, &#123; name: &#39;Email:&#39; &#125;)).toBeInTheDocument();  expect(getByRole(&#39;textbox&#39;, &#123; name: &#39;Message:&#39; &#125;)).toBeInTheDocument();&#125;);</code></pre><p>这个测试用来检测表单的label和输入值是否正确。来自react-testing-library的render函数被用来渲染App组件。之后，getByLabelText和getByRole函数用来找表单里的元素，并断言他们在文档中。</p><ul><li>测试是否会展示空域的错误信息：</li></ul><pre><code class="javascript">it(&#39;displays errors for empty fields&#39;, () =&gt; &#123;  const &#123; getByText, getByRole &#125; = render(&lt;App /&gt;);  const submitButton = getByRole(&#39;button&#39;, &#123; type: &#39;submit&#39; &#125;);  fireEvent.click(submitButton);  expect(getByText(&#39;Name is required&#39;)).toBeInTheDocument();  expect(getByText(&#39;Email is required&#39;)).toBeInTheDocument();  expect(getByText(&#39;Message is required&#39;)).toBeInTheDocument();&#125;);</code></pre><p>这个测试检查当用户尝试提交空白表单的时候是否会展示正确的错误信息。我们的表单是使用render函数渲染的，使用getByRole方法找到按钮元素。fireEvent函数模拟点击提交按钮。getByText函数找到错误信息并且断言他们在文档里。</p><ul><li>测试在email地址不合法的情况下是否会展示错误信息:</li></ul><pre><code class="javascript">it(&#39;display error for invalid email&#39;, () =&gt; &#123;  const &#123; getByLabelText, getByText, getByRole &#125; = render(&lt;App /&gt;);  const emailInput = getByRole(&#39;textbox&#39;, &#123; name: &#39;Email:&#39; &#125;);  fireEvent.change(emailInput, &#123; target: &#123; value: &#39;wdwkfb.com@&#39; &#125; &#125;);  const submitButton = getByRole(&#39;button&#39;, &#123; type: &#39;submit&#39; &#125;);  fireEvent.click(submitButton);  expect(getByLabelText(&#39;Email:&#39;)).toBeInTheDocument();  expect(getByText(&#39;Email is not valid&#39;)).toBeInTheDocument();&#125;);</code></pre><p>这个测试检测包含不合法的邮件地址的表单是否会在用户尝试提交表单会展示错误信息。表单渲染以后，通过getByRole方法找到邮箱输入。fireEvent函数被用来模拟将邮件地址变成不合法的值。提交按钮找到以后像以前的测试一样使用同样的步骤点击。使用getByText方法找到错误信息并断言存在于文档中。</p><ul><li>当右边的输入被给定的时候，测试我们的表单是否被提交：</li></ul><pre><code class="javascript">it(&#39;submit the form with correct data when the submit button is clicked&#39;, () =&gt; &#123;  const spy = jest.spyOn(console, &#39;log&#39;).mockImplementation(() =&gt; &#123;&#125;);  const &#123; getByLabelText, getByText &#125; = render(&lt;App /&gt;);  const nameInput = getByLabelText(&#39;Name:&#39;);  const emailInput = getByLabelText(&#39;Email:&#39;);  const messageInput = getByLabelText(&#39;Message:&#39;);  const submitButton = getByText(&#39;Submit&#39;);  fireEvent.change(nameInput, &#123; target: &#123; value: &#39;John Doe&#39; &#125; &#125;);  fireEvent.change(emailInput, &#123; target: &#123; value: &#39;johndoe@example.com&#39; &#125; &#125;);  fireEvent.change(messageInput, &#123;    target: &#123; value: &#39;Hello, I would like to get in touch.&#39; &#125;,  &#125;);  fireEvent.click(submitButton);  expect(console.log).toHaveBeenCalledWith(&#123;    name: &#39;John Doe&#39;,    email: &#39;johndoe@example.com&#39;,    message: &#39;Hello, I would like to get in touch.&#39;,  &#125;);  spy.mockRestore();&#125;);</code></pre><p>这个例子中，我们使用Jest的spyOn方法创建对console.log方法的监听，然后使用 mockImplementation来用mock函数替代真正的方法。这允许我们验证 console.log 方法可以在不往控制台记录任何信息的情况下被调用。然后我们使用来自@testing-library&#x2F;react的render方法渲染App组件，使用getByText从已经渲染的组件中获取到按钮元素。使用fireEvent.change，我们可以给输入域提供输入。接下来使用fireEvent.click来模拟点击按钮，断言有预期消息的console.log方法被调用。最后使用mockRestore来恢复原始的console.log方法，所以spy不会影响任何未来的测试。</p><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>到目前为止，我们已经学习了如何为React应用搭建单元测试。为了运行我们已经写好的测试，需要做以下这些事：</p><ul><li><p>将你的测试文件保存在组件文件的同级目录，命名为[component-name].test.js。</p></li><li><p>在你的终端，导航到项目的根目录，运行下面的命令：npm run test，如果你使用的是yarn,可以运行yarn test</p></li><li><p>test runner会自动找到你项目里的所有测试文件并运行，在终端展示结果。</p></li><li><p>如果你想要运行指定的测试文件，可以使用 npm run test [test-file-path]或者yarn test [test-file-path]命令。</p></li><li><p>终端上展示了我们测试的结果，包含了所有的测试和他们的结果。这是当测试全部通过的时候的输出：</p><p><img src="https://blog.openreplay.com/images/unit-testing-with-the-react-testing-library/images/Z92HEh8.png"></p><p>现在我们让其中一个测试失败，看看是什么样子；</p><p><img src="https://blog.openreplay.com/images/unit-testing-with-the-react-testing-library/images/iYziRAC.png"><br>我们可以看到React Testing Library 向我们精确地展示了什么原因导致了错误，因此我们能够快速纠正错误。</p></li></ul><h2 id="写有效单元测试用例的一些建议"><a href="#写有效单元测试用例的一些建议" class="headerlink" title="写有效单元测试用例的一些建议"></a>写有效单元测试用例的一些建议</h2><ul><li><strong>保持测试内容小且集中</strong>: 每个测试应该只测试组件特定的行为或者方面，避免在单个test中测试多个行为。这可以提高你的测试包的可靠性，可读性和可维护性。这里是一个反面例子：</li></ul><pre><code class="javascript">import React from &#39;react&#39;;import MyComponent from &#39;./MyComponent&#39;;import &#123; render, fireEvent &#125; from &#39;@testing-library/react&#39;;describe(&#39;MyComponent&#39;, () =&gt; &#123;  it(&#39;tests multiple behaviors&#39;, () =&gt; &#123;    const &#123; getByText, getByRole &#125; = render(&lt;MyComponent title=&quot;Test title&quot; /&gt;);    expect(getByText(&#39;Test title&#39;)).toBeInTheDocument();    fireEvent.click(getByRole(&#39;button&#39;));    expect(getByText(&#39;Button clicked&#39;)).toBeInTheDocument();  &#125;);&#125;);</code></pre><p>这同时测试了标题的展示和按钮点击的行为，这使得它在失败的时候难以理解和debug。这里是同样的测试更好的写法：</p><pre><code class="javascript">import React from &#39;react&#39;;import MyComponent from &#39;./MyComponent&#39;;import &#123; render, fireEvent &#125; from &#39;@testing-library/react&#39;;describe(&#39;MyComponent&#39;, () =&gt; &#123;  it(&#39;renders the title&#39;, () =&gt; &#123;    const &#123; getByText &#125; = render(&lt;MyComponent title=&quot;Test title&quot; /&gt;);    expect(getByText(&#39;Test title&#39;)).toBeInTheDocument();  &#125;);  it(&#39;handles button click&#39;, () =&gt; &#123;    const &#123; getByText, getByRole &#125; = render(&lt;MyComponent title=&quot;Test title&quot; /&gt;);    fireEvent.click(getByRole(&#39;button&#39;));    expect(getByText(&#39;Button clicked&#39;)).toBeInTheDocument();  &#125;);&#125;);</code></pre><p>在这个例子中，我们使用来自@testing-library&#x2F;react的render方法渲染组件和来自jest的fireEvent.click模拟按钮点击事件。然后getByText 和 getByRole函数被用来在页面中定位元素。这些测试被写在单独的test块中，遵循建议的做法，这让他们即使随着时间的流逝也能易于理解和维护。</p><ul><li><strong>测试特定结果</strong>: 当我们专注于测试组件特定的结果或者某些方面的行为，而不是专注于渲染的整体正确性，单元测试会更高效。通过测试特定的结果，我们可以确保组件功能在一些特殊的场景下能按照预期运行。举例来说，你可以测试当传入指定prop的时候这个组件是否会正确展示指定的数据，或者也可以测试当点击指定的按钮时触发操作。这些类型的测试提供了关于组件的行为更特定的和更有意义的信息，这使得捕获可能发生的问题或者bug更加容易。</li><li><strong>同时测试符合预期和不符合预期的行为</strong>: 测试组件在给定合法输入的时候是否行为正常，同时测试它是否能处理不合法的输入和边缘用例。这里是一个例子；假设有这样一个React组件，有一个数字value作为prop,返回基于值的信息：</li></ul><pre><code class="javascript">import React from &quot;react&quot;;const ValueMessage = (&#123; value &#125;) =&gt; &#123;  let message = &quot;&quot;;  if (value &gt; 10) &#123;    message = &quot;Value is greater than 10&quot;;  &#125; else if (value &lt; 0) &#123;    message = &quot;Value is negative&quot;;  &#125; else &#123;    message = &quot;Value is between 0 and 10&quot;;  &#125;  return &lt;div&gt;&#123;message&#125;&lt;/div&gt;;&#125;;export default ValueMessage;</code></pre><p>为了给这个组件写有效的单元测试，我们应该同时测试符合预期和不符合预期的行为：测试符合预期的行为；</p><pre><code class="javascript">import React from &#39;react&#39;;import &#123; render &#125; from &#39;@testing-library/react&#39;;import ValueMessage from &#39;./ValueMessage&#39;;test(&#39;displays &quot;Value is greater than 10&quot; when value is greater than 10&#39;, () =&gt; &#123;  const value = 11;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;value&#125; /&gt;);  expect(getByText(&#39;Value is greater than 10&#39;)).toBeInTheDocument();&#125;);test(&#39;displays &quot;Value is between 0 and 10&quot; when value is between 0 and 10&#39;, () =&gt; &#123;  const value = 5;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;value&#125; /&gt;);  expect(getByText(&#39;Value is between 0 and 10&#39;)).toBeInTheDocument();&#125;);test(&#39;displays &quot;Value is negative&quot; when value is negative&#39;, () =&gt; &#123;  const value = -5;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;value&#125; /&gt;);  expect(getByText(&#39;Value is negative&#39;)).toBeInTheDocument();&#125;);</code></pre><p>现在来测试一些不符合预期的行为；</p><pre><code class="javascript">import React from &#39;react&#39;;import &#123; render &#125; from &#39;@testing-library/react&#39;;import ValueMessage from &#39;./ValueMessage&#39;;test(&#39;displays &quot;Value is between 0 and 10&quot; when value is undefined&#39;, () =&gt; &#123;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;undefined&#125; /&gt;);  expect(getByText(&#39;Value is between 0 and 10&#39;)).toBeInTheDocument();&#125;);test(&#39;displays &quot;Value is between 0 and 10&quot; when value is null&#39;, () =&gt; &#123;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;null&#125; /&gt;);  expect(getByText(&#39;Value is between 0 and 10&#39;)).toBeInTheDocument();&#125;);test(&#39;displays &quot;Value is between 0 and 10&quot; when value is NaN&#39;, () =&gt; &#123;  const &#123; getByText &#125; = render(&lt;ValueMessage value=&#123;NaN&#125; /&gt;);  expect(getByText(&#39;Value is between 0 and 10&#39;)).toBeInTheDocument();&#125;);</code></pre><p>在这个例子中，我们通过提供给组件合法的输入（大于10，1-10，负数的数字）测试符合预期的行为。我们也测试了不符合预期的行为，比如给组件的value的props提供undefined，null和NaN。边缘用例帮助确保组件可以优雅处理不合法输入，避免app崩溃。</p><ul><li><p><strong>使用合理的测试方式</strong>: React Testing Library 提供了不同的测试组件的方法，比如：render,fireEvent和wait。为你要测试的行为选择合理的方法。</p></li><li><p><strong>避免测试还没有实现的细节</strong>: 组件也许内部会变化，但是只要他们的行为不变，我们的测试仍然可以通过。避免测试内部的实现细节，而是专注于测试组件的公共API。举例来说,假设你有一个<Counter /> 组件,在屏幕上显示一个数字,允许用户增加或减少这个数字.这里是一个例子展示了你在<Counter />组件也许想要测试什么:</p></li></ul><pre><code class="javascript">it(&quot;renders the correct number&quot;, () =&gt; &#123;  const wrapper = shallow(&lt;Counter value=&#123;3&#125; /&gt;);  expect(wrapper.text()).toEqual(&quot;3&quot;);&#125;);it(&quot;increments the value correctly&quot;, () =&gt; &#123;  const wrapper = shallow(&lt;Counter value=&#123;3&#125; /&gt;);  wrapper.find(&quot;[data-test=&#39;increment-button&#39;]&quot;).simulate(&quot;click&quot;);  expect(wrapper.text()).toEqual(&quot;4&quot;);&#125;);it(&quot;decrements the value correctly&quot;, () =&gt; &#123;  const wrapper = shallow(&lt;Counter value=&#123;3&#125; /&gt;);  wrapper.find(&quot;[data-test=&#39;decrement-button&#39;]&quot;).simulate(&quot;click&quot;);  expect(wrapper.text()).toEqual(&quot;2&quot;);&#125;);</code></pre><p>在这个例子中,测试专注于<Counter />组件的行为。他们检测组件是否渲染了正确的数字，同时也检测用户是否可以增加或减少数字。即使组件的执行变了，只要行为不变，测试应该仍然会通过。避免测试内部实现细节非常重要，比如用于展示一个数字或者按钮的特定HTML元素。举例来说，组件也许会从使用<p> 元素展示数字变成使用自定义的<Display>组件展示。只要组件表现一致，测试应该仍然会通过；就不需要更新测试。</p><ul><li><strong>使用测试替身</strong>:<br>使用测试替身，比如mock,spy和stub来隔离他们的依赖和组件，让测试更快和更可靠。测试替身可以隔离组件和依赖，让测试更加快速和可靠。举例来说，假设你有<FetchData />组件，它从API获取数据并且在屏幕上展示。当测试<FetchData />组件的时候，你不想发送一个API的网络请求，因为这会减缓测试速度，并且没有那么可靠（比如，API会挂掉，响应在每次返回都不同）。取而代之的是，你可以使用测试替身来模拟API响应。这里演示了如何使用mock来测试<FetchData /> 组件：</li></ul><pre><code class="javascript">it(&quot;renders data correctly&quot;, () =&gt; &#123;  const apiResponse = [    &#123; id: 1, name: &quot;John&quot; &#125;,    &#123; id: 2, name: &quot;Jane&quot; &#125;,  ];  const mockFetchData = jest.fn().mockResolvedValue(apiResponse);  const wrapper = shallow(&lt;FetchData fetchData=&#123;mockFetchData&#125; /&gt;);  // 等待组件渲染  setTimeout(() =&gt; &#123;    expect(wrapper.text()).toContain(&quot;John&quot;);    expect(wrapper.text()).toContain(&quot;Jane&quot;);  &#125;, 0);&#125;);</code></pre><p>这个例子中， mockFetchData函数模仿API响应。mockFetchData函数作为prop传递给<FetchData />组件，所以会调用mockFetchData而不是真正的网络请求。这让测试更加快捷且可靠，因为测试不再依赖API。<br>你也可以使用spies和stubs来隔离组件和他们的依赖。举例来说，你也许会使用spy检测某个功能是否被调用或者使用stub用简单版本的对象代替真正的对象来测试。使用测试替身是把组件和依赖有效的隔离开来，让测试更加快捷和可靠。这是测试工具包中的一项珍贵的技术。</p><ul><li>保持测试用例最新:让测试用例跟随代码的最新修改而更新。这可以确保测试用例一直合法和有作用。</li><li>隔离测试： 尽可能隔离测试组件避免测试依赖项。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单元测试帮助我们确保组件正常工作以及对代码库做的修改不会破坏已有功能。这可以显著提高React应用的整体质量和可靠性。 除此之外，React testing library 也很容易使用。它能和其他测试框架很好的集成，这对任何一个期望在他们项目里实现单元测试的React开发者都是一个好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-whats-new-in-http3</title>
      <link href="/2023/04/16/fan-yi-whats-new-in-http3/"/>
      <url>/2023/04/16/fan-yi-whats-new-in-http3/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://medium.com/better-programming/whats-new-in-http-3-10c2455a4f8c">https://medium.com/better-programming/whats-new-in-http-3-10c2455a4f8c</a></p><h2 id="HTTP-x2F-3-中的新特性"><a href="#HTTP-x2F-3-中的新特性" class="headerlink" title="HTTP&#x2F;3 中的新特性?"></a>HTTP&#x2F;3 中的新特性?</h2><h3 id="漫游-HTTP-x2F-0-9-HTTP-x2F-1-0-HTTP-x2F-1-1-HTTP-x2F-2-and-HTTP-x2F-3"><a href="#漫游-HTTP-x2F-0-9-HTTP-x2F-1-0-HTTP-x2F-1-1-HTTP-x2F-2-and-HTTP-x2F-3" class="headerlink" title="漫游 HTTP&#x2F;0.9, HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2, and HTTP&#x2F;3"></a>漫游 HTTP&#x2F;0.9, HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2, and HTTP&#x2F;3</h3><blockquote><p>“超文本传输协议（HTTP）是应用层协议，用于分布式、协作式超媒体信息系统。它是一个通用的、无状态的协议，可以用于超文本以外的很多任务，比如：name server 和分布式对象管理系统。-<a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">W3</a></p></blockquote><p>HTTP 使浏览器和服务器能够通信。它构成了 web 服务器执行最基础的操作所必须有的基础。HTTP 经历了多个阶段。最新的草案 <a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">超文本传输协议版本 3</a> (HTTP&#x2F;3)在 2021 年 5 月 27 日发布。</p><p>接下来我们了解下 HTTP 的历史，并探索 HTTP&#x2F;3 中的新特性。</p><h2 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h2><p><a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Sir Timothy John Berners-Lee</a> , 也被称为 TimBL,是英国的计算机科学家，同时也是万维网的发明者。他在 1989 年创建了一行的 HTTP 协议 . 简单地返回了一个网页。这个协议在 1991 年被命名为 HTTP&#x2F;0.9。</p><p>它只是一个简单的<a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">单页规范</a>。只有一种方法：GET,后面跟着文档地址和可选端口地址，以回车(CR)和换行(LF)作为结束：</p><pre><code class="bash">    GET /aWebpage.html</code></pre><p>响应可能是被请求的 HTML 文件:</p><pre><code class="html">&lt;html&gt;  The Webpage content&lt;/html&gt;</code></pre><p>或者也有可能是一个错误页面:</p><pre><code class="html">&lt;html&gt;  Cannot get the page&lt;/html&gt;</code></pre><p>HTTP&#x2F;0.9 有 4 个术语：连接，断开连接，请求和响应。没有 HTTP 头，状态码、错误码，也没有 cookie 以及其他的现代特性。HTTP&#x2F;0.9 是基于 TCP——传输控制协议 构建的。connection 会在响应后立刻终止。</p><h2 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h2><p>1996 年 HTTP&#x2F;1.0 发布。<a href="https://datatracker.ietf.org/doc/html/rfc1945">规范</a>显著扩展，支持三种方法：GET, Head 和 POST。增加了术语： 消息, 资源, 实体, 客户端, 用户代理, 服务端, 源服务器, 代理, 网关, 隧道和 缓存。</p><p>下面是在 HTTP&#x2F;0.9 基础上 HTTP&#x2F;1.0 做出的改进：</p><ul><li>每个请求都附加 HTTP 版本。</li><li>状态码在响应的开头被发送。</li><li>请求和响应都包括 HTTP 头。</li><li>头部的元数据让协议更加灵活和易扩展。</li><li>头部的 content type 使得 http 有能力传输 HTML 文件以外的文档。</li></ul><p>但是，HTTP&#x2F;1.0 不是官方标准。</p><h2 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><p>HTTP 第一个标准化版本 HTTP&#x2F;1.1 (<a href="https://datatracker.ietf.org/doc/html/rfc2068">RFC 2068</a>)发布于 1997 年初，距离 HTTP&#x2F;1.0 只有几个月。 HTTP&#x2F;1.1 支持 7 种方法：OPTIONS, GET, HEAD, POST, PUT, DELETE 和 TRACE。2010 年<a href="https://datatracker.ietf.org/doc/html/rfc5789">RFC 5789</a>增加了 PATCH,2014 年<a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC 7231</a> 增加了 CONNECT。</p><p>HTTP&#x2F;1.1 附加的术语：representation, content negotiation, variant, cachable, first-hand, explicit expiration time, heuristic expiration time, age, freshness lifetime, fresh, stale, semantically transparent 和 validator.</p><p>HTTP&#x2F;1.1 是 HTTP 1.0 的增强版：</p><ul><li>虚拟主机允许多个从单个 ip 提供多个域。</li><li>持久化和流水线连接使得 web 浏览器可以通过单个的持久化连接发送多个请求。</li><li>缓存能够支持节省带宽，让响应更加快速。</li><li>分块传输编码可以在知道总长度之前就发送响应。这使得动态生成页面成为可能。</li><li>包括语言，编码或者类型在内多种方式的内容协商，使得客户端和服务端就要交换的最适合的内容达成一致。</li></ul><p>HTTP&#x2F;1.1 在接下来的 15 年左右非常稳定。在那期间，HTTPS（安全超文本传输协议）出现了。它是 HTTP 的安全版本，使用 SSL&#x2F;TLS 进行安全的加密通信。</p><p>2000 年以来，web API 的真实潜力被认可。Roy Fielding 带领一组专家发明了 REST：REpresentational State Transfer。 REST 是一种软件架构风格，定义了创建 web 服务时必须遵守的一系列的约束和标准。REST API 在 HTTP&#x2F;1.1 及以上生效。</p><h2 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p>HTTP&#x2F;2 旨在更高效的使用网络资源，减少对延迟的感知。它引入了新的二进制分帧，该层不能向后兼容 HTTP&#x2F;1.x 的服务端和客户端。</p><p>HTTP&#x2F;2 的第一个草案使用 SPDY 作为规范草案的工作基础。<a href="https://datatracker.ietf.org/doc/html/rfc7540">这个规范</a>于 2015 年发布。增加了术语： connection error, endpoint, frame, peer, receiver, sender, stream, stream error, intermediary, 和 payload body。</p><p>HTTP&#x2F;2 在流上构建了并行化、优先级和流量控制：</p><ul><li>stream 是在已建立的 TCP 连接中的双向字节流，可以携带一条或多条消息。</li><li>通信通过具有任意数量的双向流的单个TCP连接完成。</li><li>这是一个多路复用协议。可以让多个并行请求在同一个连接上处理。</li><li>它拥有优先排序一个资源而不是另一个资源的能力,因此可以把他放在响应行头部。</li><li>允许未经请求就将representation从服务端推送到客户端。</li><li>它使用了二进制协议而不是文本。这让它可以被机器读取,性能得到提高。同时也提高了总体上的安全性。</li><li>请求头和响应头都是被压缩的。</li><li>帧在流上传输,数据帧的载荷受到流控制。</li></ul><h2 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><p>由于 TCP 保证发送和接收数据包的顺序，因此丢失的数据包将停止所有流，即使它可能只影响其中一个流。HTTP&#x2F;2 没有强制加密，它容易受到流重用攻击以及压缩页面标题和 cookie 攻击。</p><p>HTTP&#x2F;3可以解决下面这些问题。</p><p>HTTP&#x2F;3是继HTTP&#x2F;1.1 和HTTP&#x2F;2后的第三大版本。目前，这仍然只是一个草案。<a href="https://quicwg.org/base-drafts/draft-ietf-quic-http.html">最新规范</a>在2021年5月27日发布。它增加了术语：abort,HTTP&#x2F;3 connection和content。</p><p>HTTP&#x2F;3 是一种新的、快速的、可靠的、安全的协议，适用于所有形式的设备。</p><ul><li>HTTP&#x2F;3采用了新的协议——QUIC而不是TCP，这款协议由谷歌在2013年开发。QUIC基于UDP——用户数据报协议运行，</li><li>QUIC提供本地的多路服用，丢的包只会影响数据已经丢失的流。这解决了HTTP&#x2F;2中的线端阻塞问题。</li><li>QUIC为流数据和在流上发送的 HTTP&#x2F;3帧类型提供流控制。因此所有帧的header和payload都受流控制的约束。</li><li>请求头和响应头都是通过QPACK压缩而不是通过HTTP&#x2F;2的HPACK。</li><li>多个HTTP&#x2F;3帧用于管理服务器推送。</li><li>HTTP&#x2F;3包括了 TLS 1.3 加密。事实上，它担任了HTTPS的角色。</li></ul><h2 id="HTTP-x2F-3-支持度"><a href="#HTTP-x2F-3-支持度" class="headerlink" title="HTTP&#x2F;3 支持度"></a>HTTP&#x2F;3 支持度</h2><p>HTTP&#x2F;3 brings revolutionary changes to improve web performance and security. Setting up an HTTP&#x2F;3 website requires both server and browser support.<br>HTTP&#x2F;3为提升web性能和安全带来了革命性变革。建立HTTP&#x2F;3 网站需要服务器和浏览器同时支持。</p><h3 id="服务器支持"><a href="#服务器支持" class="headerlink" title="服务器支持"></a>服务器支持</h3><p>目前，<a href="https://cloud.google.com/">Google Cloud</a>, <a href="https://www.cloudflare.com/">Cloudflare</a> 和<a href="https://www.fastly.com/">Fastly</a>支持 HTTP&#x2F;3。</p><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Chrome, Firefox, Edge, Opera和部分移动端浏览器支持HTTP&#x2F;3。我们可以去<a href="https://caniuse.com/?search=http3">https://caniuse.com/?search=http3</a> 检查更新后的浏览器的支持度。绿色单元格列出了支持的浏览器版本。</p><p><img src="https://cdn-images-1.medium.com/max/2896/1*3m1FjB_lXyS2y1kBiZ8sEg.png" alt="HTTP/3 browser support table by [Can I use...](https://caniuse.com/?search=http3)"></p><p>在Chrome中，HTTP&#x2F;3 可以作为一个试验性协议被启用。当我们在浏览器url输入chrome:&#x2F;&#x2F;flags的时候，可以看见QUIC 默认是启用的。<br><img src="https://cdn-images-1.medium.com/max/2000/1*KsBjkghHX0kQdeAEtjx-ow.png"></p><h2 id="协议检查"><a href="#协议检查" class="headerlink" title="协议检查"></a>协议检查</h2><p>请求&#x2F;响应的协议可以通过NetWork标签页检查。打开谷歌开发者工具，选中Network标签。当右键点击表头的时候，协议列可以被选中而展示该列。</p><p><img src="https://cdn-images-1.medium.com/max/2274/1*Km5elHxixk9Y5jhaFkRQbg.png"></p><p>根据<a href="https://w3techs.com/technologies/overview/site_element%EF%BC%8C%E6%88%AA%E6%AD%A2%E5%88%B02021">https://w3techs.com/technologies/overview/site_element，截止到2021</a> 年 7 月，45.7% 的网站使用 HTTP&#x2F;2，20% 的网站使用 HTTP&#x2F;3。<br><img src="https://cdn-images-1.medium.com/max/2000/1*LvJFI64o1rI44tVyfNoffg.png" alt="An image generated by [W3Techs](https://w3techs.com/technologies/overview/site_element)"></p><h3 id="HTTP-x2F-1-1-案例"><a href="#HTTP-x2F-1-1-案例" class="headerlink" title="HTTP&#x2F;1.1 案例"></a>HTTP&#x2F;1.1 案例</h3><p>目前没有太多的公开网站仍然还在使用HTTP&#x2F;1.1协议。AT&amp;T的登录页属于其中之一。<br><img src="https://cdn-images-1.medium.com/max/2846/1*iJBck-4B0YoEgQigzxy8nQ.png" alt="AT&amp;T 登陆页"></p><h3 id="HTTP-x2F-2-案例"><a href="#HTTP-x2F-2-案例" class="headerlink" title="HTTP&#x2F;2 案例"></a>HTTP&#x2F;2 案例</h3><p>大部分公开网站都运行在HTTP&#x2F;2,AT&amp;T官网也是如此：<br><img src="https://cdn-images-1.medium.com/max/2846/1*oQ162JFnETIOGmkc3NpghQ.png" alt="AT&amp;T官网"></p><h3 id="HTTP-x2F-3-案例"><a href="#HTTP-x2F-3-案例" class="headerlink" title="HTTP&#x2F;3 案例"></a>HTTP&#x2F;3 案例</h3><p>HTTP&#x2F;3的YouTube页面。</p><p><img src="https://cdn-images-1.medium.com/max/2846/1*QgDSM-J_oDAyKwfKtTXQKw.png" alt="Youtube官方页面"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们了解了HTTP&#x2F;0.9, HTTP&#x2F;1.0, HTTP&#x2F;1.1, HTTP&#x2F;2, 和 HTTP&#x2F;3. HTTP&#x2F;3 使用QUIC，它基于UDP运行。这是一种新的，快速可靠的跨设备安全协议。<br>你正在考虑把你的应用迁移到HTTP&#x2F;3服务器上？或者已经更新浏览器通过HTTP&#x2F;3来查看web应用?</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cobra学习笔记</title>
      <link href="/2023/04/03/cobra-xue-xi-bi-ji/"/>
      <url>/2023/04/03/cobra-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>cobra本质：Go的CLI（命令行界面）框架<br>cobra作用：</p><ul><li>包含创建现代化CLI应用的库</li><li>包含一个用于快速生成基于Cobra的应用和命令文件的工具</li></ul><h2 id="安装和导入"><a href="#安装和导入" class="headerlink" title="安装和导入"></a>安装和导入</h2><pre><code class="bash">go get -u github.com/spf13/cobra@latestimport &quot;github.com/spf13/cobra&quot;</code></pre><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><ul><li>命令，表示一个行为或者动作，比如<code>serve</code>,<code>add</code>,<code>version</code></li><li>一个命令可以有多个子命令</li></ul><h3 id="Arg"><a href="#Arg" class="headerlink" title="Arg"></a>Arg</h3><ul><li>参数，代表某个对象或事物</li><li>通常位于命令之后，比如<code>serve web</code> 中的 <code>web</code></li></ul><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><ul><li>标记，用于修饰或者配置命令的行为，以<code>--</code>或者<code>-</code>开头</li><li>比如 <code>--port</code>或者<code>-p</code></li></ul><h2 id="遵循的模式："><a href="#遵循的模式：" class="headerlink" title="遵循的模式："></a>遵循的模式：</h2><ol><li><code>APPNAME VERB NOUN --ADJECTIVE</code><br>git(APPNAME) add(VERB) file(NOUN)</li><li><code>APPNAME COMMAND ARG --FLAG</code><br>git(APPNAME) commit(COMMAND) docs&#x2F;README.md(ARG) -m(FLAG)</li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><code>hugo serve -p 8080 --baseURL https://example.com </code></p><ul><li>command: serve,表示启动hugo的服务器</li><li>flag：<code>-p</code>,<code>--baseUrl</code>,用于设置端口和baseUrl</li><li>arg：无</li></ul><p><code>git add . </code></p><ul><li>command: add,表示git添加文件</li><li>flag：无</li><li>arg：<code>.</code>，代表当前目录<br><code>git commit -m &quot;Update README&quot;</code></li><li>command: commit,表示git提交文件</li><li>flag：<code>-m</code>,设置提交信息</li><li>arg：无</li></ul><h3 id="flag和arg的区别"><a href="#flag和arg的区别" class="headerlink" title="flag和arg的区别"></a>flag和arg的区别</h3><ol><li>arg代表 必选参数，flag代表可选参数</li><li>arg如果缺少则command会报错，flag缺少不会报错，而是会使用默认值</li></ol><h2 id="Command-1"><a href="#Command-1" class="headerlink" title="Command"></a>Command</h2><p>类型定义</p><pre><code class="go">type Command struct&#123;    Use string    Aliases []string    SuggestFor []string    Short string    GroupID string    Example  string    ValidArgs []string    ValidArgsFunction func(cmd *Command, args []string, toComplete string) ([]string, ShellCompDirective)    Args PositionalArgs    ArgAliases []string    BashCompletionFunction string    Deprecated string    Annotations map[string]string    Version string    PersistentPreRun func(cmd *Command, args []string)    PersistentPreRunE func(cmd *Command, args []string) error    PreRun func(cmd *Command, args []string)    PreRunE func(cmd *Command, args []string) error    Run func(cmd *Command, args []string)    RunE func(cmd *Command, args []string) error    PostRun func(cmd *Command, args []string)    PostRunE func(cmd *Command, args []string) error    PersistentPostRun func(cmd *Command, args []string)    PersistentPostRunE func(cmd *Command, args []string) error    FParseErrWhitelist FParseErrWhitelist    CompletionOptions CompletionOptions    TraverseChildren bool    Hidden bool    SilenceErrors bool    SilenceUsage bool    DisableFlagParsing bool    DisableAutoGenTag bool    DisableFlagsInUseLine bool    DisableSuggestions bool    SuggestionsMinimumDistance int&#125;</code></pre><h3 id="Hidden"><a href="#Hidden" class="headerlink" title="Hidden"></a>Hidden</h3><p>定义该命令不应该出现在可获得命令列表中的</p><h3 id="TraverseChildren"><a href="#TraverseChildren" class="headerlink" title="TraverseChildren"></a>TraverseChildren</h3><p>定义当用户输入该命令的路径时,是否遍历其子命令。</p><h3 id="CompletionOptions"><a href="#CompletionOptions" class="headerlink" title="CompletionOptions"></a>CompletionOptions</h3><p>定义自动补全选项</p><pre><code class="go">var cmd = &amp;cobra.Command&#123;  CompletionOptions: cobra.CompletionOptions&#123;    Flags: []string&#123;&quot;flag1&quot;, &quot;flag2&quot;&#125;,    Commands: []string&#123;&quot;subcmd1&quot;, &quot;subcmd2&quot;&#125;,    GlobalFlags: true,  &#125;,&#125;</code></pre><h3 id="FParseErrWhitelist"><a href="#FParseErrWhitelist" class="headerlink" title="FParseErrWhitelist"></a>FParseErrWhitelist</h3><p>定义该命令在标志解析阶段忽略的错误。<br>原本：当我们在命令行中输入与命令标志不匹配的内容时,Cobra 会返回一个 flag parse error</p><pre><code class="bash">Error: unknown flag: --ghUsage:  add [action] [options] [target] [flags]Flags:  -h, --help   help for add</code></pre><h3 id="Run相关函数"><a href="#Run相关函数" class="headerlink" title="Run相关函数"></a>Run相关函数</h3><blockquote><p>执行顺序：<br>PersistentPreRun()<br>PreRun()<br>Run()<br>PostRun()<br>PersistentPostRun()<br><strong>Run和RunE的区别是后者会返回error</strong></p></blockquote><h4 id="PersistentPostRun"><a href="#PersistentPostRun" class="headerlink" title="PersistentPostRun"></a>PersistentPostRun</h4><p>会在每次运行Run命令后被调用，会被子命令继承</p><h4 id="PostRun"><a href="#PostRun" class="headerlink" title="PostRun"></a>PostRun</h4><p>在Run之后调用，主要用于收尾工作</p><ul><li>清理临时文件</li><li>断开数据库连接</li><li>停止日志记录</li></ul><h4 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h4><p>通常是实际功能函数，命令的核心功能</p><ul><li>访问命令的标志、参数等</li><li>执行命令的主要业务逻辑</li><li>调用外部服务</li><li>修改系统状态</li><li>返回结果给用户</li><li>如果没有定义Run,本质上就是一个空命令</li></ul><h4 id="PreRun"><a href="#PreRun" class="headerlink" title="PreRun"></a>PreRun</h4><p>会在每次运行该命令前被调用，不会被子命令继承</p><h4 id="PersistentPreRun"><a href="#PersistentPreRun" class="headerlink" title="PersistentPreRun"></a>PersistentPreRun</h4><p>会在每次运行该命令前被调用，会被子命令继承</p><ol><li>验证全局标志或环境变量</li><li>启动日志记录</li><li>连接数据库等</li></ol><h4 id="PersistentPreRunE"><a href="#PersistentPreRunE" class="headerlink" title="PersistentPreRunE"></a>PersistentPreRunE</h4><h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h3><p>用于为该命令添加注解，可以用<code>cmd.Annotations</code>访问，主要用于在应用逻辑中传递和共享上下文信息,对最终用户不可见。</p><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>为命令定义版本，如果命令中定义了该字段且命令还没有定义 <code>version</code>标志，则cobra会自动给命令添加 –version和-v 标志，前提是这两者都没有定义。<br>执行<code>cmd --version</code>会输出Version中定义的值</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p>如果该命令已经被废弃，当使用的时候应该打印这个字符串</p><h3 id="BashCompletionFunction"><a href="#BashCompletionFunction" class="headerlink" title="BashCompletionFunction"></a>BashCompletionFunction</h3><p>值是我们的 Bash 自动补全函数的函数名,例如:</p><pre><code class="go">govar cmd = &amp;cobra.Command&#123;  BashCompletionFunction: &quot;autocompleteDo&quot;,&#125;// 同名函数实现func autocompleteDo(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) &#123;  // ...&#125;</code></pre><h3 id="ArgAliases"><a href="#ArgAliases" class="headerlink" title="ArgAliases"></a>ArgAliases</h3><p>ValidArgs别名列表，不会提示给用户，但是手动输入也会接收</p><h3 id="Args"><a href="#Args" class="headerlink" title="Args"></a>Args</h3><p>作用：指定它接收的位置参数模式,在内部可以：</p><ol><li>定义当前命令接收的位置参数</li><li>校验用户输入的参数是否正确</li><li>返回一个 nil 的 error 表示校验成功,或返回非 nil 的 error 表示校验失败<br>取值类型：<code>PositionalArgs</code></li></ol><pre><code class="go">type PositionalArgs func(*Command, []string) error</code></pre><h3 id="ValidArgsFunction"><a href="#ValidArgsFunction" class="headerlink" title="ValidArgsFunction"></a>ValidArgsFunction</h3><p>动态的ValidArgs，一个命令中不能同时存在<code>ValidArgsFunction</code>和<code>ValidArgs</code>选项</p><ul><li>第三个参数<code>toCoplete</code>用于实现命令补全<ul><li>cobra.ShellCompDirectiveDefault:继续使用默认的补全方案</li><li>cobra.ShellCompDirectiveError：阻止补全并返回错误</li><li>cobra.ShellCompDirectiveNoFileComp：仅提供文件名补全而非命令补全</li></ul></li></ul><pre><code class="go">ValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) &#123;    // 检查 toComplete 是否以 &quot;enabl&quot; 开头,如果是则返回可能的补全选项 [&quot;enable&quot;, &quot;enables&quot;, &quot;enabling&quot;]  if toComplete == &quot;enabl&quot; &#123;    return []string&#123;&quot;enable&quot;, &quot;enables&quot;, &quot;enabling&quot;&#125;, cobra.ShellCompDirectiveNoFileComp   &#125;    if args[0] != &quot;enable&quot; &#123;    // 阻止补全并返回错误    return nil, cobra.ShellCompDirectiveError  &#125;    return nil, cobra.ShellCompDirectiveDefault&#125; </code></pre><h3 id="ValidArgs"><a href="#ValidArgs" class="headerlink" title="ValidArgs"></a>ValidArgs</h3><p>作用：定义命令接收的所有合法的非flag参数，cobra会根据这个验证用户在shell命令中输入的参数是否有效，并在help输出中生成参数列表信息<br>疑问：为什么定义了ValidArgs，运行.&#x2F;demo add不会报错？<br>原因：cobra的解析流程导致的</p><ol><li>解析命令链,识别出各个命令和参数</li><li>对每个命令及其参数,检查是否符合 ValidArgs 中的要求</li><li>如果不符合,则视为普通参数传入,并继续后续检查</li><li>检查是否定义了该参数的子命令</li><li>如果没有子命令,则将该参数传入 Run 方法</li><li>在 Run 方法中,需要我们自行判断该参数是否有效,如果无效需要手动报错</li></ol><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>作用：示范如何使用命令<br>区别：Use定义规范，Example展示用例</p><h3 id="GroupID"><a href="#GroupID" class="headerlink" title="GroupID"></a>GroupID</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于将命令分组，具有相同 GroupID 的命令会被放入同一个命令组中。</p><ol><li>实际使用中不会影响命令的实际行为</li><li>优化help输出和自动补全功能</li></ol><h3 id="Use"><a href="#Use" class="headerlink" title="Use"></a>Use</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>定义命令的使用说明,使用户快速理解每个命令及其子命令的用法</li><li>在使用<code>--help</code>时显示,提供命令的帮助信息</li><li>提供一种检验命令设计的手段</li></ol><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>Use:   &quot;add [-F file | -D dir]... [-f format] profile&quot;</code><br>命令行使用:<code>./cobraDemo add xxx</code></p><ol><li><code>[]</code>表示这个是可选参数,其他的参数是必须参数</li><li><code>...</code>表示可以为前面的参数指定多个值,比如<code>Use: &quot;app STR... NUM...&quot;</code>,使用<code>app hello world 2 3</code> 。一个键(key)可以有多个值(value)</li><li><code>|</code>表示互斥,在一个命令里不能同时使用两边的参数</li><li><code>&#123;&#125;</code>表示分隔一组互斥参数,比如<code>add &#123;arg1|arg2|arg3&#125; &#123;arg4|arg5|arg6&#125;</code></li></ol><blockquote><ul><li>如果go build生成的二进制文件名demo和 rootCmd 的 Use 字段第一个单词相同,那么 .&#x2F;demo 会直接被 Cobra 识别为 rootCmd 命令,而不是普通参数。</li><li>如果不同，则.&#x2F;demo相当于普通参数传入，需要在Run方法中自行解析</li></ul></blockquote><h3 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ol><li>表示命令或参数的别名</li><li><code> Aliases: []string&#123;&quot;param1&quot;, &quot;p1&quot;,&quot;param2&quot;,&quot;p2&quot;&#125;</code>-param1的别名是p1,param2的别名是p2</li></ol><h3 id="SuggestFor"><a href="#SuggestFor" class="headerlink" title="SuggestFor"></a>SuggestFor</h3><p>作用：用于为用户输入的错误参数提供建议<br>案例：</p><pre><code class="go">var rootCmd = &amp;cobra.Command&#123;    Use:        &quot;app start|stop&quot;,      Args:       cobra.ExactArgs(1),     ValidArgs:  []string&#123;&quot;start&quot;, &quot;stop&quot;&#125;,    SuggestFor: []string&#123;&quot;run&quot;&#125;, // 对 &quot;run&quot; 提供建议&#125;</code></pre><p>此时用户输入<code>app run</code>，错误提示会变为：</p><ul><li>不设置SuggstFor<blockquote><p>Error: invalid argument “run” for “app”<br>Usage: app start|stop</p></blockquote></li><li>设置SuggstFor</li></ul><pre><code class="go">SuggestFor: []string&#123;&quot;run&quot;&#125;, // 对 &quot;run&quot; 提供建议</code></pre><blockquote><p>Error: invalid argument “run” for “app”<br>Did you mean “start” or “stop”?<br>Usage: app start|stop</p></blockquote><h3 id="Short"><a href="#Short" class="headerlink" title="Short"></a>Short</h3><p>定义命令或字段的简短描述，在<code>help</code>里展示的简短描述</p><h4 id="显示条件"><a href="#显示条件" class="headerlink" title="显示条件"></a>显示条件</h4><ol><li>实际定义了该字段</li><li>没有定义Long字段<br>如果同时定义了，则只会展示Long字段</li></ol><h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><p>作用：定义命令或字段的 详细描述</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin-web笔记</title>
      <link href="/2023/03/23/gin-web-bi-ji/"/>
      <url>/2023/03/23/gin-web-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">go get -u github.com/gin-gonic/gin</code></pre><p>Gin 默认使用<code>encoding/json</code>进行编译</p><h2 id="快捷方式："><a href="#快捷方式：" class="headerlink" title="快捷方式："></a>快捷方式：</h2><ul><li>gin.H 是 map[string]interface{}的快捷方式</li><li>gin.Accounts 是 map[string]string 的一种快捷方式</li></ul><h2 id="AsciiJSON"><a href="#AsciiJSON" class="headerlink" title="AsciiJSON"></a>AsciiJSON</h2><p>使用 AsciiJSON 生成具有转义的非 ASCII 字符的 ASCII-only JSON。<br>原数据：</p><pre><code class="go">data := map[string]interface&#123;&#125;&#123;  &quot;lang&quot;: &quot;GO语言&quot;,  &quot;tag&quot;:  &quot;&lt;br&gt;&quot;,&#125;// 输出data:&#123;&quot;lang&quot;:&quot;GO\u8bed\u8a00&quot;,&quot;tag&quot;:&quot;\u003cbr\u003e&quot;&#125;c.AsciiJSON(http.StatusOK, data)</code></pre><h2 id="html-渲染"><a href="#html-渲染" class="headerlink" title="html 渲染"></a>html 渲染</h2><p>使用<code>LoadHTMLGlob()</code>或者<code>LoadHTMLFiles()</code></p><pre><code class="tmpl">&lt;!-- templates/index.tmpl --&gt;&lt;html&gt;    &lt;h1&gt;        &#123;&#123; .title &#125;&#125;    &lt;/h1&gt;&lt;/html&gt;&lt;!-- templates/posts/index.tmpl --&gt;&#123;&#123; define "posts/index.tmpl" &#125;&#125;&lt;html&gt;&lt;h1&gt;    &#123;&#123; .title &#125;&#125;&lt;/h1&gt;&lt;p&gt;Using posts/index.tmpl&lt;/p&gt;&lt;/html&gt;&#123;&#123; end &#125;&#125;&lt;!-- templates/users/index.tmpl --&gt;&#123;&#123; define "users/index.tmpl" &#125;&#125;&lt;html&gt;&lt;h1&gt;    &#123;&#123; .title &#125;&#125;&lt;/h1&gt;&lt;p&gt;Using users/index.tmpl&lt;/p&gt;&lt;/html&gt;&#123;&#123; end &#125;&#125;</code></pre><p>如何使用模板：</p><pre><code class="go">    router.LoadHTMLGlob(&quot;templates/**/*&quot;)  //router.LoadHTMLFiles(&quot;templates/template1.html&quot;, &quot;templates/template2.html&quot;)  // 使用不同目录下的相同名称的模板    router.GET(&quot;/posts/index&quot;, func(c *gin.Context) &#123;        c.HTML(http.StatusOK, &quot;posts/index.tmpl&quot;, gin.H&#123;            &quot;title&quot;: &quot;Posts&quot;,        &#125;)    &#125;)    router.GET(&quot;/users/index&quot;, func(c *gin.Context) &#123;        c.HTML(http.StatusOK, &quot;users/index.tmpl&quot;, gin.H&#123;            &quot;title&quot;: &quot;Users&quot;,        &#125;)    &#125;)</code></pre><h3 id="自定义-html-模板"><a href="#自定义-html-模板" class="headerlink" title="自定义 html 模板"></a>自定义 html 模板</h3><p>暂忽略</p><h2 id="HTTP2-server-服务器-推送"><a href="#HTTP2-server-服务器-推送" class="headerlink" title="HTTP2 server 服务器 推送"></a>HTTP2 server 服务器 推送</h2><p>服务器推送：还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。比如，浏览器只请求了 index.html，但是服务器把 index.html、style.css、example.png 全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能</p><pre><code class="go">var html = template.Must(template.New(&quot;https&quot;).Parse(`&lt;html&gt;&lt;head&gt;  &lt;title&gt;Https Test&lt;/title&gt;  &lt;script src=&quot;/assets/app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 style=&quot;color:red;&quot;&gt;Welcome, Ginner!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;`))r.GET(&quot;/&quot;, func(c *gin.Context) &#123;  if pusher := c.Writer.Pusher(); pusher != nil &#123;    // 使用 pusher.Push() 做服务器推送    if err := pusher.Push(&quot;/assets/app.js&quot;, nil); err != nil &#123;      log.Printf(&quot;Failed to push: %v&quot;, err)    &#125;  &#125;  c.HTML(200, &quot;https&quot;, gin.H&#123;    &quot;status&quot;: &quot;success&quot;,  &#125;)&#125;)</code></pre><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>用来解决跨域问题:如果查询参数存在回调，则将回调添加到响应体中</p><pre><code class="go">data := map[string]interface&#123;&#125;&#123;  &quot;foo&quot;: &quot;bar&quot;,&#125;// 请求：/JSONP?callback=x// 输出data:x(&#123;\&quot;foo\&quot;:\&quot;bar\&quot;&#125;)c.JSONP(http.StatusOK, data)</code></pre><h2 id="Multipart-x2F-Urlencoded-绑定"><a href="#Multipart-x2F-Urlencoded-绑定" class="headerlink" title="Multipart&#x2F;Urlencoded 绑定"></a>Multipart&#x2F;Urlencoded 绑定</h2><pre><code class="go">type LoginForm struct &#123;    User     string `form:&quot;user&quot; binding:&quot;required&quot;`    Password string `form:&quot;password&quot; binding:&quot;required&quot;`&#125;// 显式绑定声明绑定multipart form：c.ShouldBindWith(&amp;form, binding.Form)// 使用ShouldBind 方法自动绑定var form LoginFormif c.ShouldBind(&amp;form) == nil &#123;  if form.User == &quot;user&quot; &amp;&amp; form.Password == &quot;password&quot; &#123;    c.JSON(200, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)  &#125; else &#123;    c.JSON(401, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)  &#125;&#125;// curl测试// curl -v --form user=user --form password=password http://localhost:8080/login</code></pre><h2 id="Multipart-x2F-Urlencoded-表单"><a href="#Multipart-x2F-Urlencoded-表单" class="headerlink" title="Multipart&#x2F;Urlencoded 表单"></a>Multipart&#x2F;Urlencoded 表单</h2><pre><code class="go">    router.POST(&quot;/form_post&quot;, func(c *gin.Context) &#123;        message := c.PostForm(&quot;message&quot;)        nick := c.DefaultPostForm(&quot;nick&quot;, &quot;anonymous&quot;)        c.JSON(200, gin.H&#123;            &quot;status&quot;:  &quot;posted&quot;,            &quot;message&quot;: message,            &quot;nick&quot;:    nick,        &#125;)    &#125;)</code></pre><h2 id="对特殊-HTML-字符进行编码——PureJSON"><a href="#对特殊-HTML-字符进行编码——PureJSON" class="headerlink" title="对特殊 HTML 字符进行编码——PureJSON"></a>对特殊 HTML 字符进行编码——PureJSON</h2><p>JSON 使用 unicode 替换特殊 HTML 字符，例如 &lt; 变为 \ u003c。如果要按字面对这些字符进行编码，则可以使用 PureJSON</p><pre><code class="go">// 提供 unicode 实体r.GET(&quot;/json&quot;, func(c *gin.Context) &#123;  c.JSON(200, gin.H&#123;    &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;,  &#125;)&#125;)// 提供字面字符r.GET(&quot;/pureJson&quot;, func(c *gin.Context) &#123;  c.PureJSON(200, gin.H&#123;    &quot;html&quot;: &quot;&lt;b&gt;Hello, world!&lt;/b&gt;&quot;,  &#125;)&#125;)</code></pre><h2 id="Query-和-post-form"><a href="#Query-和-post-form" class="headerlink" title="Query 和 post form"></a>Query 和 post form</h2><p>请求如下：</p><blockquote><p>POST &#x2F;post?id&#x3D;1234&amp;page&#x3D;1 HTTP&#x2F;1.1<br>Content-Type: application&#x2F;x-www-form-urlencoded<br>name&#x3D;mau&amp;message&#x3D;this_is_great</p></blockquote><pre><code class="go">id := c.Query(&quot;id&quot;)page := c.DefaultQuery(&quot;page&quot;, &quot;0&quot;)name := c.PostForm(&quot;name&quot;)message := c.PostForm(&quot;message&quot;)fmt.Printf(&quot;id: %s; page: %s; name: %s; message: %s&quot;, id, page, name, message)// 结果：id: 1234; page: 1; name: mau; message: this_is_great</code></pre><h2 id="防止-JSON-劫持——SecureJSON"><a href="#防止-JSON-劫持——SecureJSON" class="headerlink" title="防止 JSON 劫持——SecureJSON"></a>防止 JSON 劫持——SecureJSON</h2><p>如果给定的结构是数组值，则默认预置 “while(1),” 到响应体</p><pre><code class="go">names := []string&#123;&quot;lena&quot;, &quot;austin&quot;, &quot;foo&quot;&#125;// 自定义SecureJSON 前缀r.SecureJsonPrefix(&quot;)]&#125;&#39;,\n&quot;)// 结果：while(1);[&quot;lena&quot;,&quot;austin&quot;,&quot;foo&quot;]c.SecureJSON(http.StatusOK, names)</code></pre><h2 id="XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染"><a href="#XML-x2F-JSON-x2F-YAML-x2F-ProtoBuf-渲染" class="headerlink" title="XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染"></a>XML&#x2F;JSON&#x2F;YAML&#x2F;ProtoBuf 渲染</h2><pre><code class="go">// JSONr.GET(&quot;/someJSON&quot;, func(c *gin.Context) &#123;  c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)&#125;)// JSON-使用结构体r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) &#123;  // 你也可以使用一个结构体  var msg struct &#123;    Name    string `json:&quot;user&quot;`    Message string    Number  int  &#125;  msg.Name = &quot;Lena&quot;  msg.Message = &quot;hey&quot;  msg.Number = 123  // 输出：&#123;&quot;user&quot;: &quot;Lena&quot;, &quot;Message&quot;: &quot;hey&quot;, &quot;Number&quot;: 123&#125;  c.JSON(http.StatusOK, msg)&#125;)// XMLr.GET(&quot;/someXML&quot;, func(c *gin.Context) &#123;  c.XML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)&#125;)// Yamlr.GET(&quot;/someYAML&quot;, func(c *gin.Context) &#123;  c.YAML(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;hey&quot;, &quot;status&quot;: http.StatusOK&#125;)&#125;)// ProtoBufr.GET(&quot;/someProtoBuf&quot;, func(c *gin.Context) &#123;  reps := []int64&#123;int64(1), int64(2)&#125;  label := &quot;test&quot;  // protobuf 的具体定义写在 testdata/protoexample 文件中  data := &amp;protoexample.Test&#123;    Label: &amp;label,    Reps:  reps,  &#125;  // 数据在响应中变为二进制数据  // 将输出被 protoexample.Test protobuf 序列化了的数据  c.ProtoBuf(http.StatusOK, data)&#125;)</code></pre><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><h3 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h3><pre><code class="go">// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB,8右移20位router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;  // 单文件  file, _ := c.FormFile(&quot;file&quot;)  log.Println(file.Filename)  dst := &quot;./&quot; + file.Filename  // 上传文件至指定的完整文件路径  c.SaveUploadedFile(file, dst)  c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded!&quot;, file.Filename))&#125;)//curl -X POST http://localhost:8080/upload \// -F &quot;file=@/Users/appleboy/test.zip&quot; \// -H &quot;Content-Type: multipart/form-data&quot;</code></pre><h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><pre><code class="go">router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123;  // Multipart form  form, _ := c.MultipartForm()  files := form.File[&quot;upload[]&quot;]  for _, file := range files &#123;    log.Println(file.Filename)    // 上传文件至指定目录    c.SaveUploadedFile(file, dst)  &#125;  c.String(http.StatusOK, fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)))&#125;)// curl -X POST http://localhost:8080/upload \//   -F &quot;upload[]=@/Users/appleboy/test1.zip&quot; \//   -F &quot;upload[]=@/Users/appleboy/test2.zip&quot; \//   -H &quot;Content-Type: multipart/form-data&quot;</code></pre><h2 id="不使用默认的中间件"><a href="#不使用默认的中间件" class="headerlink" title="不使用默认的中间件"></a>不使用默认的中间件</h2><p>gin.Default()默认使用 Logger 和 Recovery 中间件<br>gin.New()可以用于不需要使用默认的中间件的场景下</p><h2 id="从-reader-读取数据"><a href="#从-reader-读取数据" class="headerlink" title="从 reader 读取数据"></a>从 reader 读取数据</h2><pre><code class="go">response, err := http.Get(&quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&quot;)if err != nil || response.StatusCode != http.StatusOK &#123;  c.Status(http.StatusServiceUnavailable)  return&#125;reader := response.BodycontentLength := response.ContentLengthcontentType := response.Header.Get(&quot;Content-Type&quot;)extraHeaders := map[string]string&#123;  &quot;Content-Disposition&quot;: `attachment; filename=&quot;gopher.png&quot;`,&#125;c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)</code></pre><h2 id="重启或停止-web-服务器"><a href="#重启或停止-web-服务器" class="headerlink" title="重启或停止 web 服务器"></a>重启或停止 web 服务器</h2><p>使用<code>fvbock/endless</code>代替<code>ListenAndServe</code></p><pre><code class="go">router := gin.Default()router.GET(&quot;/&quot;, handler)// [...]endless.ListenAndServe(&quot;:4242&quot;, router)</code></pre><h2 id="使用-BasicAuth-中间件"><a href="#使用-BasicAuth-中间件" class="headerlink" title="使用 BasicAuth 中间件"></a>使用 BasicAuth 中间件</h2><p>gin.BasicAuth() 中间件</p><pre><code class="go">var secrets = gin.H&#123;    &quot;foo&quot;:    gin.H&#123;&quot;email&quot;: &quot;foo@bar.com&quot;, &quot;phone&quot;: &quot;123433&quot;&#125;,    &quot;austin&quot;: gin.H&#123;&quot;email&quot;: &quot;austin@example.com&quot;, &quot;phone&quot;: &quot;666&quot;&#125;,    &quot;lena&quot;:   gin.H&#123;&quot;email&quot;: &quot;lena@guapa.com&quot;, &quot;phone&quot;: &quot;523443&quot;&#125;,&#125;authorized := r.Group(&quot;/admin&quot;, gin.BasicAuth(gin.Accounts&#123; &quot;foo&quot;:    &quot;bar&quot;, &quot;austin&quot;: &quot;1234&quot;, &quot;lena&quot;:   &quot;hello2&quot;, &quot;manu&quot;:   &quot;4321&quot;,&#125;))// /admin/secrets 端点// 触发 &quot;localhost:8080/admin/secretsauthorized.GET(&quot;/secrets&quot;, func(c *gin.Context) &#123;  // 获取用户，它是由 BasicAuth 中间件设置的  user := c.MustGet(gin.AuthUserKey).(string)  if secret, ok := secrets[user]; ok &#123;    c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user, &quot;secret&quot;: secret&#125;)  &#125; else &#123;    c.JSON(http.StatusOK, gin.H&#123;&quot;user&quot;: user, &quot;secret&quot;: &quot;NO SECRET :(&quot;&#125;)  &#125;&#125;)</code></pre><h2 id="使用-http-方法"><a href="#使用-http-方法" class="headerlink" title="使用 http 方法"></a>使用 http 方法</h2><pre><code class="go">    // 使用默认中间件（logger 和 recovery 中间件）创建 gin 路由    router := gin.Default()    router.GET(&quot;/someGet&quot;, getting)    router.POST(&quot;/somePost&quot;, posting)    router.PUT(&quot;/somePut&quot;, putting)    router.DELETE(&quot;/someDelete&quot;, deleting)    router.PATCH(&quot;/somePatch&quot;, patching)    router.HEAD(&quot;/someHead&quot;, head)    router.OPTIONS(&quot;/someOptions&quot;, options)    // 默认在 8080 端口启动服务，除非定义了一个 PORT 的环境变量。    router.Run()</code></pre><h2 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h2><pre><code class="go">// Logger 中间件将日志写入 gin.DefaultWriter，r.Use(gin.Logger())// Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。r.Use(gin.Recovery())// 可以为每个路由添加任意数量的中间件。r.GET(&quot;/benchmark&quot;, MyBenchLogger(), benchEndpoint)</code></pre><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><pre><code class="go">authorized := r.Group(&quot;/&quot;, AuthRequired())&#123;  authorized.POST(&quot;/login&quot;, loginEndpoint)  authorized.POST(&quot;/submit&quot;, submitEndpoint)  authorized.POST(&quot;/read&quot;, readEndpoint)  // 嵌套路由组  testing := authorized.Group(&quot;testing&quot;)  testing.GET(&quot;/analytics&quot;, analyticsEndpoint)&#125;</code></pre><p>同下面的完全一样</p><pre><code class="go">authorized := r.Group(&quot;/&quot;)authorized.Use(AuthRequired())&#123;  authorized.POST(&quot;/login&quot;, loginEndpoint)  authorized.POST(&quot;/submit&quot;, submitEndpoint)  authorized.POST(&quot;/read&quot;, readEndpoint)&#125;</code></pre><h2 id="只绑定-url-查询字符串"><a href="#只绑定-url-查询字符串" class="headerlink" title="只绑定 url 查询字符串"></a>只绑定 url 查询字符串</h2><p>只绑定 url 查询参数，而忽略 post 参数：<code>ShouldBindQuery</code></p><pre><code class="go">type Person struct &#123;    Name    string `form:&quot;name&quot;`    Address string `form:&quot;address&quot;`&#125;route.PUT(&quot;/testing&quot;, startPage)func startPage(c *gin.Context) &#123;    var person Person    if c.ShouldBindQuery(&amp;person) == nil &#123;        log.Println(&quot;====== Only Bind By Query String ======&quot;)        log.Println(person.Name)        log.Println(person.Address)    &#125;    c.String(200, &quot;Success&quot;)&#125;</code></pre><h2 id="在中间件使用-go-routine"><a href="#在中间件使用-go-routine" class="headerlink" title="在中间件使用 go routine"></a>在中间件使用 go routine</h2><p>当在中间件或 handler 中启动新的 Goroutine 时，不能使用原始的上下文，必须使用只读副本。</p><pre><code class="go">r.GET(&quot;/long_async&quot;, func(c *gin.Context) &#123;  // 创建在 goroutine 中使用的副本  cCp := c.Copy()  go func() &#123;    // 用 time.Sleep() 模拟一个长任务。    time.Sleep(5 * time.Second)    // 使用的是复制的上下文 &quot;cCp&quot;，这一点很重要    log.Println(&quot;Done! in path &quot; + cCp.Request.URL.Path)  &#125;()&#125;)r.GET(&quot;/long_sync&quot;, func(c *gin.Context) &#123;  // 用 time.Sleep() 模拟一个长任务。  time.Sleep(5 * time.Second)  // 因为没有使用 goroutine，不需要使用上下文副本  log.Println(&quot;Done! in path &quot; + c.Request.URL.Path)&#125;)</code></pre><h2 id="记录日志"><a href="#记录日志" class="headerlink" title="记录日志"></a>记录日志</h2><pre><code class="go">// 只将日志写入文件f, _ := os.Create(&quot;gin.log&quot;)gin.DefaultWriter = io.MultiWriter(f)// 需要同时将日志写入文件和控制台gin.DefaultWriter = io.MultiWriter(f, os.Stdout)</code></pre><h2 id="定义路由日志的格式"><a href="#定义路由日志的格式" class="headerlink" title="定义路由日志的格式"></a>定义路由日志的格式</h2><p>默认的路由日志格式</p><pre><code class="bash">[GIN-debug] POST   /foo                      --&gt; main.main.func1 (3 handlers)[GIN-debug] GET    /bar                      --&gt; main.main.func2 (3 handlers)[GIN-debug] GET    /status                   --&gt; main.main.func3 (3 handlers)</code></pre><p>自定义日志格式：JSON，key-value 等-&gt;<code>gin.DebugPrintRouteFunc</code></p><pre><code class="go">gin.DebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) &#123;  log.Printf(&quot;endpoint %v %v %v %v\n&quot;, httpMethod, absolutePath, handlerName, nuHandlers)&#125;</code></pre><h2 id="将-request-body-绑定到不同的结构体中"><a href="#将-request-body-绑定到不同的结构体中" class="headerlink" title="将 request body 绑定到不同的结构体中"></a>将 request body 绑定到不同的结构体中</h2><p><code>c.ShouldBind</code>通过<code>c.Request.Body</code>绑定数据，但是在部分格式不能多次调用：</p><ul><li>JSON</li><li>XML</li><li>MsgPack</li><li>ProtoBuf<br>如果需要多次绑定到不同结构体,需要使用<code>c.ShouldBindBodyWith</code><br>可以多次调用<code>c.ShouldBind</code>的格式：</li><li>Query</li><li>Form</li><li>FormPost</li><li>FormMultipart</li></ul><pre><code class="go">type formA struct &#123;  Foo string `json:&quot;foo&quot; xml:&quot;foo&quot; binding:&quot;required&quot;`&#125;type formB struct &#123;  Bar string `json:&quot;bar&quot; xml:&quot;bar&quot; binding:&quot;required&quot;`&#125;func SomeHandler(c *gin.Context) &#123;  objA := formA&#123;&#125;  objB := formB&#123;&#125;  // c.ShouldBind 使用了 c.Request.Body，不可重用。  if errA := c.ShouldBind(&amp;objA); errA == nil &#123;    c.String(http.StatusOK, `the body should be formA`)  // 因为现在 c.Request.Body 是 EOF，所以这里会报错。  &#125; else if errB := c.ShouldBind(&amp;objB); errB == nil &#123;    c.String(http.StatusOK, `the body should be formB`)  &#125;&#125;// 读取 c.Request.Body 并将结果存入上下文。if errA := c.ShouldBindBodyWith(&amp;objA, binding.JSON); errA == nil &#123;  c.String(http.StatusOK, `the body should be formA`)// 这时, 复用存储在上下文中的 body。&#125; else if errB := c.ShouldBindBodyWith(&amp;objB, binding.JSON); errB == nil &#123;  c.String(http.StatusOK, `the body should be formB JSON`)// 可以接受其他格式&#125; else if errB2 := c.ShouldBindBodyWith(&amp;objB, binding.XML); errB2 == nil &#123;  c.String(http.StatusOK, `the body should be formB XML`)&#125;</code></pre><h2 id="控制日志输出颜色"><a href="#控制日志输出颜色" class="headerlink" title="控制日志输出颜色"></a>控制日志输出颜色</h2><p>输出到控制台的日志默认是有颜色的</p><pre><code class="go">// 禁止日志的颜色gin.DisableConsoleColor()// 强制日志颜色化gin.ForceConsoleColor()</code></pre><h2 id="映射查询字符串或表单参数"><a href="#映射查询字符串或表单参数" class="headerlink" title="映射查询字符串或表单参数"></a>映射查询字符串或表单参数</h2><pre><code class="bash">POST /post?ids[a]=1234&amp;ids[b]=hello HTTP/1.1Content-Type: application/x-www-form-urlencodednames[first]=thinkerou&amp;names[second]=tianou</code></pre><pre><code class="go">ids := c.QueryMap(&quot;ids&quot;)names := c.PostFormMap(&quot;names&quot;)fmt.Printf(&quot;ids: %v; names: %v&quot;, ids, names)// query参数——ids: map[b:hello a:1234],// 表单参数——names: map[second:tianou first:thinkerou]</code></pre><h2 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h2><p>&#x2F;&#x2F; 使用现有的基础请求对象解析查询字符串参数。<br>示例 URL： &#x2F;welcome?firstname&#x3D;Jane&amp;lastname&#x3D;Doe</p><pre><code class="go">router.GET(&quot;/welcome&quot;, func(c *gin.Context) &#123;  firstname := c.DefaultQuery(&quot;firstname&quot;, &quot;Guest&quot;)  lastname := c.Query(&quot;lastname&quot;) // c.Request.URL.Query().Get(&quot;lastname&quot;) 的一种快捷方式  c.String(http.StatusOK, &quot;Hello %s %s&quot;, firstname, lastname)&#125;)</code></pre><h2 id="model-binding-绑定和验证"><a href="#model-binding-绑定和验证" class="headerlink" title="model binding 绑定和验证"></a>model binding 绑定和验证</h2><p>在绑定的所有字段上，设置相应的 tag，比如使用 json 绑定的时候，设置字段标签为 <code>json:&quot;filename&quot;</code><br>方法：ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML<br>行为： 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。</p><pre><code class="go">type Login struct &#123;    User     string `form:&quot;user&quot; json:&quot;user&quot; xml:&quot;user&quot;  binding:&quot;required&quot;`    Password string `form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;`&#125;// 绑定 JSON (&#123;&quot;user&quot;: &quot;manu&quot;, &quot;password&quot;: &quot;123&quot;&#125;)router.POST(&quot;/loginJSON&quot;, func(c *gin.Context) &#123;  var json Login  if err := c.ShouldBindJSON(&amp;json); err != nil &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)    return  &#125;  if json.User != &quot;manu&quot; || json.Password != &quot;123&quot; &#123;    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)    return  &#125;  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)// 绑定XML//&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;//&lt;root&gt;//&lt;user&gt;manu&lt;/user&gt;//&lt;password&gt;123&lt;/password&gt;//&lt;/root&gt;)router.POST(&quot;/loginXML&quot;, func(c *gin.Context) &#123;  var xml Login  if err := c.ShouldBindXML(&amp;xml); err != nil &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)    return  &#125;  if xml.User != &quot;manu&quot; || xml.Password != &quot;123&quot; &#123;    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)    return  &#125;  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)// 绑定 HTML 表单 (user=manu&amp;password=123)router.POST(&quot;/loginForm&quot;, func(c *gin.Context) &#123;  var form Login  // 根据 Content-Type Header 推断使用哪个绑定器。  if err := c.ShouldBind(&amp;form); err != nil &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)    return  &#125;  if form.User != &quot;manu&quot; || form.Password != &quot;123&quot; &#123;    c.JSON(http.StatusUnauthorized, gin.H&#123;&quot;status&quot;: &quot;unauthorized&quot;&#125;)    return  &#125;  c.JSON(http.StatusOK, gin.H&#123;&quot;status&quot;: &quot;you are logged in&quot;&#125;)&#125;)</code></pre><h2 id="绑定-uri"><a href="#绑定-uri" class="headerlink" title="绑定 uri"></a>绑定 uri</h2><pre><code class="go">type Person struct &#123;    ID   string `uri:&quot;id&quot; binding:&quot;required,uuid&quot;`    Name string `uri:&quot;name&quot; binding:&quot;required&quot;`&#125;route.GET(&quot;/:name/:id&quot;, func(c *gin.Context) &#123;  var person Person  if err := c.ShouldBindUri(&amp;person); err != nil &#123;    c.JSON(400, gin.H&#123;&quot;msg&quot;: err.Error()&#125;)    return  &#125;  c.JSON(200, gin.H&#123;&quot;name&quot;: person.Name, &quot;uuid&quot;: person.ID&#125;)&#125;)</code></pre><h2 id="绑定查询字符串或者表单数据"><a href="#绑定查询字符串或者表单数据" class="headerlink" title="绑定查询字符串或者表单数据"></a>绑定查询字符串或者表单数据</h2><pre><code class="go">type Person struct &#123;    Name     string    `form:&quot;name&quot;`    Address  string    `form:&quot;address&quot;`    Birthday time.Time `form:&quot;birthday&quot; time_format:&quot;2006-01-02&quot; time_utc:&quot;1&quot;`&#125;route.GET(&quot;/testing&quot;, startPage)func startPage(c *gin.Context) &#123;    var person Person    // 如果是 `GET` 请求，只使用 `Form` 绑定引擎（`query`）。    // 如果是 `POST` 请求，首先检查 `content-type` 是否为 `JSON` 或 `XML`，然后再使用 `Form`（`form-data`）。    // 查看更多：https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L88    if c.ShouldBind(&amp;person) == nil &#123;        log.Println(person.Name)        log.Println(person.Address)        log.Println(person.Birthday)    &#125;    c.String(200, &quot;Success&quot;)&#125;</code></pre><h2 id="绑定表单数据到自定义-struct"><a href="#绑定表单数据到自定义-struct" class="headerlink" title="绑定表单数据到自定义 struct"></a>绑定表单数据到自定义 struct</h2><p>不支持嵌套的 struct</p><pre><code class="go">type StructA struct &#123;    FieldA string `form:&quot;field_a&quot;`&#125;type StructB struct &#123;    NestedStruct StructA    FieldB string `form:&quot;field_b&quot;`&#125;func GetDataB(c *gin.Context) &#123;  var b StructB  c.Bind(&amp;b)  c.JSON(200, gin.H&#123;      &quot;a&quot;: b.NestedStruct,      &quot;b&quot;: b.FieldB,  &#125;)&#125;</code></pre><h2 id="自定义-http-配置"><a href="#自定义-http-配置" class="headerlink" title="自定义 http 配置"></a>自定义 http 配置</h2><pre><code class="go">http.ListenAndServe(&quot;:8080&quot;, router)// 自定义s := &amp;http.Server&#123;  Addr:           &quot;:8080&quot;,  Handler:        router,  ReadTimeout:    10 * time.Second,  WriteTimeout:   10 * time.Second,  MaxHeaderBytes: 1 &lt;&lt; 20,&#125;s.ListenAndServe()</code></pre><h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><pre><code class="go">func Logger() gin.HandlerFunc &#123;    return func(c *gin.Context) &#123;        t := time.Now()        // 设置 example 变量        c.Set(&quot;example&quot;, &quot;12345&quot;)        // 请求前        c.Next()        // 请求后        latency := time.Since(t)        log.Print(latency)        // 获取发送的 status        status := c.Writer.Status()        log.Println(status)    &#125;&#125;//r := gin.New()r.Use(Logger())r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;  example := c.MustGet(&quot;example&quot;).(string)  // 打印：&quot;12345&quot;  log.Println(example)&#125;)</code></pre><h2 id="自定义验证"><a href="#自定义验证" class="headerlink" title="自定义验证"></a>自定义验证</h2><pre><code class="go">type Booking struct &#123;    CheckIn  time.Time `form:&quot;check_in&quot; binding:&quot;required,bookabledate&quot; time_format:&quot;2006-01-02&quot;`    CheckOut time.Time `form:&quot;check_out&quot; binding:&quot;required,gtfield=CheckIn,bookabledate&quot; time_format:&quot;2006-01-02&quot;`&#125;var bookableDate validator.Func = func(fl validator.FieldLevel) bool &#123;    date, ok := fl.Field().Interface().(time.Time)    if ok &#123;        today := time.Now()        if today.After(date) &#123;            return false        &#125;    &#125;    return true&#125;    if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;        v.RegisterValidation(&quot;bookabledate&quot;, bookableDate)    &#125;</code></pre><h2 id="设置-x2F-获取-cookie"><a href="#设置-x2F-获取-cookie" class="headerlink" title="设置&#x2F;获取 cookie"></a>设置&#x2F;获取 cookie</h2><p>获取:<code>cookie, err := c.Cookie(&quot;gin_cookie&quot;)</code><br>设置:<code>c.SetCookie(&quot;gin_cookie&quot;, &quot;test&quot;, 3600, &quot;/&quot;, &quot;localhost&quot;, false, true)</code></p><h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><p>匹配 &#x2F;user&#x2F;john 但不会匹配 &#x2F;user&#x2F; 或者 &#x2F;user:</p><pre><code class="go">router.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123;  name := c.Param(&quot;name&quot;)  c.String(http.StatusOK, &quot;Hello %s&quot;, name)&#125;)</code></pre><p>匹配 &#x2F;user&#x2F;john&#x2F; 和 &#x2F;user&#x2F;john&#x2F;send:</p><pre><code class="go">//  如果没有其他路由匹配 /user/john，它将重定向到 /user/john/router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) &#123;  name := c.Param(&quot;name&quot;)  action := c.Param(&quot;action&quot;)  message := name + &quot; is &quot; + action  c.String(http.StatusOK, message)&#125;)</code></pre><h2 id="路由组-1"><a href="#路由组-1" class="headerlink" title="路由组"></a>路由组</h2><pre><code class="go">v1 := router.Group(&quot;/v1&quot;)&#123;  v1.POST(&quot;/login&quot;, loginEndpoint)  v1.POST(&quot;/submit&quot;, submitEndpoint)  v1.POST(&quot;/read&quot;, readEndpoint)&#125;</code></pre><h2 id="运行多个服务"><a href="#运行多个服务" class="headerlink" title="运行多个服务"></a>运行多个服务</h2><p>GO </p><pre><code class="go">var (    g errgroup.Group)func router01() http.Handler &#123;    e := gin.New()    e.Use(gin.Recovery())    e.GET(&quot;/&quot;, func(c *gin.Context) &#123;        c.JSON(            http.StatusOK,            gin.H&#123;                &quot;code&quot;:  http.StatusOK,                &quot;error&quot;: &quot;Welcome server 01&quot;,            &#125;,        )    &#125;)    return e&#125;func router02() http.Handler &#123;    e := gin.New()    e.Use(gin.Recovery())    e.GET(&quot;/&quot;, func(c *gin.Context) &#123;        c.JSON(            http.StatusOK,            gin.H&#123;                &quot;code&quot;:  http.StatusOK,                &quot;error&quot;: &quot;Welcome server 02&quot;,            &#125;,        )    &#125;)    return e&#125;server01 := &amp;http.Server&#123;  Addr:         &quot;:8080&quot;,  Handler:      router01(),  ReadTimeout:  5 * time.Second,  WriteTimeout: 10 * time.Second,&#125;server02 := &amp;http.Server&#123;  Addr:         &quot;:8081&quot;,  Handler:      router02(),  ReadTimeout:  5 * time.Second,  WriteTimeout: 10 * time.Second,&#125;g.Go(func() error &#123;  return server01.ListenAndServe()&#125;)g.Go(func() error &#123;  return server02.ListenAndServe()&#125;)if err := g.Wait(); err != nil &#123;  log.Fatal(err)&#125;</code></pre><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="get重定向"><a href="#get重定向" class="headerlink" title="get重定向"></a>get重定向</h3><pre><code class="go">r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;    c.Redirect(http.StatusMovedPermanently, &quot;http://www.google.com/&quot;)&#125;)</code></pre><h3 id="post-重定向"><a href="#post-重定向" class="headerlink" title="post 重定向"></a>post 重定向</h3><pre><code class="go">r.POST(&quot;/test&quot;, func(c *gin.Context) &#123;    c.Redirect(http.StatusFound, &quot;/foo&quot;)&#125;)</code></pre><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>使用<code>HandleContext</code></p><pre><code class="go">r.GET(&quot;/test&quot;, func(c *gin.Context) &#123;    c.Request.URL.Path = &quot;/test2&quot;    r.HandleContext(c)&#125;)r.GET(&quot;/test2&quot;, func(c *gin.Context) &#123;    c.JSON(200, gin.H&#123;&quot;hello&quot;: &quot;world&quot;&#125;)&#125;)</code></pre><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><pre><code class="go">router.Static(&quot;/assets&quot;, &quot;./assets&quot;)router.StaticFS(&quot;/more_static&quot;, http.Dir(&quot;my_file_system&quot;))router.StaticFile(&quot;/favicon.ico&quot;, &quot;./resources/favicon.ico&quot;)</code></pre><h2 id="静态资源嵌入"><a href="#静态资源嵌入" class="headerlink" title="静态资源嵌入"></a>静态资源嵌入</h2><pre><code class="go">// loadTemplate 加载由 go-assets-builder 嵌入的模板func loadTemplate() (*template.Template, error) &#123;    t := template.New(&quot;&quot;)    for name, file := range Assets.Files &#123;        if file.IsDir() || !strings.HasSuffix(name, &quot;.tmpl&quot;) &#123;            continue        &#125;        h, err := ioutil.ReadAll(file)        if err != nil &#123;            return nil, err        &#125;        t, err = t.New(name).Parse(string(h))        if err != nil &#123;            return nil, err        &#125;    &#125;    return t, nil&#125;t, err := loadTemplate()if err != nil &#123;  panic(err)&#125;r.SetHTMLTemplate(t)r.GET(&quot;/&quot;, func(c *gin.Context) &#123;  c.HTML(http.StatusOK, &quot;/html/index.tmpl&quot;, nil)&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gorm学习笔记</title>
      <link href="/2023/03/21/gorm-xue-xi-bi-ji/"/>
      <url>/2023/03/21/gorm-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">go get -u gorm.io/gorm# 安装对应数据库驱动，比如mysql,sqlitego get -u gorm.io/driver/mysql</code></pre><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><pre><code class="go">package mainimport (  &quot;gorm.io/gorm&quot;  &quot;gorm.io/driver/sqlite&quot;)type Product struct &#123;  gorm.Model  Code  string  Price uint&#125;func main() &#123;  // 连接数据库  db, err := gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;&#125;)  if err != nil &#123;    panic(&quot;failed to connect database&quot;)  &#125;  // 迁移 schema：保持数据库和程序数据结构始终保持一致  db.AutoMigrate(&amp;Product&#123;&#125;)  // Create ：创建一条数据库记录  db.Create(&amp;Product&#123;Code: &quot;D42&quot;, Price: 100&#125;)  // Read ：查询数据库记录  var product Product  db.First(&amp;product, 1) // 根据整型主键查找  db.First(&amp;product, &quot;code = ?&quot;, &quot;D42&quot;) // 查找 code 字段值为 D42 的记录  // Update ：修改数据库单条记录，将 product 的 price 更新为 200  db.Model(&amp;product).Update(&quot;Price&quot;, 200)  // Update - 更新多个字段  db.Model(&amp;product).Updates(Product&#123;Price: 200, Code: &quot;F42&quot;&#125;) // 仅更新非零值字段  db.Model(&amp;product).Updates(map[string]interface&#123;&#125;&#123;&quot;Price&quot;: 200, &quot;Code&quot;: &quot;F42&quot;&#125;)  // Delete：软删除数据库单条记录， 删除 product  db.Delete(&amp;product, 1)&#125;</code></pre><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>约定优于配置</p><ol><li>GORM 使用 ID 做主键</li><li>GORM 使用结构体名称<code>UserTable</code>的蛇形复数<code>user_tables</code>作为表名，字段名的蛇形<code>created_at</code>作为列名</li><li>GORM 使用 CreatedAt,UpdatedAt 字段追踪创建时间和更新时间</li><li>可修改默认配置,具体见<a href="https://gorm.io/zh_CN/docs/conventions.html">修改默认配置</a></li></ol><h2 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h2><p>本质：一个 struct 结构体</p><pre><code class="go">// gorm.Model 的定义type Model struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time   //在创建、更新、删除时自动填充当前时间  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`&#125;</code></pre><h2 id="控制字段级的读写权限"><a href="#控制字段级的读写权限" class="headerlink" title="控制字段级的读写权限"></a>控制字段级的读写权限</h2><p>默认可导出字段在进行 CRUD 的时候拥有全部权限。使用自动迁移创建表的时候，不会创建被忽略的字段</p><pre><code class="go">type User struct &#123;  Name string `gorm:&quot;&lt;-:create&quot;` // 允许读和创建  Name string `gorm:&quot;&lt;-:update&quot;` // 允许读和更新  Name string `gorm:&quot;&lt;-&quot;`        // 允许读和写（创建和更新）  Name string `gorm:&quot;&lt;-:false&quot;`  // 允许读，禁止写  Name string `gorm:&quot;-&gt;&quot;`        // 只读（除非有自定义配置，否则禁止写）  Name string `gorm:&quot;-&gt;;&lt;-:create&quot;` // 允许读和写  Name string `gorm:&quot;-&gt;:false;&lt;-:create&quot;` // 仅创建（禁止从 db 读）  Name string `gorm:&quot;-&quot;`  // 通过 struct 读写会忽略该字段  Name string `gorm:&quot;-:all&quot;`        // 通过 struct 读写、迁移会忽略该字段  Name string `gorm:&quot;-:migration&quot;`  // 通过 struct 迁移会忽略该字段&#125;</code></pre><h2 id="嵌入结构体"><a href="#嵌入结构体" class="headerlink" title="嵌入结构体"></a>嵌入结构体</h2><h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><pre><code class="go">type User struct &#123;  gorm.Model  Name string&#125;// 等效于type User struct &#123;  ID        uint           `gorm:&quot;primaryKey&quot;`  CreatedAt time.Time  UpdatedAt time.Time  DeletedAt gorm.DeletedAt `gorm:&quot;index&quot;`  Name string&#125;</code></pre><h3 id="正常结构体字段"><a href="#正常结构体字段" class="headerlink" title="正常结构体字段"></a>正常结构体字段</h3><ol><li>通过标签 <code>embedded</code> 将其嵌入</li></ol><pre><code class="go">type Author struct &#123;    Name  string    Email string&#125;type Blog struct &#123;  ID      int  Author  Author `gorm:&quot;embedded&quot;`  UpVotes int32&#125;// 等效于type Blog struct &#123;  ID    int64  Name  string  Email string  UpVotes  int32&#125;</code></pre><ol start="2"><li>使用标签 embeddedPrefix 来为 db 中的字段名添加前缀</li></ol><pre><code class="go">type Author struct &#123;    Name  string    Email string&#125;type Blog struct &#123;  ID      int  Author  Author `gorm:&quot;embedded;embeddedPrefix:author_&quot;`  UpVotes  int32&#125;// 等效于type Blog struct &#123;  ID          int64  AuthorName string  AuthorEmail string  UpVotes  int32&#125;</code></pre><h2 id="字段标签-tag"><a href="#字段标签-tag" class="headerlink" title="字段标签 tag"></a>字段标签 tag</h2><p>声明 model 时，tag 是可选的,使用<code>camelCase</code>风格</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>column</td><td>指定 db 列名</td></tr><tr><td>type</td><td>列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</td></tr><tr><td>serializer</td><td>指定将数据序列化或反序列化到数据库中的序列化器, 例如: serializer:json&#x2F;gob&#x2F;unixtime</td></tr><tr><td>size</td><td>定义列数据类型的大小或长度，例如 size: 256</td></tr><tr><td>primaryKey</td><td>将列定义为主键</td></tr><tr><td>unique</td><td>将列定义为唯一键</td></tr><tr><td>default</td><td>定义列的默认值</td></tr><tr><td>precision</td><td>指定列的精度</td></tr><tr><td>scale</td><td>指定列大小</td></tr><tr><td>not null</td><td>指定列为 NOT NULL</td></tr><tr><td>autoIncrement</td><td>指定列为自动增长</td></tr><tr><td>autoIncrementIncrement</td><td>自动步长，控制连续记录之间的间隔</td></tr><tr><td>embedded</td><td>嵌套字段</td></tr><tr><td>embeddedPrefix</td><td>嵌入字段的列名前缀</td></tr><tr><td>autoCreateTime</td><td>创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano&#x2F;milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano</td></tr><tr><td>autoUpdateTime</td><td>创建&#x2F;更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano&#x2F;milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli</td></tr><tr><td>index</td><td>根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情</td></tr><tr><td>uniqueIndex</td><td>与 index 相同，但创建的是唯一索引</td></tr><tr><td>check</td><td>创建检查约束，例如 check:age &gt; 13，查看 约束 获取详情</td></tr><tr><td>&lt;-</td><td>设置字段写入的权限， &lt;-:create 只创建、&lt;-:update 只更新、&lt;-:false 无写入权限、&lt;- 创建和更新权限</td></tr><tr><td>-&gt;</td><td>设置字段读的权限，-&gt;:false 无读权限</td></tr><tr><td>-</td><td>忽略该字段，- 表示无读写，-:migration 表示无迁移权限，-:all 表示无读写迁移权限</td></tr><tr><td>comment</td><td>迁移时为字段添加注释</td></tr></tbody></table><h2 id="连接到数据库"><a href="#连接到数据库" class="headerlink" title="连接到数据库"></a>连接到数据库</h2><p>目前支持数据库类型：MySQL, PostgreSQL, SQLite, SQL Server,clickHouse 和 TiDB</p><h3 id="以-mysql-为例"><a href="#以-mysql-为例" class="headerlink" title="以 mysql 为例"></a>以 mysql 为例</h3><h4 id="简单型"><a href="#简单型" class="headerlink" title="简单型"></a>简单型</h4><pre><code class="go">  dsn := &quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;  db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</code></pre><h4 id="高级配置型"><a href="#高级配置型" class="headerlink" title="高级配置型"></a>高级配置型</h4><p>DNS 参数配置参考<a href="https://github.com/go-sql-driver/mysql#parameters">go-sql-driver</a><br>mysql 配置可参考<a href="https://github.com/go-gorm/mysql">go-gorm&#x2F;mysql</a></p><pre><code class="go">db, err := gorm.Open(mysql.New(mysql.Config&#123;  // 此处  DSN: &quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;, // DSN data source name  DefaultStringSize: 256, // string 类型字段的默认长度  DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持  DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引  DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列  SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置  DriverName:&quot;自定义mysql驱动名称&quot;&#125;), &amp;gorm.Config&#123;&#125;)</code></pre><h4 id="通过一个现有的数据库连接来初始化-gorm-DB"><a href="#通过一个现有的数据库连接来初始化-gorm-DB" class="headerlink" title="通过一个现有的数据库连接来初始化 *gorm.DB"></a>通过一个现有的数据库连接来初始化 *gorm.DB</h4><pre><code class="go">import (  &quot;database/sql&quot;  &quot;gorm.io/driver/mysql&quot;  &quot;gorm.io/gorm&quot;)sqlDB, err := sql.Open(&quot;mysql&quot;, &quot;mydb_dsn&quot;)gormDB, err := gorm.Open(mysql.New(mysql.Config&#123;  Conn: sqlDB,&#125;), &amp;gorm.Config&#123;&#125;)</code></pre><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><h3 id="通过数据的指针创建"><a href="#通过数据的指针创建" class="headerlink" title="通过数据的指针创建"></a>通过数据的指针创建</h3><pre><code class="go">user:=User&#123;Name:&quot;yueyueyan&quot;,Age:19,Birthday:time.Now()&#125;result:=db.Create(&amp;user)</code></pre><p>返回结果<br>user.ID：返回插入数据的主键<br>result.Error ：返回 error<br>result.RowsAffected ： 返回插入记录的条数</p><h3 id="用指定的字段创建记录"><a href="#用指定的字段创建记录" class="headerlink" title="用指定的字段创建记录"></a>用指定的字段创建记录</h3><pre><code class="go">db.Select(&quot;Name&quot;, &quot;Age&quot;, &quot;CreatedAt&quot;).Create(&amp;user)//创建指定字段的记录// INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (&quot;j&quot;, 18, &quot;2020-07-04 11:05:21.775&quot;)db.Omit(&quot;Name&quot;, &quot;Age&quot;, &quot;CreatedAt&quot;).Create(&amp;user)//创建忽略指定字段的记录// INSERT INTO `users` (`birthday`,`updated_at`) VALUES (&quot;2020-01-01 00:00:00.000&quot;, &quot;2020-07-04 11:05:21.775&quot;)</code></pre><h3 id="批量添加"><a href="#批量添加" class="headerlink" title="批量添加"></a>批量添加</h3><p>原理:将切片传给 Create 方法<br>注意：使用 CreateBatchSize 选项初始化 GORM 时，所有的创建&amp; 关联 INSERT 都将遵循该选项</p><blockquote><p>比如 gorm.Config 中 CreateBatchSize 设置为 1000，则之后所有数据插入都要遵循这个值<br><code>users = [5000]User&#123;&#123;Name: "jinzhu", Pets: []Pet&#123;pet1, pet2, pet3&#125;&#125;...&#125;</code><br>则 users 需要批量插入 5 次,pets 需要批量插入 15 次</p></blockquote><pre><code class="go">var users = []User&#123;&#123;Name: "j1"&#125;, &#123;Name: "j2"&#125;, &#123;Name: "j3"&#125;&#125;db.Create(&amp;users)for _, user := range users &#123;  user.ID // 1,2,3&#125;</code></pre><h3 id="创建钩子"><a href="#创建钩子" class="headerlink" title="创建钩子"></a>创建钩子</h3><p>支持的钩子函数：BeforeSave, BeforeCreate, AfterSave, AfterCreate<br>跳过钩子函数：<code>DB.Session(&amp;gorm.Session&#123;SkipHooks: true&#125;).Create(&amp;user)</code></p><h4 id="根据-Map-创建"><a href="#根据-Map-创建" class="headerlink" title="根据 Map 创建"></a>根据 Map 创建</h4><ul><li>根据<code>map[string]interface&#123;&#125;</code>创建</li></ul><pre><code class="go">db.Model(&amp;User&#123;&#125;).Create(map[string]interface&#123;&#125;&#123;  &quot;Name&quot;: &quot;jinzhu&quot;, &quot;Age&quot;: 18,&#125;)</code></pre><ul><li>根据<code>[]map[string]interface&#123;&#125;&#123;&#125;</code>创建</li></ul><pre><code class="go">db.Model(&amp;User&#123;&#125;).Create([]map[string]interface&#123;&#125;&#123;  &#123;&quot;Name&quot;: &quot;jinzhu_1&quot;, &quot;Age&quot;: 18&#125;,  &#123;&quot;Name&quot;: &quot;jinzhu_2&quot;, &quot;Age&quot;: 20&#125;,&#125;)</code></pre><h3 id="使用-SQL-表达式、Context-Valuer-创建记录"><a href="#使用-SQL-表达式、Context-Valuer-创建记录" class="headerlink" title="使用 SQL 表达式、Context Valuer 创建记录"></a>使用 SQL 表达式、Context Valuer 创建记录</h3><p>暂时忽略</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="获取单条记录："><a href="#获取单条记录：" class="headerlink" title="获取单条记录："></a>获取单条记录：</h3><ul><li>First() 获取第一条记录[主键升序]</li><li>Take() 获取一条记录</li><li>Last（）获取最后一条记录[主键降序]</li><li>检查 ErrRecordNotFound 错误<br><code>errors.Is(result.Error, gorm.ErrRecordNotFound)</code></li><li>避开 ErrRecordNotFound 错误<br><code>db.Limit(1).Find(&amp;user)</code></li><li>Fist 和 Last 方法生效条件<ol><li>指向目标 struct 的指针作为参数传入方法</li><li>使用<code>db.Model()</code>指定 model</li></ol></li><li>如果没有定义主键,则按照第一个字段排序</li></ul><pre><code class="go">var user  Uservar users []User// 生效，满足条件1// 查询users表中按user struct 主键id排列的第一条记录db.First(&amp;user)// 生效，满足条件2result := map[string]interface&#123;&#125;&#123;&#125;db.Model(&amp;User&#123;&#125;).First(&amp;result)// 不生效result := map[string]interface&#123;&#125;&#123;&#125;db.Table(&quot;users&quot;).First(&amp;result)// 使用Take生效result := map[string]interface&#123;&#125;&#123;&#125;db.Table(&quot;users&quot;).Take(&amp;result)</code></pre><h3 id="按照主键获取"><a href="#按照主键获取" class="headerlink" title="按照主键获取"></a>按照主键获取</h3><ol><li>主键是数值:使用内联条件</li></ol><pre><code class="go">db.First(&amp;user, 10)db.First(&amp;user, &quot;10&quot;)//查询id为10的第一条记录db.Find(&amp;users, []int&#123;1,2,3&#125;) //查询id在1,2,3中的记录</code></pre><ol start="2"><li>主键是字符串:有 sql 注入风险</li></ol><pre><code class="go">// 搜索id为1bxx-xx-xx的用户记录db.First(&amp;user, &quot;id = ?&quot;, &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;)</code></pre><h3 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h3><pre><code class="go">// result.RowsAffected :返回找到的记录条数// result.Error: 返回错误result := db.Find(&amp;users)</code></pre><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="string-条件"><a href="#string-条件" class="headerlink" title="string 条件"></a>string 条件</h4><pre><code class="go">//查询name等于jinzhu的第一条记录db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)// 查询name不等于jinzhu的所有记录db.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(&amp;users)// 查询name为jinzhu或者 jinzhu 2的所有记录db.Where(&quot;name IN ?&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(&amp;users)// 模糊匹配,查询name包含jin的所有记录db.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(&amp;users)// 查询name为jinzhu并且age&gt;=22的所有记录db.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(&amp;users)// 查询更新时间大于上周的所有记录db.Where(&quot;updated_at &gt; ?&quot;, week(now())-1).Find(&amp;users)// 查询上周和今天之间创建的所有记录db.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(&amp;users)</code></pre><p>如果设置了对象的主键,则与查询条件构成 AND 关系</p><h4 id="struct-amp-Map-条件"><a href="#struct-amp-Map-条件" class="headerlink" title="struct&amp;Map 条件"></a>struct&amp;Map 条件</h4><pre><code class="go">// struct:查询Name为jinzhu,年龄为20的按主键id升序的第一条记录db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 20&#125;).First(&amp;user)// Map：查询name为jinzhu,年龄为20的所有记录db.Where(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;, &quot;age&quot;: 20&#125;).Find(&amp;users)// 查询id为20/21/22的所有记录db.Where([]int64&#123;20, 21, 22&#125;).Find(&amp;users)// 不支持零值,查询name为jinzhu的所有记录db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;, Age: 0&#125;).Find(&amp;users)// 支持零值db.Where(map[string]interface&#123;&#125;&#123;&quot;Name&quot;: &quot;jinzhu&quot;, &quot;Age&quot;: 0&#125;).Find(&amp;users)</code></pre><h4 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h4><pre><code class="go">// 查询名称为jinzhu,Age为0的用户db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;name&quot;, &quot;Age&quot;).Find(&amp;users)// 查询年龄为0的所有记录db.Where(&amp;User&#123;Name: &quot;jinzhu&quot;&#125;, &quot;Age&quot;).Find(&amp;users)// SELECT * FROM users WHERE age = 0;</code></pre><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><p>内联指的是将查询条件嵌入到 First 等方法中,达到与 where 相似的效果</p><pre><code class="go">db.First(&amp;user, &quot;id = ?&quot;, &quot;string_primary_key&quot;)db.Find(&amp;user, &quot;name = ?&quot;, &quot;jinzhu&quot;)db.Find(&amp;users, &quot;name &lt;&gt; ? AND age &gt; ?&quot;, &quot;jinzhu&quot;, 20)// structdb.Find(&amp;users, User&#123;Age: 20&#125;)// mapdb.Find(&amp;users, map[string]interface&#123;&#125;&#123;&quot;age&quot;: 20&#125;)</code></pre><h4 id="Not-条件-和-Or-条件"><a href="#Not-条件-和-Or-条件" class="headerlink" title="Not 条件 和 Or 条件"></a>Not 条件 和 Or 条件</h4><pre><code class="go">// Not// 查询name不为jinzhu的第一条记录db.Not(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user)// 查询name不为jinzhu或者jinzhu 2的所有记录db.Not(map[string]interface&#123;&#125;&#123;&quot;name&quot;: []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;&#125;).Find(&amp;users)// 查询name不为jinzhu并且Age不为18的第一条记录db.Not(User&#123;Name: &quot;jinzhu&quot;, Age: 18&#125;).First(&amp;user)// 查询主键id不在1,2,3的第一条记录db.Not([]int64&#123;1,2,3&#125;).First(&amp;user)// Or// 查询role是admin或者role是super_admin的第一条记录db.Where(&quot;role = ?&quot;, &quot;admin&quot;).Or(&quot;role = ?&quot;, &quot;super_admin&quot;).Find(&amp;users)// 查询name为jinzhu,或者name为jinzhu2并且Age为18的所有记录// struct:db.Where(&quot;name = &#39;jinzhu&#39;&quot;).Or(User&#123;Name: &quot;jinzhu 2&quot;, Age: 18&#125;).Find(&amp;users)// map:db.Where(&quot;name = &#39;jinzhu&#39;&quot;).Or(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu 2&quot;, &quot;age&quot;: 18&#125;).Find(&amp;users)</code></pre><h4 id="选择特定字段-Select-方法"><a href="#选择特定字段-Select-方法" class="headerlink" title="选择特定字段 Select 方法"></a>选择特定字段 Select 方法</h4><pre><code class="go">// 从users表中查询name,age字段db.Select(&quot;name&quot;, &quot;age&quot;).Find(&amp;users)db.Select([]string&#123;&quot;name&quot;, &quot;age&quot;&#125;).Find(&amp;users)db.Table(&quot;users&quot;).Select(&quot;COALESCE(age,?)&quot;, 42).Rows()</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>默认升序</p><pre><code class="go">// age降序,name升序返回所有记录db.Order(&quot;age desc, name&quot;).Find(&amp;users)db.Order(&quot;age desc&quot;).Order(&quot;name&quot;).Find(&amp;users)// SQL语句：不常用~SELECT * FROM users ORDER BY FIELD(id,1,2,3)db.Clauses(clause.OrderBy&#123;  Expression: clause.Expr&#123;SQL: &quot;FIELD(id,?)&quot;, Vars: []interface&#123;&#125;&#123;[]int&#123;1, 2, 3&#125;&#125;, WithoutParentheses: true&#125;,&#125;).Find(&amp;User&#123;&#125;)</code></pre><h3 id="Limit-amp-Offset"><a href="#Limit-amp-Offset" class="headerlink" title="Limit&amp;Offset"></a>Limit&amp;Offset</h3><h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>作用:指定返回记录的最大值<br>Limit(-1):取消 limit 限制</p><pre><code class="go">// 从users表查询3条记录db.Limit(3).Find(&amp;users)// 从users1表查询10条记录，从users2表中查询所有记录db.Limit(10).Find(&amp;users1).Limit(-1).Find(&amp;users2)</code></pre><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p>作用:指定在开始返回记录之前要跳过的记录数量<br>Offset(-1)：取消 Offset 限制</p><pre><code class="go">// 从第四条开始返回记录db.Offset(3).Find(&amp;users)db.Limit(10).Offset(5).Find(&amp;users)db.Offset(10).Find(&amp;users1).Offset(-1).Find(&amp;users2)</code></pre><p>offset 具体效果：</p><img src="/2023/03/21/gorm-xue-xi-bi-ji/no_offset.jpg" class=""><img src="/2023/03/21/gorm-xue-xi-bi-ji/offset.jpg" class=""><h3 id="Group-By-amp-Having"><a href="#Group-By-amp-Having" class="headerlink" title="Group By &amp;Having"></a>Group By &amp;Having</h3><h4 id="Group-By：Group"><a href="#Group-By：Group" class="headerlink" title="Group By：Group()"></a>Group By：Group()</h4><p>作用：将具有相同值的行分组到汇总行中，例如“查找每个国家的客户数”。</p><pre><code class="go">type result struct &#123;  Date  time.Time  Total int&#125;// SELECT name, sum(age) as total FROM `users` WHERE name LIKE &quot;group%&quot; GROUP BY `name` LIMIT 1// as关键字用于重命名列或表db.Model(&amp;User&#123;&#125;).Select(&quot;name, sum(age) as total&quot;).Where(&quot;name LIKE ?&quot;, &quot;group%&quot;).Group(&quot;name&quot;).First(&amp;result)rows, err := db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Rows()</code></pre><h4 id="Having"><a href="#Having" class="headerlink" title="Having"></a>Having</h4><p>作用：where 的替代品，因为 where 不能和聚合函数一起使用,所以使用 having 子句来设置条件<br>聚合函数：</p><ul><li>AVG - 计算一组值或表达式的平均值。</li><li>COUNT - 计算表中的行数。</li><li>INSTR - 返回字符串中第一次出现的子字符串的位置。</li><li>SUM - 计算一组值或表达式的总和。</li><li>MIN - 在一组值中找到最小值</li><li>MAX - 在一组值中找到最大值</li></ul><pre><code class="go">db.Model(&amp;User&#123;&#125;).Select(&quot;name, sum(age) as total&quot;).Group(&quot;name&quot;).Having(&quot;name = ?&quot;, &quot;group&quot;).Find(&amp;result)db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Having(&quot;sum(amount) &gt; ?&quot;, 100).Scan(&amp;results)rows, err := db.Table(&quot;orders&quot;).Select(&quot;date(created_at) as date, sum(amount) as total&quot;).Group(&quot;date(created_at)&quot;).Having(&quot;sum(amount) &gt; ?&quot;, 100).Rows()</code></pre><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>作用：查询去重,只保留一个<br>只根据查询字段去重:</p><img src="/2023/03/21/gorm-xue-xi-bi-ji/distinct1.jpg" class=""><img src="/2023/03/21/gorm-xue-xi-bi-ji/distinct2.jpg" class=""><img src="/2023/03/21/gorm-xue-xi-bi-ji/distinct3.jpg" class=""><img src="/2023/03/21/gorm-xue-xi-bi-ji/distinct4.jpg" class=""><pre><code class="go">db.Distinct(&quot;name&quot;, &quot;age&quot;).Order(&quot;name, age desc&quot;).Find(&amp;results)</code></pre><h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p>外键列：数据库中的公共列<br>作用：指定 joins 条件，基于表之间的公共列的值在一个（自连接）或更多表之间链接数据<br>存在表：t1,t2</p><ul><li>cross join 笛卡尔积 —— 结果集包括 t1 表中行和 t2 表中行的组合-&gt;<code>SELECT t1.id, t2.id FROM t1 CROSS JOIN t2; </code></li><li>inner join —— 必须有一个连接字段条件,结果集包括满足该条件的 t1 和 t2 行的组合-&gt; <code>SELECT t1.id, t2.id FROM t1 INNER JOIN t2 ON t1.pattern = t2.pattern; </code></li><li>left join —— 必须有一个条件,结果集包含左表 t1 的所有数据和满足条件的 t2 的行的组合 <code>SELECT t1.id, t2.id FROM t1 LEFT JOIN t2 ON t1.pattern = t2.pattern;</code>,此处比 inner join 多一个 1,null</li><li>right join —— 同 left join 相反，结果集包含右表 t2 的所有数据</li></ul><pre><code class="go">type result struct &#123;  Name  string  Email string&#125;db.Model(&amp;User&#123;&#125;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Scan(&amp;result&#123;&#125;) //users表，左连接rows, err := db.Table(&quot;users&quot;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Rows()//users表，右连接db.Table(&quot;users&quot;).Select(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Scan(&amp;results)// 带参数的多重joindb.Joins(&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;, &quot;jinzhu@example.org&quot;).Joins(&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;).Where(&quot;credit_cards.number = ?&quot;, &quot;411111111111&quot;).Find(&amp;user)</code></pre><h4 id="Join-预加载"><a href="#Join-预加载" class="headerlink" title="Join 预加载"></a>Join 预加载</h4><pre><code class="go">// SELECT users.id,users.name,users.age,Company.id AS Company__id,Company.name AS Company__name FROM users LEFT JOIN companies AS Company ON users.company_id = Company.id;db.Joins(&quot;Company&quot;).Find(&amp;users)// SELECT users.id,users.name,users.age,Company.id AS Company__id,Company.name AS Company__name FROM users INNER JOIN  companies AS Company  ON users.company_id = Company.id;db.InnerJoins(&quot;Company&quot;).Find(&amp;users)// 条件连接// SELECT users.id,users.name,users.age,Company.id AS Company__id,Company.name AS Company__name FROM users LEFT JOIN companies AS Company  ON users.company_id = Company.id AND Company.alive = true;db.Joins(&quot;Company&quot;, db.Where(&amp;Company&#123;Alive: true&#125;)).Find(&amp;users)</code></pre><h4 id="Scan"><a href="#Scan" class="headerlink" title="Scan()"></a>Scan()</h4><p>把结果扫描到一个 struct,和 Find()方法类似</p><pre><code class="go">type Result struct &#123;  Name string  Age  int&#125;var result Resultdb.Table(&quot;users&quot;).Select(&quot;name&quot;, &quot;age&quot;).Where(&quot;name = ?&quot;, &quot;Antonio&quot;).Scan(&amp;result)// Raw SQLdb.Raw(&quot;SELECT name, age FROM users WHERE name = ?&quot;, &quot;Antonio&quot;).Scan(&amp;result)</code></pre><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><h3 id="自动选择字段"><a href="#自动选择字段" class="headerlink" title="自动选择字段"></a>自动选择字段</h3><p>手动：使用 Select()方法选择特定字段<br>自动：将需要选择的字段放在一个 struct 中</p><pre><code class="go">type User struct &#123;  ID     uint  Name   string  Age    int  Gender string  // 假设后面还有几百个字段...&#125;type APIUser struct &#123;  ID   uint  Name string&#125;// 查询时会自动选择 `id`, `name` 字段db.Model(&amp;User&#123;&#125;).Limit(10).Find(&amp;APIUser&#123;&#125;)// SELECT id, name FROM users LIMIT 10</code></pre><h3 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h3><p>Gorm 支持多种类型的锁<br>锁：和表关联的标志，</p><ul><li>针对会话</li><li>防止其他会话在特定时间段内访问同一个表。</li><li>客户端会话只能为自己获取或释放表锁。它无法获取或释放其他会话的表锁</li></ul><h4 id="读锁-共享锁-表锁"><a href="#读锁-共享锁-表锁" class="headerlink" title="读锁-共享锁 (表锁)"></a>读锁-共享锁 (表锁)</h4><p>语法：</p><ul><li>显式上锁：<code>LOCK TABLES table_name READ</code></li><li>隐式上锁：<code>select </code></li><li>解锁：<code>UNLOCK TABLES; </code></li></ul><p>约束：</p><ol><li>当在 A 会话中设置了 READ 锁，则 A 会话中插入数据会报错</li><li>当在 A 会话中设置了 READ 锁，会话 B 依然可以从表中读取数据</li><li>当在 A 会话中设置了 READ 锁，会话 B 如果要插入数据，会进入等待状态，直至 A 会话中的锁被释放</li><li>如果会话终止，则隐式释放所有锁</li></ol><h4 id="写锁-排他锁-表锁"><a href="#写锁-排他锁-表锁" class="headerlink" title="写锁-排他锁 (表锁)"></a>写锁-排他锁 (表锁)</h4><p>语法：</p><ul><li><p>显式上锁：<code>LOCK TABLE table_name WRITE;</code></p></li><li><p>隐式上锁：<code>insert、update、delete</code><br>种类：</p></li><li><p>约束：</p></li></ul><ol><li>当在 A 会话中设置了 WRITE 锁,A 会话仍可以检索或者插入数据</li><li>当在 A 会话中设置了 WRITE 锁,会话 B 的所有命令都会进入等待状态，直至解锁</li></ol><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>显式上锁：</p><ul><li><code>select * from tableName lock in share mode;</code>&#x2F;&#x2F;读锁&#x2F;共享锁 5.7</li><li>&#96;&#96;select * from tableName lock for share;&#96;&#x2F;&#x2F;读锁 8.0</li><li><code>select * from tableName for update;</code>&#x2F;&#x2F;写锁&#x2F;排他锁</li></ul><p>解锁：</p><ul><li>提交事务（commit）</li><li>回滚事务（rollback）</li><li>kill 阻塞进程</li></ul><hr><pre><code class="go">// SELECT * FROM users FOR UPDATEdb.Clauses(clause.Locking&#123;Strength: &quot;UPDATE&quot;&#125;).Find(&amp;users)// SELECT * FROM users FOR SHARE OF usersdb.Clauses(clause.Locking&#123;  Strength: &quot;SHARE&quot;,  Table: clause.Table&#123;Name: clause.CurrentTable&#125;,&#125;).Find(&amp;users)// SELECT * FROM users FOR UPDATE NOWAITdb.Clauses(clause.Locking&#123;  Strength: &quot;UPDATE&quot;,  Options: &quot;NOWAIT&quot;,&#125;).Find(&amp;users)</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><pre><code class="go">// 相当于SELECT * FROM &quot;orders&quot; WHERE amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;);db.Where(&quot;amount &gt; (?)&quot;, db.Table(&quot;orders&quot;).Select(&quot;AVG(amount)&quot;)).Find(&amp;orders)// 相当于SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE &quot;name%&quot;)subQuery := db.Select(&quot;AVG(age)&quot;).Where(&quot;name LIKE ?&quot;, &quot;name%&quot;).Table(&quot;users&quot;)db.Select(&quot;AVG(age) as avgage&quot;).Group(&quot;name&quot;).Having(&quot;AVG(age) &gt; (?)&quot;, subQuery).Find(&amp;results)// FROM子查询// 相当于SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18db.Table(&quot;(?) as u&quot;, db.Model(&amp;User&#123;&#125;).Select(&quot;name&quot;, &quot;age&quot;)).Where(&quot;age = ?&quot;, 18).Find(&amp;User&#123;&#125;)</code></pre><h3 id="多个列的IN查询"><a href="#多个列的IN查询" class="headerlink" title="多个列的IN查询"></a>多个列的IN查询</h3><pre><code class="go">// SELECT * FROM users WHERE (name, age, role) IN ((&quot;jinzhu&quot;, 18, &quot;admin&quot;), (&quot;jinzhu 2&quot;, 19, &quot;user&quot;));db.Where(&quot;(name, age, role) IN ?&quot;, [][]interface&#123;&#125;&#123;&#123;"jinzhu", 18, "admin"&#125;, &#123;"jinzhu2", 19, "user"&#125;&#125;).Find(&amp;users)</code></pre><!-- 待补充 --><h2 id="修改更新"><a href="#修改更新" class="headerlink" title="修改更新"></a>修改更新</h2><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><pre><code class="go">// UPDATE users SET name=&#39;jinzhu 2&#39;, age=100, birthday=&#39;2016-01-01&#39;, updated_at = &#39;2013-11-17 21:34:10&#39; WHERE id=111;db.First(&amp;user)user.Name = &quot;jinzhu 2&quot;user.Age = 100db.Save(&amp;user)</code></pre><h3 id="修改单个列"><a href="#修改单个列" class="headerlink" title="修改单个列"></a>修改单个列</h3><p>需要设置一些条件避免<code>ErrMissingWhereClause</code>错误<br>使用 Model 方法，并且值中有主键值时，主键将会被用于构建条件</p><pre><code class="go">// 条件更新:UPDATE users SET name=&#39;hello&#39;, updated_at=&#39;2013-11-17 21:34:10&#39; WHERE active=true;db.Model(&amp;User&#123;&#125;).Where(&quot;active = ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)// User 的 ID 是 `111`: UPDATE users SET name=&#39;hello&#39;, updated_at=&#39;2013-11-17 21:34:10&#39; WHERE id=111;db.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)// 根据条件和 model 的值进行更新:UPDATE users SET name=&#39;hello&#39;, updated_at=&#39;2013-11-17 21:34:10&#39; WHERE id=111 AND active=true;db.Model(&amp;user).Where(&quot;active = ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)</code></pre><h3 id="修改多个列"><a href="#修改多个列" class="headerlink" title="修改多个列"></a>修改多个列</h3><p>根据 <code>struct</code> 更新属性，只会更新非零值的字段</p><pre><code class="go">// 根据 `struct` 更新属性// UPDATE users SET name=&#39;hello&#39;, age=18, updated_at = &#39;2013-11-17 21:34:10&#39; WHERE id = 111;db.Model(&amp;user).Updates(User&#123;Name: &quot;hello&quot;, Age: 18, Active: false&#125;)// 根据 `map` 更新属性// UPDATE users SET name=&#39;hello&#39;, age=18, active=false, updated_at=&#39;2013-11-17 21:34:10&#39; WHERE id=111;db.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)</code></pre><h3 id="修改指定字段"><a href="#修改指定字段" class="headerlink" title="修改指定字段"></a>修改指定字段</h3><p>方法: Select、Omit</p><pre><code class="go">// User&#39;s ID is `111`:// struct:UPDATE users SET name=&#39;hello&#39; WHERE id=111;db.Model(&amp;user).Select(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)// 忽略某个字段// UPDATE users SET age=18, active=false, updated_at=&#39;2013-11-17 21:34:10&#39; WHERE id=111;db.Model(&amp;user).Omit(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18, &quot;active&quot;: false&#125;)//选择role以外的所有字段db.Model(&amp;user).Select(&quot;*&quot;).Omit(&quot;Role&quot;).Updates(User&#123;Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Age: 0&#125;)</code></pre><h3 id="更新hook"><a href="#更新hook" class="headerlink" title="更新hook"></a>更新hook</h3><p>暂时忽略</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>未通过 Model 指定记录的主键，则 GORM 会执行批量更新<br>更新如果没有任何条件则会报错,可以通过添加条件或原生Sql或者启用<code>AllowGlobalUpdate</code>模式</p><pre><code class="go">// 根据 struct 更新// UPDATE users SET name=&#39;hello&#39;, age=18 WHERE role = &#39;admin&#39;;db.Model(User&#123;&#125;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)// 根据 map 更新db.Table(&quot;users&quot;).Where(&quot;id IN ?&quot;, []int&#123;10, 11&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18&#125;)// UPDATE users SET name=&#39;hello&#39;, age=18 WHERE id IN (10, 11);// gorm.ErrMissingWhereClausedb.Model(&amp;User&#123;&#125;).Updates(&quot;name&quot;, &quot;jinzhu&quot;).Error </code></pre><p>通过原生sql,启用<code>AllowGlobalUpdate</code>模式解决gorm.ErrMissingWhereClause报错</p><pre><code class="go">db.Exec(&quot;UPDATE users SET name = ?&quot;, &quot;jinzhu&quot;)// UPDATE users SET name = &quot;jinzhu&quot;db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: true&#125;).Model(&amp;User&#123;&#125;).Update(&quot;name&quot;, &quot;jinzhu&quot;)// UPDATE users SET `name` = &quot;jinzhu&quot;</code></pre><h3 id="获取受更新影响的行数"><a href="#获取受更新影响的行数" class="headerlink" title="获取受更新影响的行数"></a>获取受更新影响的行数</h3><p><code>RowsAffected</code>属性</p><pre><code class="go">// UPDATE users SET name=&#39;hello&#39;, age=18 WHERE role = &#39;admin&#39;;result := db.Model(User&#123;&#125;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)result.RowsAffected // 更新的记录数result.Error        // 更新的错误</code></pre><h3 id="高级选项"><a href="#高级选项" class="headerlink" title="高级选项"></a>高级选项</h3><p>暂时忽略</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除单条记录"><a href="#删除单条记录" class="headerlink" title="删除单条记录"></a>删除单条记录</h3><p>需要指定主键,否则会触发批量删除</p><pre><code class="go">// Email 的 ID 是 `10`// DELETE from emails where id = 10;db.Delete(&amp;email)// 带额外条件的删除// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Delete(&amp;email)</code></pre><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><pre><code class="go">// DELETE FROM users WHERE id = 10;db.Delete(&amp;User&#123;&#125;, 10)db.Delete(&amp;User&#123;&#125;, &quot;10&quot;)// DELETE FROM users WHERE id IN (1,2,3);db.Delete(&amp;users, []int&#123;1,2,3&#125;)</code></pre><h3 id="Delete-hook"><a href="#Delete-hook" class="headerlink" title="Delete hook"></a>Delete hook</h3><p>暂时忽略</p><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，将删除所有匹配的记录</p><pre><code class="go">// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;db.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).Delete(&amp;Email&#123;&#125;)// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;db.Delete(&amp;Email&#123;&#125;, &quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;)</code></pre><h3 id="返回被删除的数据"><a href="#返回被删除的数据" class="headerlink" title="返回被删除的数据"></a>返回被删除的数据</h3><pre><code class="go">// 返回所有列var users []User// 返回所有列var users []User// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING *DB.Clauses(clause.Returning&#123;&#125;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Delete(&amp;users)// users =&gt; []User&#123;&#123;ID: 1, Name: "jinzhu", Role: "admin", Salary: 100&#125;, &#123;ID: 2, Name: "jinzhu.2", Role: "admin", Salary: 1000&#125;&#125;// 返回指定的列// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING `name`, `salary`// users =&gt; []User&#123;&#123;ID: 0, Name: "jinzhu", Role: "", Salary: 100&#125;, &#123;ID: 0, Name: "jinzhu.2", Role: "", Salary: 1000&#125;&#125;DB.Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: "name"&#125;, &#123;Name: "salary"&#125;&#125;&#125;).Where(&quot;role = ?&quot;, &quot;admin&quot;).Delete(&amp;users)</code></pre><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>概念:</p><ol><li>不会把记录从数据库中真正删除,只是把DeletedAt设置为当前时间</li><li>删除后不能再通过普通的查询方法找到该记录</li></ol><pre><code class="go">// user 的 ID 是 `111`// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;db.Delete(&amp;user)// 批量删除// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;db.Where(&quot;age = ?&quot;, 20).Delete(&amp;User&#123;&#125;)// 查询时会忽略被软删除的记录db.Where(&quot;age = 20&quot;).Find(&amp;user)// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL</code></pre><h3 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h3><p>找到被软删除的记录:<code>db.Unscoped().Where(&quot;age = 20&quot;).Find(&amp;users)</code></p><pre><code class="go">// DELETE FROM orders WHERE id=10;db.Unscoped().Delete(&amp;order)</code></pre><hr><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><h3 id="belongs-to"><a href="#belongs-to" class="headerlink" title="belongs to"></a>belongs to</h3><p>概念:</p><ol><li>包含 user 和 company，并且每个 user 能且只能被分配给一个 company</li><li>User和Company有一个共同的外键CompanyID</li></ol><pre><code class="go">type User struct &#123;  gorm.Model  Name      string  CompanyID int  Company   Company `gorm:&quot;constraint:OnUpdate:CASCADE,OnDelete:SET NULL;&quot;`&#125;type Company struct &#123;  ID   int  Name string&#125;</code></pre><h3 id="has-one"><a href="#has-one" class="headerlink" title="has one"></a>has one</h3><p>概念:</p><ol><li>包含 user 和 credit card ，且每个 user 只能有一张 credit card</li></ol><pre><code class="go">// User 有一张 CreditCard，UserID 是外键type User struct &#123;  gorm.Model  CreditCard CreditCard&#125;type CreditCard struct &#123;  gorm.Model  Number string  UserID uint&#125;// 检索用户列表并预加载信用卡func GetAll(db *gorm.DB) ([]User, error) &#123;    var users []User    err := db.Model(&amp;User&#123;&#125;).Preload(&quot;CreditCard&quot;).Find(&amp;users).Error    return users, err&#125;</code></pre><h3 id="Has-Many"><a href="#Has-Many" class="headerlink" title="Has Many"></a>Has Many</h3><p>概念:</p><ol><li>包含 user 和 credit card 模型，且每个 user 可以有多张 credit card</li></ol><pre><code class="go">// User 有多张 CreditCard，UserID 是外键type User struct &#123;  gorm.Model  CreditCards []CreditCard&#125;type CreditCard struct &#123;  gorm.Model  Number string  UserID uint&#125;// 检索用户列表并预加载信用卡func GetAll(db *gorm.DB) ([]User, error) &#123;    var users []User    err := db.Model(&amp;User&#123;&#125;).Preload(&quot;CreditCards&quot;).Find(&amp;users).Error    return users, err&#125;</code></pre><h3 id="Many-to-Many"><a href="#Many-to-Many" class="headerlink" title="Many to Many"></a>Many to Many</h3><p>概念:</p><ol><li>包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language</li><li>当使用 GORM 的 AutoMigrate 为 User 创建表时，GORM 会自动创建连接表</li></ol><pre><code class="go">// User 拥有并属于多种 language，`user_languages` 是连接表type User struct &#123;  gorm.Model  Languages []Language `gorm:&quot;many2many:user_languages;&quot;`&#125;type Language struct &#123;  gorm.Model  Name string&#125;// User 拥有并属于多种 language，`user_languages` 是连接表type User struct &#123;  gorm.Model  Languages []*Language `gorm:&quot;many2many:user_languages;&quot;`&#125;type Language struct &#123;  gorm.Model  Name string  Users []*User `gorm:&quot;many2many:user_languages;&quot;`&#125;// 检索 User 列表并预加载 Languagefunc GetAllUsers(db *gorm.DB) ([]User, error) &#123;    var users []User    err := db.Model(&amp;User&#123;&#125;).Preload(&quot;Languages&quot;).Find(&amp;users).Error    return users, err&#125;// 检索 Language 列表并预加载 Userfunc GetAllLanguages(db *gorm.DB) ([]Language, error) &#123;    var languages []Language    err := db.Model(&amp;Language&#123;&#125;).Preload(&quot;Users&quot;).Find(&amp;languages).Error    return languages, err&#125;</code></pre><h3 id="实体关联"><a href="#实体关联" class="headerlink" title="实体关联"></a>实体关联</h3><p>在创建、更新记录时，GORM 会通过 Upsert 自动保存关联及其引用记录。<br>跳过自动创建更新:使用select 和 omit</p><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><h4 id="使用-Preload通过多个SQL中来直接加载关系"><a href="#使用-Preload通过多个SQL中来直接加载关系" class="headerlink" title="使用 Preload通过多个SQL中来直接加载关系"></a>使用 <code>Preload</code>通过多个SQL中来直接加载关系</h4><pre><code class="go">type User struct &#123;  gorm.Model  Username string  Orders   []Order&#125;type Order struct &#123;  gorm.Model  UserID uint  Price  float64&#125;// 查找 user 时预加载相关 Order// SELECT * FROM users;// SELECT * FROM orders WHERE user_id IN (1,2,3,4);db.Preload(&quot;Orders&quot;).Find(&amp;users)// SELECT * FROM users;// SELECT * FROM orders WHERE user_id IN (1,2,3,4); // has many// SELECT * FROM profiles WHERE user_id IN (1,2,3,4); // has one// SELECT * FROM roles WHERE id IN (4,5,6); // belongs todb.Preload(&quot;Orders&quot;).Preload(&quot;Profile&quot;).Preload(&quot;Role&quot;).Find(&amp;users)</code></pre><h4 id="joins预加载"><a href="#joins预加载" class="headerlink" title="joins预加载"></a>joins预加载</h4><pre><code class="go">db.Joins(&quot;Company&quot;).Joins(&quot;Manager&quot;).Joins(&quot;Account&quot;).First(&amp;user, 1)db.Joins(&quot;Company&quot;).Joins(&quot;Manager&quot;).Joins(&quot;Account&quot;).First(&amp;user, &quot;users.name = ?&quot;, &quot;jinzhu&quot;)db.Joins(&quot;Company&quot;).Joins(&quot;Manager&quot;).Joins(&quot;Account&quot;).Find(&amp;users, &quot;users.id IN ?&quot;, []int&#123;1,2,3,4,5&#125;)db.Joins(&quot;Company&quot;, DB.Where(&amp;Company&#123;Alive: true&#125;)).Find(&amp;users)</code></pre><hr><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>普通错误:</p><pre><code class="go">if err := db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).First(&amp;user).Error; err != nil &#123;  // 处理错误...&#125;</code></pre><p>未找到对应记录错误ErrRecordNotFound</p><pre><code class="go">// 检查错误是否为 RecordNotFounderr := db.First(&amp;user, 100).Errorerrors.Is(err, gorm.ErrRecordNotFound)</code></pre><h2 id="链式方法"><a href="#链式方法" class="headerlink" title="链式方法"></a>链式方法</h2><p>链式&#x2F;终结方法之后返回一个初始化的<code>*gorm.DB</code>实例</p><ul><li>链式方法:Where, Select, Omit, Joins, Scopes, Preload, Raw</li><li>终结方法:Create, First, Find, Take, Save, Update, Delete, Scan, Row, Rows</li><li>新建会话方法: Session、WithContext、Debug</li></ul><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>暂时忽略</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>用于自动迁移 schema，保持您的 schema 是最新的<br>schema:数据库对象集合，它包含了各种对像，比如：表，视图，存储过程，索引等等</p><pre><code class="go">db.AutoMigrate(&amp;User&#123;&#125;)db.AutoMigrate(&amp;User&#123;&#125;, &amp;Product&#123;&#125;, &amp;Order&#123;&#125;)// 创建表时添加后缀db.Set(&quot;gorm:table_options&quot;, &quot;ENGINE=InnoDB&quot;).AutoMigrate(&amp;User&#123;&#125;)</code></pre><h2 id="日志Logger"><a href="#日志Logger" class="headerlink" title="日志Logger"></a>日志Logger</h2><p>作用:打印慢 SQL 和错误<br>级别:Silent、Error、Warn、Info</p><pre><code class="go">newLogger := logger.New(  log.New(os.Stdout, &quot;\r\n&quot;, log.LstdFlags), // io writer（日志输出的目标，前缀和日志包含的内容）  logger.Config&#123;    SlowThreshold: time.Second,   // 慢 SQL 阈值    LogLevel:      logger.Silent, // 日志级别    IgnoreRecordNotFoundError: true,   // 忽略ErrRecordNotFound（记录未找到）错误    Colorful:      false,         // 禁用彩色打印  &#125;,)// 全局模式db, err := gorm.Open(sqlite.Open(&quot;test.db&quot;), &amp;gorm.Config&#123;  Logger: newLogger,&#125;)// 新建会话模式tx := db.Session(&amp;Session&#123;Logger: newLogger&#125;)tx.First(&amp;user)tx.Model(&amp;user).Update(&quot;Age&quot;, 18)</code></pre><h2 id="通用数据库接口"><a href="#通用数据库接口" class="headerlink" title="通用数据库接口"></a>通用数据库接口</h2><pre><code class="go">// 获取通用数据库对象 sql.DB，然后使用其提供的功能sqlDB, err := db.DB()// PingsqlDB.Ping()// ClosesqlDB.Close()// 返回数据库统计信息sqlDB.Stats()</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code class="go">// 获取通用数据库对象 sql.DB ，然后使用其提供的功能sqlDB, err := db.DB()// SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。sqlDB.SetMaxIdleConns(10)// SetMaxOpenConns 设置打开数据库连接的最大数量。sqlDB.SetMaxOpenConns(100)// SetConnMaxLifetime 设置了连接可复用的最大时间。sqlDB.SetConnMaxLifetime(time.Hour)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ini文件配置</title>
      <link href="/2023/03/19/ini-wen-jian-pei-zhi/"/>
      <url>/2023/03/19/ini-wen-jian-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>github地址：<a href="https://github.com/go-ini/ini">https://github.com/go-ini/ini</a><br>文档地址：<a href="https://ini.unknwon.io/">https://ini.unknwon.io/</a></p><p>包的功能：在Go语言中读写INI文件的功能<br>Go最低版本：1.6<br>安装：<code>go get gopkg.in/ini.v1</code><br>更新：<code>go get -u gopkg.in/ini.v1</code></p><p>my.ini</p><pre><code class="bash"># my.ini#  可选值：production, developmentapp_mode = development# grafana存储临时文件，session和sqlite3数据库[paths]data=/home/git/grafana[server]# 协议protocol=http# http端口http_port=9999# 如果主机header不符合域名的话，重定向到正确的域名# 防止 DNS 重新绑定攻击enforce_domain=true</code></pre><p>main.go</p><pre><code class="go">func main() &#123;    cfg, err := ini.Load(&quot;my.ini&quot;)    if err != nil &#123;        fmt.Printf(&quot;Fail to read file: %v&quot;, err)        os.Exit(1)    &#125;    // 简单的读取操作    fmt.Println(&quot;App Mode:&quot;, cfg.Section(&quot;&quot;).Key(&quot;app_mode&quot;).String())    fmt.Println(&quot;Data Path:&quot;, cfg.Section(&quot;paths&quot;).Key(&quot;data&quot;).String())    // 做一些候选值限制的操作    // 如果读取的值不在候选列表内，则会回退使用提供的默认值    fmt.Println(&quot;Server Protocol:&quot;, cfg.Section(&quot;server&quot;).Key(&quot;protocol&quot;).In(&quot;http&quot;, []string&#123;&quot;http&quot;, &quot;https&quot;&#125;))    fmt.Println(&quot;Email Protocol:&quot;, cfg.Section(&quot;server&quot;).Key(&quot;protocol&quot;).In(&quot;smtp&quot;, []string&#123;&quot;imap&quot;, &quot;smtp&quot;&#125;))    // 自动类型转换    fmt.Printf(&quot;Port Number:(%[1]T) %[1]d\n&quot;, cfg.Section(&quot;server&quot;).Key(&quot;http_port&quot;).MustInt((9999)))    fmt.Printf(&quot;Enforce Domain: (%[1]T) %[1]v\n&quot;, cfg.Section(&quot;server&quot;).Key(&quot;enforce_domain&quot;).MustBool(false))    // 修改某个值后保存到新文件    cfg.Section(&quot;&quot;).Key(&quot;app_mode&quot;).SetValue(&quot;production&quot;)    cfg.SaveTo(&quot;mysql.ini.local&quot;)&#125;// 输出：// App Mode: development// Data Path: /home/git/grafana// Server Protocol: http// Email Protocol: smtp// Port Number:(int) 9999// Enforce Domain: (bool) true</code></pre><h3 id="从数据源加载配置"><a href="#从数据源加载配置" class="headerlink" title="从数据源加载配置"></a>从数据源加载配置</h3><p>数据源类型：</p><ul><li>[]byte类型的原始数据</li><li>string 类型的文件路径</li><li>io.ReadCloser</li></ul><p>特点：</p><ul><li>可以加载多个数据源  <code>ini.Load(&quot;my.ini&quot;)</code></li><li>可以从一个空白的文件开始 <code>cfg:=ini.Empty()</code></li><li>后期可以按需加载 <code>err := cfg.Append(&quot;other file&quot;, []byte(&quot;other raw data&quot;))</code></li><li>不确定是否有文件不存在，可以使用LooseLoad <code>cfg, err := ini.LooseLoad(&quot;filename&quot;, &quot;filename_404&quot;)</code>,后期通过<code>Reload()</code>可以正常加载</li><li>加载多个数据源，如果出现同名键，则后面的配置会覆盖前面的配置</li><li>数据覆盖只有在使用 ShadowLoad 加载数据源不会被触发</li></ul><h4 id="跳过无法识别的数据行"><a href="#跳过无法识别的数据行" class="headerlink" title="跳过无法识别的数据行"></a>跳过无法识别的数据行</h4><p>如果配置文件包含非键值对的数据行，解析器默认报错并终止解析<br>忽略错误：</p><pre><code class="go">cfg, err := ini.LoadSources(ini.LoadOptions&#123;    SkipUnrecognizableLines: true,&#125;, &quot;other.ini&quot;)</code></pre><h4 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h4><ol><li>输出配置到某个文件</li></ol><pre><code class="go">err = cfg.SaveTo(&quot;my.ini&quot;)err = cfg.SaveToIndent(&quot;my.ini&quot;, &quot;\t&quot;)</code></pre><ol start="2"><li>写入到任何实现 io.Writer 接口的对象中</li></ol><pre><code class="go">cfg.WriteTo(writer)cfg.WriteToIndent(writer, &quot;\t&quot;)</code></pre><h3 id="操作分区Section"><a href="#操作分区Section" class="headerlink" title="操作分区Section"></a>操作分区Section</h3><ul><li>获取默认分区1:<code>sec, err := cfg.GetSection(&quot;&quot;)</code></li><li>获取默认分区2:<code>sec, err := cfg.GetSection(ini.DEFAULT_SECTION)</code></li><li>获取指定分区1：<code>sec, err := cfg.GetSection(&quot;section name&quot;)</code></li><li>获取指定分区2：<code>sec := cfg.Section(&quot;section name&quot;)</code>，如果不存在则自动创建并返回一个对应的分区</li><li>创建分区：<code>err := cfg.NewSection(&quot;new section&quot;)</code></li><li>获取所有分区对象或名称：</li></ul><pre><code class="go">secs := cfg.Sections()names := cfg.SectionStrings()</code></pre><h4 id="父子分区"><a href="#父子分区" class="headerlink" title="父子分区"></a>父子分区</h4><p>概念：在分区名称中使用 . 来表示两个或多个分区之间的父子关系<br>关系：如果某个键在子分区中不存在，则会去它的父分区中再次寻找，直到没有父分区为止</p><pre><code class="bash">NAME = iniVERSION = v1IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s[package]CLONE_URL = https://%(IMPORT_PATH)s[package.sub]# https://gopkg.in/ini.v1cfg.Section(&quot;package.sub&quot;).Key(&quot;CLONE_URL&quot;).String()   </code></pre><h4 id="非键值对分区"><a href="#非键值对分区" class="headerlink" title="非键值对分区"></a>非键值对分区</h4><p>使用选项<code>LoadOptions.UnparsableSections</code>配置解析</p><pre><code class="go">cfg, err := ini.LoadSources(ini.LoadOptions&#123;    UnparseableSections: []string&#123;&quot;COMMENTS&quot;&#125;,&#125;, `[COMMENTS]&lt;1&gt;&lt;L.Slide#2&gt; This slide has the fuel listed in the wrong units &lt;e.1&gt;`)body := cfg.Section(&quot;COMMENTS&quot;).Body()/* --- start ---&lt;1&gt;&lt;L.Slide#2&gt; This slide has the fuel listed in the wrong units &lt;e.1&gt;------  end  --- */</code></pre><h3 id="操作键Key"><a href="#操作键Key" class="headerlink" title="操作键Key"></a>操作键Key</h3><ul><li>获取某个分区下的键1：<code>key, err := cfg.Section(&quot;&quot;).GetKey(&quot;key name&quot;)</code></li><li>获取某个分区下的键2：<code>key := cfg.Section(&quot;&quot;).Key(&quot;key name&quot;)</code></li><li>判断某个键是否存在：<code>yes := cfg.Section(&quot;&quot;).HasKey(&quot;key name&quot;)</code></li><li>创建新的Key：<code>err := cfg.Section(&quot;&quot;).NewKey(&quot;name&quot;, &quot;value&quot;)</code></li><li>获取分区下的所有键或键名：</li></ul><pre><code class="go">keys := cfg.Section(&quot;&quot;).Keys()names := cfg.Section(&quot;&quot;).KeyStrings()</code></pre><h4 id="忽略分区或键名大小写"><a href="#忽略分区或键名大小写" class="headerlink" title="忽略分区或键名大小写"></a>忽略分区或键名大小写</h4><p><code>cfg, err := ini.InsensitiveLoad(&quot;filename&quot;)</code></p><h4 id="同一个键名包含多个值"><a href="#同一个键名包含多个值" class="headerlink" title="同一个键名包含多个值"></a>同一个键名包含多个值</h4><p>普通情况下：只有最后一次出现的值会被保存到url中<br>需要保留所有值：</p><pre><code class="go">cfg, err := ini.ShadowLoad(&quot;.gitconfig&quot;)f.Section(`remote &quot;origin&quot;`).Key(&quot;url&quot;).String() # Result: https://github.com/Antergone/test2.gitf.Section(`remote &quot;origin&quot;`).Key(&quot;url&quot;).ValueWithShadows()//  Result:  []string&#123;//             &quot;https://github.com/Antergone/test1.git&quot;,//               &quot;https://github.com/Antergone/test2.git&quot;,//           &#125;</code></pre><h4 id="自增键名"><a href="#自增键名" class="headerlink" title="自增键名"></a>自增键名</h4><p>如果数据源中的键名为 -，则认为该键使用了自增键名的特殊语法。计数器从 1 开始，并且分区之间是相互独立的<br><code>cfg.Section(&quot;features&quot;).KeyStrings()    // []&#123;&quot;#1&quot;, &quot;#2&quot;, &quot;#3&quot;&#125;</code></p><h4 id="获取父分区下的所有键名"><a href="#获取父分区下的所有键名" class="headerlink" title="获取父分区下的所有键名"></a>获取父分区下的所有键名</h4><p><code>cfg.Section(&quot;package.sub&quot;).ParentKeys() // [&quot;CLONE_URL&quot;]</code></p><h3 id="操作键值Value"><a href="#操作键值Value" class="headerlink" title="操作键值Value"></a>操作键值Value</h3><ul><li>获取key的值:<code>al := cfg.Section(&quot;&quot;).Key(&quot;key name&quot;).String()</code></li><li>获取原值：<code>val := cfg.Section(&quot;&quot;).Key(&quot;key name&quot;).Value()</code></li><li>判断某个原值是否存在：<code>yes := cfg.Section(&quot;&quot;).HasValue(&quot;test value&quot;)</code></li></ul><h4 id="Value布尔值的规则："><a href="#Value布尔值的规则：" class="headerlink" title="Value布尔值的规则："></a>Value布尔值的规则：</h4><p>结果为true：为：1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On<br>结果为false 为：0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off</p><h4 id="Must开头的方法"><a href="#Must开头的方法" class="headerlink" title="Must开头的方法"></a>Must开头的方法</h4><p>由 Must 开头的方法名允许接收一个相同类型的参数来作为默认值，<br>当键不存在或者转换失败时，则会直接返回该默认值。但是，MustXXXX方法必须传递一个默认值。</p><pre><code class="go">v = cfg.Section(&quot;&quot;).Key(&quot;INT&quot;).MustInt(10)</code></pre><h4 id="多行书写"><a href="#多行书写" class="headerlink" title="多行书写"></a>多行书写</h4><p>可以使用\分隔<br><code>cfg.Section(&quot;advance&quot;).Key(&quot;two_lines&quot;).String() </code>获取到的是一个不换行的字符串</p><h4 id="自动处理特殊字符"><a href="#自动处理特殊字符" class="headerlink" title="自动处理特殊字符"></a>自动处理特殊字符</h4><p>具体概念：值使用双引号括起来，内部的双引号被转义<br>案例：create_repo&#x3D;”created repository &lt;a href&#x3D;&quot;%s&quot;&gt;%s</a>“</p><pre><code class="go">cfg, err := ini.LoadSources(ini.LoadOptions&#123;UnescapeValueDoubleQuotes: true&#125;, &quot;en-US.ini&quot;)cfg.Section(&quot;&lt;name of your section&gt;&quot;).Key(&quot;create_repo&quot;).String()// 结果：created repository &lt;a href=&quot;%s&quot;&gt;%s&lt;/a&gt;</code></pre><h4 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h4><ul><li>设置默认值,不在给定的值内就设置为默认值<br><code>v = cfg.Section(&quot;&quot;).Key(&quot;STRING&quot;).In(&quot;default&quot;, []string&#123;&quot;str&quot;, &quot;arr&quot;, &quot;types&quot;&#125;)</code></li><li>判断获取的值是否在指定范围内,第一个参数为默认值，第二个参数和第三个参数为范围<br><code>vals = cfg.Section(&quot;&quot;).Key(&quot;FLOAT64&quot;).RangeFloat64(0.0, 1.1, 2.2)</code></li><li>自动分割键值到切片<ul><li>存在无效输入的的时候，使用零值代替</li></ul></li></ul><pre><code class="go">// Input: 1.1, 2.2, 3.3, 4.4 -&gt; [1.1 2.2 3.3 4.4]// Input: how, 2.2, are, you -&gt; [0.0 2.2 0.0 0.0]vals = cfg.Section(&quot;&quot;).Key(&quot;STRINGS&quot;).Strings(&quot;,&quot;)vals = cfg.Section(&quot;&quot;).Key(&quot;FLOAT64S&quot;).Float64s(&quot;,&quot;)</code></pre><pre><code>-  去除无效输入</code></pre><pre><code class="go">// Input: 1.1, 2.2, 3.3, 4.4 -&gt; [1.1 2.2 3.3 4.4]// Input: how, 2.2, are, you -&gt; [2.2]vals = cfg.Section(&quot;&quot;).Key(&quot;FLOAT64S&quot;).ValidFloat64s(&quot;,&quot;)</code></pre><pre><code>- 存在无效输入时，直接返回错误</code></pre><pre><code class="go">// Input: 1.1, 2.2, 3.3, 4.4 -&gt; [1.1 2.2 3.3 4.4]// Input: how, 2.2, are, you -&gt; errorvals = cfg.Section(&quot;&quot;).Key(&quot;FLOAT64S&quot;).StrictFloat64s(&quot;,&quot;)</code></pre><ul><li>递归读取键值<br>语法：<code> %(&lt;name&gt;)s</code>， 其中name只能是相同分区或默认分区下的键名，如果指定的键不存在，则会用空字符串替代</li></ul><pre><code class="go">NAME = ini[author]NAME = UnknwonGITHUB = https://github.com/%(NAME)s[package]FULL_NAME = github.com/go-ini/%(NAME)s// cfg.Section(&quot;author&quot;).Key(&quot;GITHUB&quot;).String()：https://github.com/Unknwon// cfg.Section(&quot;package&quot;).Key(&quot;FULL_NAME&quot;).String()：github.com/go-ini/ini</code></pre><h3 id="注释Comment"><a href="#注释Comment" class="headerlink" title="注释Comment"></a>注释Comment</h3><h4 id="注释分类"><a href="#注释分类" class="headerlink" title="注释分类"></a>注释分类</h4><ol><li>所有以 # 或 ; 开头的行</li><li>所有在 # 或 ; 之后的内容</li><li>分区标签后的文字 (即 [分区名] 之后的内容)</li></ol><h3 id="结构体和分区双向映射"><a href="#结构体和分区双向映射" class="headerlink" title="结构体和分区双向映射"></a>结构体和分区双向映射</h3><p>暂时忽略</p><h3 id="自定义键名和键值映射器"><a href="#自定义键名和键值映射器" class="headerlink" title="自定义键名和键值映射器"></a>自定义键名和键值映射器</h3><p>暂时忽略</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何获取ui库未导出的组件类型</title>
      <link href="/2023/03/09/ru-he-huo-qu-ui-ku-wei-dao-chu-de-zu-jian-lei-xing/"/>
      <url>/2023/03/09/ru-he-huo-qu-ui-ku-wei-dao-chu-de-zu-jian-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>antd有一些组件的props属性并没有导出，但是项目里又需要用到，可以用下面这个方法来获取</p><pre><code class="TypeScript">type SelectProps = React.ComponentProps&lt;typeof Select&gt;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-CSS vs. CSS-in-JS：How and why to use each</title>
      <link href="/2023/03/07/fan-yi-css-vs-css-in-js/"/>
      <url>/2023/03/07/fan-yi-css-vs-css-in-js/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://blog.logrocket.com/css-vs-css-in-js/">https://blog.logrocket.com/css-vs-css-in-js/</a><br><a href="https://blog.logrocket.com/how-style-react-router-links-styled-components/">https://blog.logrocket.com/how-style-react-router-links-styled-components/</a><br>当使用 javascript 框架写代码的时候，开发者经常会面临一个困境：是否需要使用 CSS-in-JS。如果你使用 React 进行开发，可能你之前就使用过 CSS-in-JS。</p><p>CSS vs CSS-in-JS 是当下的热门话题。这主要是因为 CSS-in-JS 正在因为性能问题而备受关注。但是在<a href="https://web.dev/state-of-css-2022/">这个方向上(pipline 翻译不确定)</a>也有一些新的 CSS 特性,他们应该会在不久的未来解决一部分问题。</p><p>这篇文章的目的是结合现代 CSS 的当前状态以及将来可能如何变化帮助你在接下来的项目中就 CSS 和 CSS-in-JS 中做出选择。</p><p>这篇文章展示的代码片段和 demo 都是使用 React 和 CSS 编写的。所以在进行下一步之前需要确保你对这两种 web 技术都非常熟悉。</p><p>注意任意的 JavaScript 前端框架或者库都可以是实现 CSS-in-JS 的理念。本文使用目前为止最流行的前端库——React 来讨论 CSS-in-JS 的应用以及它显著的利弊。</p><h2 id="Render-blocking-和-CSS"><a href="#Render-blocking-和-CSS" class="headerlink" title="Render-blocking 和 CSS"></a>Render-blocking 和 CSS</h2><p>在进一步讨论什么是最好的,什么不是最好的之前,我们先讨论因为 CSS 导致的一些渲染问题。</p><p>传统 web 技术中,浏览器首先会加载 HTML,然后加载来自所有外部资源的 CSS。那之后,浏览器使用所有的内外部 CSS 信息创建 CSSOM。此时浏览器已准备好通过 CSS 级联规则向已经渲染的 HTML 提供样式。</p><p>这个进程会导致 CSS <a href="https://blog.logrocket.com/9-tricks-eliminate-render-blocking-resources/">阻止页面渲染</a>，并延迟所请求页面的首绘。首绘指的是浏览器在屏幕上打印所请求页面的第一个像素时的事件。</p><p>首绘中超过半秒的延迟就会造成用户不满意的风险，并且可以对 app 的评分造成负面影响。越快把 CSS 传递到客户端，就可以越好地优化页面的首绘时间。</p><h3 id="战胜-CSS-render-block"><a href="#战胜-CSS-render-block" class="headerlink" title="战胜 CSS render-block"></a>战胜 CSS render-block</h3><p>基于 HTTP&#x2F;2 的应用程序,可以并行加载多个 HTML, CSS 和 JS 文件。HTTP&#x2F;1.1 不具备这种功能。大部分现代浏览器和网站都已经支持 HTTP&#x2F;2,这最大程度地减少了由等待其他文件加载引起的渲染阻塞。</p><img src="/2023/03/07/fan-yi-css-vs-css-in-js/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.avif" class=""><p>但是渲染阻塞除了文件加载速度还有其他原因。</p><p>我们假设 app 的一个页面有许多 CSS。这个页面可能包含了很多存在但是没有被使用的选择器，因为我们在每个页面都导入了一个主 CSS 文件。</p><p>上面这个场景基本描述了我们是如何习惯直接使用我们创建的 <a href="https://blog.logrocket.com/comparing-tailwind-css-bootstrap-time-ditch-ui-kits/">CSS UI 框架或者 UI 工具箱</a>来快速促进我们的设计系统。并非所有从框架或者工具箱引用的样式都会在每个页面内被使用。结果就是我们最终为这个页面生成的 CSS 样式里出现了更多的垃圾。</p><p>CSS 越多,浏览器构建 CSSOM 的时间越长，这会导致完全没有必要的渲染阻塞。</p><p>为了遏制这种局面,把 CSS 分割成小代码块非常有用。换句话说,把全局样式和必要的 CSS 保存在一个全局文件中，然后将其他内容组件化。这种策略更有意义且解决了不必要的非必要 CSS 阻塞：</p><img src="/2023/03/07/fan-yi-css-vs-css-in-js/img2-Project-structure-componentized-CSS.avif" class=""><p>上面这张图展示了在 React 中为各个组件创建和管理局部 CSS 文件的传统方式。因为每个 CSS 文件是直接附加在各自的组件上,所以它只在相关组件被导入的时候被导入，在组件被移除的的时候消失。</p><p>目前，这个方法还有不足之处。假设 app 包含 100 个组件，同一个项目中的其他开发者可能在这些 CSS 文件中已经不小心使用了一样的类名。</p><p>在这里,每个组件的每个 CSS 文件的范围都是全局的，所以这些不小心重复的样式会不断相互覆盖并被全局应用。像这样的场景会引起严重的布局和设计不一致。</p><p>据说 CSS-in-JS 可以解决这个作用域问题。接下来的文章在高层次上回顾了 CSS-in-JS，并讨论了它是否一劳永逸地有效地解决了作用域问题。</p><h2 id="CSS-in-JS-提供了什么"><a href="#CSS-in-JS-提供了什么" class="headerlink" title="CSS-in-JS 提供了什么"></a>CSS-in-JS 提供了什么</h2><p>CSS-in-JS 简单来说就是外部功能层，它可以让你通过 JavaScript 为组件编写 CSS 属性。</p><p>这一切起源于 2015 年一个叫做 <a href="https://cssinjs.org/?v=v10.10.0">JSS</a> 的库，当然这个库现在仍然处于活跃的维护状态。你必须使用 JavaScript 语法给选择器提供 CSS 属性，一旦页面加载后就会自动把这些属性应用到他们各自的选择器。</p><p>当 JavaScript 使用类似 React 的库接管渲染和管理前端的时候，一个叫做 <a href="https://blog.logrocket.com/how-style-react-router-links-styled-components/">styled-components</a> 的 CSS-in-JS 解决方案出现了。另外一个快速流行的解决方案是使用 Emotion 库做同样的事。</p><p>我们打算用 styled-components 库演示 CSS-in-JS 的示例用例，因为他是在 React 生态中使用 CSS-in-JS 方案中最流行的。</p><h3 id="通过-styled-components-使用-CSS-in-JS-的例子"><a href="#通过-styled-components-使用-CSS-in-JS-的例子" class="headerlink" title="通过 styled-components 使用 CSS-in-JS 的例子"></a>通过 styled-components 使用 CSS-in-JS 的例子</h3><p>在 React app 中使用下面的 Yarn 命令安装 styled-components 库。如果你使用的是不同的包管理器,可以查看 styled-components 安装文档找到合适的安装命令：</p><pre><code class="bash">yarn add styled-components</code></pre><p>安装完 styled-components 库之后,导入 styled 函数，按如下代码使用：</p><pre><code class="jsx">import styled from &quot;styled-components&quot;;const StyledButton = styled.a`  padding: 0.75em 1em;  background-color: $&#123;(&#123; primary &#125;) =&gt; (primary ? &quot;#07c&quot; : &quot;#333&quot;)&#125;;  color: white;  &amp;:hover &#123;    background-color: #111;  &#125;`;export default StyledButton;</code></pre><p>如果你没有 React 环境，<a href="https://codepen.io/_rahul/pen/oNywWXR">这里</a>有一个运行上述代码的链接：</p><p>上面的代码演示了如何在 React 中给一个 button-link 组件添加样式。添加完样式的组件现在可以不用担心样式问题在任意地方被导入并被直接用来构建一个功能组件：</p><pre><code class="bash">import StyledButton from &#39;./components/styles/Button.styled&#39;;function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      ...      &lt;StyledButton href=&quot;...&quot;&gt;Default Call-to-action&lt;/StyledButton&gt;      &lt;StyledButton primary href=&quot;...&quot;&gt;Primary Call-to-action&lt;/StyledButton&gt;    &lt;/div&gt;  );&#125;export default App;</code></pre><p>注意：应用到 styled 组件上的样式是局部范围的,这消除了需要留心 CSS 类命名和全局范围的繁琐需求。除此之外，我们可以基于提供给组件的 props 或者 app 功能所需的任何其他逻辑动态添加或移除 CSS。</p><h2 id="CSS-in-JS-的好处"><a href="#CSS-in-JS-的好处" class="headerlink" title="CSS-in-JS 的好处"></a>CSS-in-JS 的好处</h2><p>比起 CSS 类,JavaScript 开发者可能更喜欢使用 CSS-in-JS 来写样式。CSS-in-JS 解决的最大问题是全局作用域。如果你是 JavaScript 开发者的话，它其他的一些优势也非常有意义。</p><p>现在让我们开始探索这些优势中的一部分。</p><h3 id="没有作用域和特异性问题"><a href="#没有作用域和特异性问题" class="headerlink" title="没有作用域和特异性问题"></a>没有作用域和特异性问题</h3><p>由于样式只能在局部范围内使用，所以他们不容易和其他组件的样式冲突。你甚至不需要担心使用严格的命名来避免样式冲突。</p><p>专门为一个组件写的样式不需要预先考虑子选择器，所以特异性问题很少。</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>条件 CSS 是 CSS-in-JS 的另外一个高光点。如同上面演示的按钮示例一样，比起为每个变动写一个单独的样式，检查 props 值并且添加合适的样式是更酷的一种方法。</p><h3 id="更少的-CSS-特异性"><a href="#更少的-CSS-特异性" class="headerlink" title="更少的 CSS 特异性"></a>更少的 CSS 特异性</h3><p>CSS-in-JS 帮助你把 CSS 声明的特异性保持在最低水平，因为你唯一使用它的样式的途径就是元素本身。这同样适用于创建组件变体，你可以检查 prop 对象值并且在需要的时候添加动态样式。</p><h3 id="容易的主题"><a href="#容易的主题" class="headerlink" title="容易的主题"></a>容易的主题</h3><p>使用自定义 CSS 属性为 app 设置主题非常有意义。在最后，你必须转到 JavaScript 侧，基于用户输入写一些逻辑代码来切换和记住主题。</p><p>CSS-in-JS 让你可以完全使用 JavaScript 编写主题逻辑。借助 styled-components 的 ThemeProvider wrapper，你可以快速为组件的主题进行颜色编码。下面借<a href="https://codepen.io/_rahul/pen/qBKXevo">这个案例</a>来查看使用 styled-components 定制主题：</p><h3 id="无痛维护"><a href="#无痛维护" class="headerlink" title="无痛维护"></a>无痛维护</h3><p>考虑到 CSS-in-JS 提供的特性和优势，JavaScript 可能会发现 CSS-in-JS 比管理上百个 CSS 文件更方便。</p><p>但是有一个遗留事实是：只有对 JavaScript 和 CSS 都有很深的理解,才能高效管理和维护由 CSS-in-JS 驱动的大型项。</p><h2 id="CSS-in-JS-的坏处"><a href="#CSS-in-JS-的坏处" class="headerlink" title="CSS-in-JS 的坏处"></a>CSS-in-JS 的坏处</h2><p>CSS-in-JS 确实非常完美的解决了作用域问题。但是就像我们一开始讨论的那样，我们会面临更大的挑战——比如渲染阻塞——这会直接影响用户体验。除此之外，CSS-in-JS 的概念还需要处理一些其他的问题。</p><h3 id="延迟渲染"><a href="#延迟渲染" class="headerlink" title="延迟渲染"></a>延迟渲染</h3><p>CSS-in-JS 会执行 JavaScript 来从 JavaScript 组件中解析 CSS,然后把这些转换出来的样式注入 DOM。组件越多，浏览器首绘的时间就越长。</p><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><p>CSS 缓存经常被用来改善连续页面加载时间。当使用 CSS-in-JS 的时候由于没有 CSS 文件,缓存变成了一个大问题。而且。动态生成 CSS 类名让这个问题变得更复杂。</p><h3 id="CSS-预处理器支持度"><a href="#CSS-预处理器支持度" class="headerlink" title="CSS 预处理器支持度"></a>CSS 预处理器支持度</h3><p>借助组件化的 CSS 方法,很容易添加像<a href="https://blog.logrocket.com/how-to-write-reusable-css-with-sass/">SASS</a>, Less, PostCSS 和其他的预处理的支持。而在 CSS-in-JS 中，这是不可能的。</p><h3 id="凌乱的-DOM"><a href="#凌乱的-DOM" class="headerlink" title="凌乱的 DOM"></a>凌乱的 DOM</h3><p>CSS-in-JS 的基础是将所有的样式定义从 JavaScript 解析为基础 CSS，然后使用样式块将样式注入 DOM 中。</p><p>对于每个使用 CSS-in-JS 进行样式编写的组件来说,可能首先就会有 100 个样式块需要解析然后注入。简单来说就是会有更多的间接成本。</p><h3 id="库依赖"><a href="#库依赖" class="headerlink" title="库依赖"></a>库依赖</h3><p>如同我们所知道的那样，我们可以使用外部库添加 CSS-in-JS 功能。许多 JavaScript 将在实际的 CSS 解析之前被包含并运行，因为从 JavaScript 到 CSS 样式的解析取决于像 styled-components 这样的库。</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>CSS-in-JS 缺失很多 CSS 和 SCSS 与生俱来的特性。对于已经习惯了 CSS 和 SCSS 的开发者来说适应 CSS-in-JS 将会非常有挑战性</p><h3 id="没有大规模的支持"><a href="#没有大规模的支持" class="headerlink" title="没有大规模的支持"></a>没有大规模的支持</h3><p>目前大部分 UI 库和组件库都不支持 CSS-in-JS 方式，因为它仍然有许多问题需要解决</p><p>上面讨论的问题可能会累积在一起，导致产品性能低、难以维护，并存在若干 UI 和 用户体验不一致的问题。</p><h2 id="什么情况下推荐使用-CSS-in-JS"><a href="#什么情况下推荐使用-CSS-in-JS" class="headerlink" title="什么情况下推荐使用 CSS-in-JS"></a>什么情况下推荐使用 CSS-in-JS</h2><p>当你处理一个较小的应用并且性能优先级要求不高的话， CSS-in-JS 是一个理想的解决方案。在处理具有庞大设计系统的性能要求高的应用时，它可能并不理想。</p><p>随着 app 逐渐变大，考虑到这个概念的所有缺点，使用 CSS-in-JS 会很容易变得复杂，把一个设计系统转化为 CSS-in-JS 有许多工作要做，从我的角度来看，没有 JavaScript 开发者会想要处理这种情况。</p><h2 id="CSS-Module-概览"><a href="#CSS-Module-概览" class="headerlink" title="CSS Module 概览"></a>CSS Module 概览</h2><p><a href="https://blog.logrocket.com/a-deep-dive-into-css-modules/">CSS Module</a>是一个 CSS 文件，里面所有的属性在已经渲染的 CSS 中默认都被限制在局部范围内。JavaScript 进一步处理 CSS Module 文件并且封装他们的样式声明来解决作用域问题。</p><p>为了使用 CSS Module，你需要把 CSS 文件扩展名修改为<code>.module.css</code>,然后将他们导入 JavaScript 文件中。下面的代码片段提供了一个如何使用 CSS Module 的例子：</p><pre><code class="jsx">import styles from &quot;./Button.module.css&quot;;export default function Button(props) &#123;  return (    &lt;a href=&#123;props.href ? props.href : &quot;#&quot;&#125; className=&#123;styles.btn&#125;&gt;      &#123;props.name&#125;    &lt;/a&gt;  );&#125;</code></pre><p>看这个在 React 中实现 CSS Module 的<a href="https://stackblitz.com/edit/react-hbivvp?file=src/components/AnotherButton/AnotherButton.jsx">示例</a>。这个例子展示了如何使用 CSS Module 修复作用域问题。</p><p>在这个例子里,请注意如何智能地处理和优化 Button.module.css 和 AnotherButton.module.css 的相同类名来防止命名冲突。</p><h2 id="CSS-Module-的好处"><a href="#CSS-Module-的好处" class="headerlink" title="CSS Module 的好处"></a>CSS Module 的好处</h2><p>CSS Module 提供的最大的好处就是摆脱对 CSS in-JS 的依赖解决范围和特异性问题。如果我们可以通过保持尽可能传统 CSS 来解决作用域和特异性问题，那么 CSS-in-JS 的工作量会比必要的工作量大。</p><h3 id="没有作用域和特异性问题-1"><a href="#没有作用域和特异性问题-1" class="headerlink" title="没有作用域和特异性问题"></a>没有作用域和特异性问题</h3><p>就像上面演示的示例一样，CSS Module 成功解决了我们遇到的传统旧式的 CSS 作用域问题。。由于规则是松散地编写在 CSS 模块文档中的，因此很少观察到任何特异性问题。</p><h3 id="有组织的代码"><a href="#有组织的代码" class="headerlink" title="有组织的代码"></a>有组织的代码</h3><p>保留各自单独的 CSS 文件似乎是一个限制。但是这个方法确实促进了更好的组织组件。举例来说，这就是我如何通过把他们分到各自的文件夹下来组织组件：</p><pre><code class="bash">- Project  - src    - components      - Button          - Button.jsx          - Button.modules.css      - Carousel          - Carousel.jsx          - Carousel.modules.css</code></pre><h3 id="缓存的可能"><a href="#缓存的可能" class="headerlink" title="缓存的可能"></a>缓存的可能</h3><p>最终构建生成的极简化的 CSS 文件可以被浏览器缓存，从而改善连续页面加载时间。</p><h3 id="CSS-预处理"><a href="#CSS-预处理" class="headerlink" title="CSS 预处理"></a>CSS 预处理</h3><p>添加对 CSS 预处理器（如 PostCSS，SASS，Less 等）的支持很容易。但是必须依赖额外的包来做这个事情。</p><h3 id="零学习曲线"><a href="#零学习曲线" class="headerlink" title="零学习曲线"></a>零学习曲线</h3><p>If you know how CSS works, you can use CSS Module without learning anything new besides the few points that we discussed above in the intro segment.<br>如果你知道 CSS 是怎么工作的就能使用 CSS Module，除了上面介绍部分讨论的几点外你几乎不用学习任何新的东西。</p><h3 id="强大的支持"><a href="#强大的支持" class="headerlink" title="强大的支持"></a>强大的支持</h3><p>你不需要添加任何额外的包就能使用 CSS Module。所有的主流框架和库都提供了内置的支持。</p><h2 id="CSS-Module-的坏处"><a href="#CSS-Module-的坏处" class="headerlink" title="CSS Module 的坏处"></a>CSS Module 的坏处</h2><p>尽管 CSS Modue 提供了许多好处，但是他还不是一个完美的解决方案。以下是一些需要牢记的注意事项。</p><h3 id="非标准的-global-属性"><a href="#非标准的-global-属性" class="headerlink" title="非标准的 :global 属性"></a>非标准的 <code>:global</code> 属性</h3><p>当在全局作用域内定位选择器的时候，你必须使用<code>:global</code>规则。这不是 CSS 规范的一部分，但是被 JavaScript 用它来标记全局样式。</p><h3 id="没有动态样式"><a href="#没有动态样式" class="headerlink" title="没有动态样式"></a>没有动态样式</h3><p>借助 CSS Module，所有的声明都会进入单独的 CSS 文件。因此不可能像 CSS-in-JS 一样实现动态样式，因为我们不能在 CSS 文件中实现任何 JavaScript。</p><h3 id="外部的-CSS-文件"><a href="#外部的-CSS-文件" class="headerlink" title="外部的 CSS 文件"></a>外部的 CSS 文件</h3><p>你不能省略组件中带有 CSS 模块的 CSS 文件的用法。使用 CSS 模块的唯一可能方法是维护和导入外部 CSS 文档。</p><h3 id="TypeScript-限制"><a href="#TypeScript-限制" class="headerlink" title="TypeScript 限制"></a>TypeScript 限制</h3><p>为了在 TypeScript 下使用 CSS Module,你必须在<code>index.d.ts</code>中添加 module 定义或者使用<a href="https://blog.logrocket.com/how-to-configure-css-modules-webpack/">webpack loader</a>：</p><pre><code class="typescript">/** index.d.ts **/declare module &quot;*.module.css&quot;; // TS module for CSS Module filesdeclare module &quot;*.module.scss&quot;; // TS module for CSS Module files in SCSS format</code></pre><h2 id="推荐使用-CSS-Module-的场景"><a href="#推荐使用-CSS-Module-的场景" class="headerlink" title="推荐使用 CSS Module 的场景"></a>推荐使用 CSS Module 的场景</h2><p>如果你应用 UI 规模大并且对性能要求严苛，CSS Module 是一个非常好的选择。由于 CSS Module 提供的每个东西最终都是基于传统的,非实验性的用法，所以这个方法让监控和修复性能变得更容易。<br>CSS Module 文件非常容易适应你选择的任意 CSS 框架的代码，因为你需要处理的只有 CSS。就像前面说的，基础的 CSS 对于这个任务来说已经足够了。</p><h2 id="现代-CSS-特性"><a href="#现代-CSS-特性" class="headerlink" title="现代 CSS 特性"></a>现代 CSS 特性</h2><p>在介绍里，我提到了一些现代化的 CSS 特性在未来不需要依赖 CSS Module，CSS-in-JS 或者其他的一些 JavaScript 解决方案的情况下是如何协助解决作用域问题的。</p><p>新的并且正在计划中的特性——例如作用域指令和@scope 伪元素——旨在使用传统的 CSS 解决老问题。反之，这也会减少开发者转向类似 CSS-in-JS 作为这些缺陷的变通方法的需求</p><p>让我们看一下目前的 scoped CSS 草案是如何解决 CSS-in-JS 甚至 CSS Module 的问题。对于其他的 CSS 属性的完整列表，查看<a href="https://web.dev/state-of-css-2022/">the State of CSS 2022</a></p><h3 id="CSS-作用域的潜在可能性"><a href="#CSS-作用域的潜在可能性" class="headerlink" title="CSS 作用域的潜在可能性"></a>CSS 作用域的潜在可能性</h3><p>在从 CSS 规范中奇怪的引入和移除<style scope>之后，当前的 Scope CSS 草案看上去已经足够优秀到去通过编写 CSS 规则来定义元素的作用域前提。<br>Its current status involves using a directive and a pseudo-class to control the provision of scoping for a given element. Here is a rough picture of how it will lock an element’s scope within a boundary and maintain it regardless of the cascade’s rules of scoping:<br>目前的状态涉及了使用指令和伪类来控制一个给定的元素的作用域。这里是一个如何将元素的作用域锁定在边界内并维护它的粗略图片，而不管级联的作用域规则如何：</p><pre><code class="html">&lt;div class=&quot;card&quot;&gt;  &lt;img src=&quot;...&quot; /&gt;  &lt;div class=&quot;content&quot;&gt;    &lt;p&gt;...&lt;/p&gt;  &lt;/div&gt;  &lt;!-- .content --&gt;&lt;/div&gt;&lt;!-- .card --&gt;&lt;style&gt;  @scope (.card) &#123;    :scope &#123;      display: grid;      ...;    &#125;    img &#123;      object-fit: cover;      ...;    &#125;    .content &#123;      ...;    &#125;  &#125;&lt;/style&gt;</code></pre><p>这个新特性也许会消除对于 CSS Module 或者 CSS-in-JS 解决作用域问题的需求。我们拭目以待，等它在我们的浏览器中可以使用的那一天。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，我们首先提到了对于web应用来说，CSS 渲染阻塞是一个主要的性能问题。然后讨论了修复这些问题的部分解决方案，这促使我们探索 CSS-in-JS、CSS Module以及新作用域 CSS 功能的官方进度草案的当前状态。</p><p>开发者喜欢JavaScript，爱CSS-in-JS是因为它用JavaScript覆盖了几乎所有的样式角度。另一方面，这些喜欢CSS的——并且想让当前的技术能支持开发者和终端用户同样也许会更喜欢CSS Module。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-go函数参数默认值</title>
      <link href="/2023/02/23/fan-yi-go-han-shu-can-shu-mo-ren-zhi/"/>
      <url>/2023/02/23/fan-yi-go-han-shu-can-shu-mo-ren-zhi/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://medium.com/@func25/golang-secret-how-to-add-default-values-to-function-parameters-60bd1e9625dc">https://medium.com/@func25/golang-secret-how-to-add-default-values-to-function-parameters-60bd1e9625dc</a></p><h2 id="GloLang-小技巧：如何给-Function-参数添加默认值"><a href="#GloLang-小技巧：如何给-Function-参数添加默认值" class="headerlink" title="GloLang 小技巧：如何给 Function 参数添加默认值?"></a>GloLang 小技巧：如何给 Function 参数添加默认值?</h2><p><img src="https://cdn-images-1.medium.com/max/4044/1*7PBtpnlYoSLWJMSOliQweQ.png"></p><p>你曾经因为 Go 没有默认参数值而感到苦恼吗?事实上你不是唯一一个!这种烦人的限制会让你的代码写起来单调乏味，读起来也更困难。</p><p>一直以来,你不得不写额外的代码来检测某个参数是否有被提供，如果没有的话要使用一个默认值赋给这个参数。</p><p>别担心!现在已经有方法来避开这些限制并且能添加默认值到 Go Function 里面。当然肯定不会像内置的方法那样方便,但是至少你不需要一直背负着限制。</p><p>Golang 小技巧系列:</p><ul><li><p>GloLang 小技巧：如何给 Function 参数添加默认值? (当前篇)</p></li><li><p><a href="https://medium.com/@func25/golang-technique-custom-struct-tag-technique-in-go-8667bf7da457">GloLang 小技巧: 自定义结构标签比如 <code>json:”name”</code></a></p></li></ul><h2 id="简单的-wrapper"><a href="#简单的-wrapper" class="headerlink" title="简单的 wrapper"></a>简单的 wrapper</h2><p>完成这件事的方法之一就是定义一个 wrapper 函数,在这个函数里将默认值作为参数调用原始函数。<br>如果客户端没有指明 name,默认的 name 就是”Aiden””。下面是一个使用 wrapper 的案例：</p><pre><code class="go">    func greet(name string) string &#123;     return &quot;Hello, &quot; + name    &#125;    func greetWithDefaultAiden(name string) string &#123;     if name == &quot;&quot; &#123;      name = &quot;Aiden&quot;     &#125;     return greet(name)    &#125;    // you can have more than 1 default set    func greetWithDefaultJohn(name string) string &#123;     if name == &quot;&quot; &#123;      name = &quot;John&quot;     &#125;     return greet(name)    &#125;</code></pre><p>通过这种方式，可以在不修改 greet 函数内部的代码的情况下，为 greet 函数设置默认参数值。</p><blockquote><p>“但是这对于一个简单的函数来说是不是太臃肿了?”</p></blockquote><p>这是一个不利之处，因为它需要你写一些额外的代码，这会让代码的可读性变差。</p><h2 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h2><p>我们可以把函数的惨呼放在一个未导出的 struct 中，允许客户端按照需要初始化这些参数：</p><pre><code class="go">  type greetingArguments struct &#123;    Name string    Age  int  &#125;  func GreetingArguments() greetingArguments &#123;    return greetingArguments&#123;    Name: &quot;Aiden&quot;,    Age:  30,    &#125;  &#125;</code></pre><p>现在定义 Greet 函数:</p><pre><code class="go">    func Greet(options greetingArguments) string &#123;      return &quot;Hello, my name is &quot; + options.Name + &quot; and I am &quot; + strconv.Itoa(options.Age) + &quot; years old.&quot;    &#125;</code></pre><p>每次客户端想要使用 Greet 函数的时候,他们就必须使用 GreetingArguments()函数来创建一个 greetingArguments 类型的 struct。</p><p>这个方法只有在在从包外而不是包内调用函数时有效。</p><p>另外一个选择就是使用 functional options pattern，它可以让你向函数传递数量可变的选项作为参数。这个方法更灵活，代码可读性也更好，但是也会让你的代码更加复杂。</p><h2 id="Functional-options-pattern-功能选项模式"><a href="#Functional-options-pattern-功能选项模式" class="headerlink" title="Functional options pattern 功能选项模式"></a>Functional options pattern 功能选项模式</h2><p>这个模式已经被很多库采用了。在本章节中，我会一步一步带你体验如何使用它：</p><ol><li>创建一个 struct,保存有两个字段的参数：Name 和 age。</li></ol><pre><code class="go">type GreetingOptions struct &#123;  Name string  Age int&#125;</code></pre><ol start="2"><li>现在顶一个 Greet 函数，将新的 struct 作为一个参数:</li></ol><pre><code class="go">func Greet(options GreetingOptions) string &#123;  return &quot;Hello, my name is &quot; + options.Name + &quot; and I am &quot; + strconv.Itoa(options.Age) + &quot; years old.&quot;&#125;</code></pre><ol start="3"><li>为 struct 中的字段定义功能选项是很有趣的内容:</li></ol><pre><code class="go">type GreetingOption func(*GreetingOptions)func WithName(name string) GreetingOption &#123;  return func(o *GreetingOptions) &#123;    o.Name = name  &#125;&#125;func WithAge(age int) GreetingOption &#123;  return func(o *GreetingOptions) &#123;    o.Age = age  &#125;&#125;</code></pre><ol start="4"><li>使用新类型<strong>GreetingOption</strong> 创建 wrapper:</li></ol><pre><code class="go">func GreetWithDefaultOptions(options ...GreetingOption) string &#123;  opts := GreetingOptions&#123;    Name: &quot;Aiden&quot;,    Age: 30,  &#125;  for _, o := range options &#123;    o(&amp;opts)  &#125;  return Greet(opts)&#125;</code></pre><p>GreetWithDefaultOptions 函数为 GreetingOptions struct 的 Name(&#x3D; “Aiden”)和 Age (&#x3D; 30) 字段设置了默认值，然后将作为参数传递的选项应用到该 struct。</p><p>最后，使用修改后的 struct 作为参数调用 Greet 函数</p><p>为了使用这段代码，你可以调用使用你需要的选项调用 GreetWithDefaultOptions 函数：</p><pre><code class="go">  greeting := GreetWithDefaultOptions(WithName(&quot;Alice&quot;), WithAge(20))  // &quot;Hello, my name is Alice and I am 20 years old.&quot;</code></pre><p>许多库都使用了 功能选项模式，这其中包括 mongodb, aws-sdk-go, gorm, cli 和许多其他的库</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web服务构建</title>
      <link href="/2023/02/22/web-fu-wu-gou-jian/"/>
      <url>/2023/02/22/web-fu-wu-gou-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="iam-api-server-服务"><a href="#iam-api-server-服务" class="headerlink" title="iam-api-server 服务"></a>iam-api-server 服务</h2><p>本质：web 服务,通过一个名为 iam-api_server 的进程，对外提供 RESTful API 接口，完成用户、密钥、策略三种 REST 资源的增删改查。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="认证相关接口"><a href="#认证相关接口" class="headerlink" title="认证相关接口"></a>认证相关接口</h4><img src="/2023/02/22/web-fu-wu-gou-jian/authn.webp" class=""><h4 id="用户相关接口"><a href="#用户相关接口" class="headerlink" title="用户相关接口"></a>用户相关接口</h4><img src="/2023/02/22/web-fu-wu-gou-jian/user.webp" class=""><h4 id="密钥相关接口"><a href="#密钥相关接口" class="headerlink" title="密钥相关接口"></a>密钥相关接口</h4><img src="/2023/02/22/web-fu-wu-gou-jian/key.webp" class=""><h4 id="策略相关接口"><a href="#策略相关接口" class="headerlink" title="策略相关接口"></a>策略相关接口</h4><img src="/2023/02/22/web-fu-wu-gou-jian/policy.webp" class=""><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>客户端【前端，API 调用，SDK,iamctl】都可以访问 iam-api_server，最终都会执行 HTTP 请求，调用 iam-api_server 提供的 RESTful API 接口,所以需要一个 REST API 客户端工具——curl 来执行 HTTP 请求。</p><pre><code class="plain">-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法-H/--header                           指定请求的 HTTP Header-d/--data                             指定请求的 HTTP 消息体（Body）-v/--verbose                          输出详细的返回信息-u/--user                             指定账号、密码-b/--cookie                           读取 cookie-s/--silent                           安静模式-S                                    强制展示错误</code></pre><ol><li>登录 api-server,获取 token</li></ol><pre><code class="bash">$ curl -s -XPOST -H&quot;Authorization: Basic `echo -n &#39;admin:Admin@2021&#39;|base64`&quot; http://127.0.0.1:8080/login | jq -r .token# 将token设置为环境变量TOKEN=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2MzUwNTk4NDIsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2MjcyODM4NDIsInN1YiI6ImFkbWluIn0.gTS0n-7njLtpCJ7mvSnct2p3TxNTUQaduNXxqqLwGfI</code></pre><ol start="2"><li>创建一个名为 secret0 的 secret</li></ol><pre><code class="bash">curl -v -XPOST -H &quot;Content-Type: application/json&quot; -H&quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -d&#39;&#123;&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;secret0&quot;&#125;,&quot;expires&quot;:0,&quot;description&quot;:&quot;admin secret&quot;&#125;&#39; http://iam.api.marmotedu.com:8080/v1/secrets</code></pre><ol start="3"><li>获取 secret0 的详细信息</li></ol><pre><code class="bash">curl -XGET -H&quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; http://iam.api.marmotedu.com:8080/v1/secrets/secret0</code></pre><ol start="4"><li>更新 secret0 的描述</li></ol><pre><code class="bash">curl -XPUT -H&quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; -d&#39;&#123;&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;secret&quot;&#125;,&quot;expires&quot;:0,&quot;description&quot;:&quot;admin secret(modify)&quot;&#125;&#39; http://iam.api.marmotedu.com:8080/v1/secrets/secret0</code></pre><ol start="5"><li>获取 secret 列表</li></ol><pre><code class="bash">curl -XGET -H&quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; http://iam.api.marmotedu.com:8080/v1/secrets</code></pre><ol start="6"><li>删除 secret0s</li></ol><pre><code class="bash">curl -XDELETE -H&quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; http://iam.api.marmotedu.com:8080/v1/secrets/secret0</code></pre><p>CRUD:<br>C：创建<br>R：获取数据<br>U：修改更新<br>D：删除</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-chatGPT</title>
      <link href="/2023/02/21/fan-yi-chatgpt/"/>
      <url>/2023/02/21/fan-yi-chatgpt/</url>
      
        <content type="html"><![CDATA[<h2 id="一份面向起步用户的chatGPT指南：理解他是什么？他为什么非常有意义，以及何时-x2F-何地使用它。"><a href="#一份面向起步用户的chatGPT指南：理解他是什么？他为什么非常有意义，以及何时-x2F-何地使用它。" class="headerlink" title="一份面向起步用户的chatGPT指南：理解他是什么？他为什么非常有意义，以及何时&#x2F;何地使用它。"></a>一份面向起步用户的chatGPT指南：理解他是什么？他为什么非常有意义，以及何时&#x2F;何地使用它。</h2><p><img src="https://cdn-images-1.medium.com/max/2000/0*bFu1qQNJn5YloboI.png"></p><h3 id="什么是ChatGPT"><a href="#什么是ChatGPT" class="headerlink" title="什么是ChatGPT?"></a><strong>什么是ChatGPT?</strong></h3><p>ChatGPT,是chat-based Generative Pre-trained Transformer的缩写，它是一个强大的工具，可以跨领域以各种各样的方式被用来提高生产力。</p><p>ChatGPT是一种人工智能(AI)科技，它作为<a href="https://en.wikipedia.org/wiki/Natural_language_processing">自然语言处理</a> (NLP)模型被认识，它是由AI研究和开发公司<a href="https://openai.com/">OpenAI</a>创建的。它使用机器学习算法来分析和理解被写出来或读出来的语言，然后基于输入生成相应内容。ChatGPT接受了难以置信的海量文本数据训练，这让它可以理解上下文和单词和短语的意思，生成高度相关的情境响应。</p><h3 id="为什么ChatGPT非常有意义"><a href="#为什么ChatGPT非常有意义" class="headerlink" title="为什么ChatGPT非常有意义?"></a>为什么ChatGPT非常有意义?</h3><p>你真的必须<a href="https://chat.openai.com/">体验一下</a>才能完全理解它的潜力，但是我将尝试用类比或者比喻的方式来解释。如果你看过钢铁侠电影，你可能对Tony Starrk非常信任的AI助手 Jarvis感觉非常熟悉。你可以把chatGPT认为是年轻版本的Jarvis。ChatGPT 可以非常高效地用于以高度精确的方式最大限度地收集、总结、提炼、修改和验证信息。 可以说是一种能量增强器。</p><h3 id="如何使用-ChatGPT"><a href="#如何使用-ChatGPT" class="headerlink" title="如何使用 ChatGPT"></a><strong>如何使用 ChatGPT</strong></h3><p>ChatGPT (在写这篇文章的时候) 可以通过web上的网页 <a href="https://chat.openai.com/">chat.openai.com</a>自由访问。使用它你只需要简单地创建一个账号，登录然后开始在聊天箱中输入你的提示。</p><p>当制定一个问题询问chatGPT的时候，为了获取最准确和关联度最高的回应，简明扼要是非常重要的。这意味着你需要避开含糊不清或者模棱两可的语言，提供具体细节和指令让chatGPT生成回应内容。</p><p>体验chatGPT强大能力的方法之一就是提出后续问题来完善它为您提供的回复。<br>**比如：</p><blockquote><p> “为软件服务生成一个商业灵感”</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2316/1*yLEDyWYiz_KOSVM-rS1fiw.png"></p><blockquote><p> “现在请为这个灵感创建一份有6个段落的商业计划书，着重强调商品特征”</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*7n0sDaOolngcQ0pqHmCNxA.png"></p><blockquote><p> “现在请为这项业务创建一个不超过一段的电梯游说，并强调对客户的好处”</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*TLxW_YVpLkEI_ch5c7Q4Uw.png"></p><p>正如你所见，追问让你提炼了初次响应的内容，并且获得了更多具体和详细的信息。</p><p>另外一个提炼chatGPT响应内容的方式是提供额外的文本或者信息。比如，如果你问chatGPT,”你能用图表和图形生成我们季度销售数据的报告吗？”，你可以提供额外的细节，类似你想在报告里包含的销售数据的时间段和具体的图表类型。这个额外的信息可以帮助chatGPT生成更准确和相关的回应。</p><p>总之，获取到更多chatGPTd的输出的关键是：提供清晰，简介具体的的查询语句，渐进式的问题和额外的上下文来细化相应内容。</p><h3 id="何处-x2F-何时使用-ChatGPT"><a href="#何处-x2F-何时使用-ChatGPT" class="headerlink" title="何处&#x2F;何时使用 ChatGPT"></a>何处&#x2F;何时使用 ChatGPT</h3><p>GPTChat 之所以如此强大，是因为它可以扩展到广泛的用途。 无论是数学问题还是会计问题、生成报告、演示脚本、博客文章、教程、上述业务计划或代码片段等，有近乎无穷的可能性。</p><p>为了帮助你了解可以从哪里开始，这里有八个种类可以使用 ChatGPT 来提高效率和生产力：</p><ol><li><strong>邮件回复:</strong>  chatGPT可以用来生成定制化和吸引人的电子邮件回复，节省时间和确保重要的信息可以迅速和专业地被回应。举个例子，你可以问chatGPT,”有没有什么礼貌且专业的方式回复这个邮件请求?”。</li><li><strong>文档生成:</strong>  chatGPT可以提供一些关键细节然后让chatGPT做剩下的工作的方式来生成文档，比如报告,展示和提案。比如，你可以问”你能用图表和图形生成季度销售数据的报告吗?”</li><li><strong>数据分析:</strong> chatGPT可以分析大量的数据，确定关键趋势和观点，帮助团队做出更好的数据驱动的决定。比如，你可以问”在过去十年我们的销售数据里关键趋势是什么?”</li><li><strong>客户服务:</strong> chatGPT可以处理常规的客户咨询，提供及时和准确的回应，从而使客户服务代表腾出时间来专注于更复杂和更具挑战性的问题。 比如你可以问 ChatGPT，”处理客户投诉缺陷产品的最佳方法是什么?”</li><li><strong>项目管理：</strong> chatGPT可以管理项目任务和截止时间，让团队成员信息灵通，按计划完成重要的里程碑和截止期。比如你可以问：”我们项目的下一步是什么，什么时候结束?”</li><li><strong>商业理念&amp; 计划:</strong> ChatGPT 还可以通过提供一些关于行业和市场的细节，让 ChatGPT 生成潜在的概念和想法，从而产生新的商业构思。这可以帮助企业家和商业领袖为新产品、服务和企业产生创造性和创新性的想法。比如你可以问：”能为新的健康行业的软件服务生成新的商业想法么？”</li><li><strong>代码生成和调试:</strong> ChatGPT 还可用于生成代码并识别和修复现有代码中的错误。通过提供有关所需功能的一些详细信息，ChatGPT 可以生成可由开发人员自定义和完善的工作代码。 此外，ChatGPT 可用于通过识别并提供修复常见编码错误和漏洞的建议来调试代码。 例如，你可以问 ChatGPT，”能否生成一个函数来计算数字列表的平均值，并识别以下代码中的任何语法错误?”</li><li><strong>技术教程：</strong> ChatGPT可用于生成技术教程和文档，提供使用各种软件和工具的分步说明。 这可以节省时间并提高技术教程的准确性和质量，使用户更容易学习和理解复杂的概念和程序。 例如，可以问 ChatGPT，”能否提供有关如何使用 XYZ 软件的教程，包括屏幕截图和每个步骤的清晰说明?”</li></ol><h2 id="注意事项和局限"><a href="#注意事项和局限" class="headerlink" title="注意事项和局限"></a>注意事项和局限</h2><p>现在，ChatGPT 进入了令人难以置信的发展，但它仍然是新兴技术，因此有一些局限性。 ChatGPT 最适合用于内容创作和构思等创造性活动。 它在以下方面仍然不擅长：复杂的数学、解决 SAT 或 IQ 类型的测试问题、从互联网上搜索数据（但是……ChatGPT 当前未连接到开放的互联网）、提供其响应的来源、编写高质量的健壮的代码等</p><p>目前 ChatGPT 应该被视为对未来的一瞥，即人工智能以有意义的方式帮助人类的令人兴奋的未来</p><p>总的来说，ChatGPT 是一个多功能且功能强大的工具，可以通过多种方式使用。 现在还处于早期，但我相信像这样的技术代表了人工智能辅助生产力的范式转变。 ChatGPT 或类似的东西很可能成为任何希望提高产出和效率的人的宝贵工具。<br>那么，接下来你打算用这个天才AI个人助理做什么呢？ 可能性只受您想象力的限制！<br>P.S. - 你刚阅读的内容里面70%是由chatGPT写的😉<br>— — — — — — — — — — — — — — — — — — —</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行框架cobra</title>
      <link href="/2023/02/17/ming-ling-xing-kuang-jia-cobra/"/>
      <url>/2023/02/17/ming-ling-xing-kuang-jia-cobra/</url>
      
        <content type="html"><![CDATA[<p>基于</p><ol><li>Commands 命令</li><li>arguments 非选项参数</li><li>flags 选项参数（即标志）</li></ol><pre><code class="bash"># clone 是一个命令，URL是一个非选项参数，bare是一个选项参数git clone URL --bare </code></pre><h2 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h2><h3 id="使用cobra库"><a href="#使用cobra库" class="headerlink" title="使用cobra库"></a>使用cobra库</h3><ol><li>创建一个 rootCmd——文件cmd&#x2F;root.go</li></ol><pre><code class="bash">mkdir -p newApp2 &amp;&amp; cd newApp2var rootCmd = &amp;cobra.Command&#123;  Use:   &quot;hugo&quot;,  Short: &quot;Hugo is a very fast static site generator&quot;,  Long: `A Fast and Flexible Static Site Generator`,  Run: func(cmd *cobra.Command, args []string) &#123;    // Do Stuff Here  &#125;,&#125;func Execute() &#123;  if err := rootCmd.Execute(); err != nil &#123;    fmt.Println(err)    os.Exit(1)  &#125;&#125;</code></pre><ol start="2"><li>创建main.go:调用rootCmd</li></ol><pre><code class="go">package mainimport (  &quot;&#123;pathToYourApp&#125;/cmd&quot;)func main() &#123;  // main.go 中不建议放很多代码，通常只需要调用 cmd.Execute()   cmd.Execute()&#125;</code></pre><ol start="3"><li>添加命令</li></ol><pre><code class="go">package cmdimport (  &quot;fmt&quot;  &quot;github.com/spf13/cobra&quot;)func init() &#123;    // 定义标志和处理配置  cmd/version.go文件  rootCmd.AddCommand(versionCmd)&#125;// rootCmd之外可以调用 AddCommand 添加其他命令var versionCmd = &amp;cobra.Command&#123;  Use:   &quot;version&quot;,  Short: &quot;Print the version number of Hugo&quot;,  Long:  `All software has versions. This is Hugo&#39;s`,  Run: func(cmd *cobra.Command, args []string) &#123;    fmt.Println(&quot;Hugo Static Site Generator v0.9 -- HEAD&quot;)  &#125;,&#125;</code></pre><ol start="4"><li>编译运行<br><code>go build -v .</code></li></ol><h3 id="使用Cobra-命令"><a href="#使用Cobra-命令" class="headerlink" title="使用Cobra 命令"></a>使用Cobra 命令</h3><p>生成一个 Cobra 命令模板，而命令模板也是通过引用 Cobra 库来构建命令的</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><h3 id="使用标志"><a href="#使用标志" class="headerlink" title="使用标志"></a>使用标志</h3><ol><li>使用持久化的标志<br>作用：用于它所分配的命令以及该命令下的每个子命令<br><code>rootCmd.PersistentFlags().BoolVarP(&amp;Verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;verbose output&quot;)</code></li><li>使用本地标志<br>作用：本地标志只能在它所绑定的命令上使用<br><code>rootCmd.Flags().StringVarP(&amp;Source, &quot;source&quot;, &quot;s&quot;, &quot;&quot;, &quot;Source directory to read from&quot;)</code></li><li>将标志绑到viper<br>作用：可以通过viper.Get()获取标志的值</li></ol><pre><code class="go">var author stringfunc init() &#123;  rootCmd.PersistentFlags().StringVar(&amp;author, &quot;author&quot;, &quot;YOUR NAME&quot;, &quot;Author name for copyright attribution&quot;)  viper.BindPFlag(&quot;author&quot;, rootCmd.PersistentFlags().Lookup(&quot;author&quot;))&#125;</code></pre><ol start="4"><li>设置标志为必选</li></ol><pre><code class="go">rootCmd.Flags().StringVarP(&amp;Region, &quot;region&quot;, &quot;r&quot;, &quot;&quot;, &quot;AWS region (required)&quot;)rootCmd.MarkFlagRequired(&quot;region&quot;)</code></pre><h3 id="非选项参数验证"><a href="#非选项参数验证" class="headerlink" title="非选项参数验证"></a>非选项参数验证</h3><p>使用 Command 的 Args 字段来验证非选项参数</p><h4 id="内置验证函数"><a href="#内置验证函数" class="headerlink" title="内置验证函数"></a>内置验证函数</h4><ul><li>NoArgs：如果存在任何非选项参数，该命令将报错。</li><li>ArbitraryArgs：该命令将接受任何非选项参数。</li><li>OnlyValidArgs：如果有任何非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。</li><li>MinimumNArgs(int)：如果没有至少 N 个非选项参数，该命令将报错。</li><li>MaximumNArgs(int)：如果有多于 N 个非选项参数，该命令将报错。</li><li>ExactArgs(int)：如果非选项参数个数不为 N，该命令将报错。</li><li>ExactValidArgs(int)：如果非选项参数的个数不为 N，或者非选项参数不在 Command 的 ValidArgs 字段中，该命令将报错。</li><li>RangeArgs(min, max)：如果非选项参数的个数不在 min 和 max 之间，该命令将报错。</li></ul><pre><code class="go">var cmd = &amp;cobra.Command&#123;  Short: &quot;hello&quot;,  Args: cobra.MinimumNArgs(1), // 使用内置的验证函数  Run: func(cmd *cobra.Command, args []string) &#123;    fmt.Println(&quot;Hello, World!&quot;)  &#125;,&#125;</code></pre><h4 id="自定义验证函数"><a href="#自定义验证函数" class="headerlink" title="自定义验证函数"></a>自定义验证函数</h4><pre><code class="go">var cmd = &amp;cobra.Command&#123;  Short: &quot;hello&quot;,  Args: func(cmd *cobra.Command, args []string) error &#123; // 自定义验证函数    if len(args) &lt; 1 &#123;      return errors.New(&quot;requires at least one arg&quot;)    &#125;    if myapp.IsValidColor(args[0]) &#123;      return nil    &#125;    return fmt.Errorf(&quot;invalid color specified: %s&quot;, args[0])  &#125;,  Run: func(cmd *cobra.Command, args []string) &#123;    fmt.Println(&quot;Hello, World!&quot;)  &#125;,&#125;</code></pre><p>解析命令行参数-&gt;Pflag<br>解析配置文件-&gt; Viper-&gt;从命令行参数、环境变量、配置文件等位置读取配置项<br>实现命令行框架-&gt;  Cobra</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PFlag</title>
      <link href="/2023/02/16/pflag/"/>
      <url>/2023/02/16/pflag/</url>
      
        <content type="html"><![CDATA[<p>作用：<br>对命令行参数进行处理。一个命令行参数在Pflag包中会解析为一个<code>Flag</code>结构体类型的变量</p><pre><code class="go">type Flag struct &#123;    Name                string // flag长选项的名称    Shorthand           string // flag短选项的名称，一个缩写的字符    Usage               string // flag的使用文本    Value               Value  // flag的值    DefValue            string // flag的默认值    Changed             bool // 记录flag的值是否有被设置过    NoOptDefVal         string // 当flag出现在命令行，但是没有指定选项值时的默认值    Deprecated          string // 记录该flag是否被放弃    Hidden              bool // 如果值为true，则从help/usage输出信息中隐藏该flag    ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息    Annotations         map[string][]string // 给flag设置注解&#125;type Value interface &#123;    String() string // 将flag类型的值转换为string类型的值，并返回string的内容    Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错    Type() string // 返回flag的类型，例如：string、int、ip等&#125;</code></pre><p>总结：<br>通过将 Flag 的值抽象成一个 interface 接口，我们就可以自定义 Flag 的类型了。只要实现了 Value 接口的结构体，就是一个新类型。</p><h2 id="FlagSet"><a href="#FlagSet" class="headerlink" title="FlagSet"></a>FlagSet</h2><p>本质：预先定义好的一些Flag的集合,日常用FlagSet的方法操作Pflag</p><h3 id="获取并使用FlagSet"><a href="#获取并使用FlagSet" class="headerlink" title="获取并使用FlagSet"></a>获取并使用FlagSet</h3><ol><li>调用 <code>NewFlagSet</code>创建一个FlagSet</li></ol><pre><code class="go">var version boolflagSet := pflag.NewFlagSet(&quot;test&quot;, pflag.ContinueOnError)flagSet.BoolVar(&amp;version, &quot;version&quot;, true, &quot;Print version information and quit.&quot;)</code></pre><ol start="2"><li>使用全局FlagSet：<code>CommandLine</code><br>主要用于不需要定义子命令的命令行工具</li></ol><pre><code class="go">import (    &quot;github.com/spf13/pflag&quot;)pflag.BoolVarP(&amp;version, &quot;version&quot;, &quot;v&quot;, true, &quot;Print version information and quit.&quot;)// pflag.BoolVarP 函数定义func BoolVarP(p *bool, name, shorthand string, value bool, usage string) &#123;    flag := CommandLine.VarPF(newBoolValue(value, p), name, shorthand, usage)    flag.NoOptDefVal = &quot;true&quot;&#125;// CommandLine is the default set of command-line flags, parsed from os.Args.var CommandLine = NewFlagSet(os.Args[0], ExitOnError)</code></pre><h2 id="Pflag使用方法"><a href="#Pflag使用方法" class="headerlink" title="Pflag使用方法"></a>Pflag使用方法</h2><h3 id="支持多种命令行参数定义方式"><a href="#支持多种命令行参数定义方式" class="headerlink" title="支持多种命令行参数定义方式"></a>支持多种命令行参数定义方式</h3><blockquote><p>函数名带Var -&gt; true:将标志的值绑定到变量，false:将标志的值存储在指针中<br>函数名带P -&gt; true:支持短选项，false:不支持短选项</p></blockquote><ol><li>支持长选项、默认值和使用文本，并将标志的值存储在指针中</li></ol><pre><code class="go">var name = pflag.String(&quot;name&quot;, &quot;colin&quot;, &quot;Input Your Name&quot;)</code></pre><ol start="2"><li>支持长选项、短选项、默认值和使用文本，并将标志的值存储在指针中。</li></ol><pre><code class="go">var name = pflag.StringP(&quot;name&quot;, &quot;n&quot;, &quot;colin&quot;, &quot;Input Your Name&quot;)</code></pre><ol start="3"><li>支持长选项、默认值和使用文本，并将标志的值绑定到变量</li></ol><pre><code class="go">var name stringpflag.StringVar(&amp;name, &quot;name&quot;, &quot;colin&quot;, &quot;Input Your Name&quot;)</code></pre><ol start="4"><li>支持长选项、短选项、默认值和使用文本，并将标志的值绑定到变量。</li></ol><pre><code class="go">var name stringpflag.StringVarP(&amp;name,&quot;n&quot;,&quot;colin&quot;,&quot;Input Your Name&quot;)</code></pre><h3 id="使用Get获取参数的值"><a href="#使用Get获取参数的值" class="headerlink" title="使用Get获取参数的值"></a>使用Get<Type>获取参数的值</h3><p>Type 代表 Pflag 所支持的类型<br>案例：有一个 pflag.FlagSet，带有一个名为 flagname 的 int 类型的标志，可以使用GetInt()来获取 int 值。需要注意 flagname 必须存在且必须是 int</p><pre><code class="go">i, err := flagset.GetInt(&quot;flagname&quot;)</code></pre><h3 id="获取非选项参数"><a href="#获取非选项参数" class="headerlink" title="获取非选项参数"></a>获取非选项参数</h3><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/spf13/pflag&quot;)var flagvar = pflag.Int(&quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)func main() &#123;    // 解析定义的标志    pflag.Parse()    // 返回非选项参数的个数    fmt.Printf(&quot;argument number is: %v\n&quot;, pflag.NArg()) //2    // 返回所有的非选项参数    fmt.Printf(&quot;argument list is: %v\n&quot;, pflag.Args()) //[arg1,arg2]    // 返回第i个非选项参数    fmt.Printf(&quot;the first argument is: %v\n&quot;, pflag.Arg(0))//arg1&#125;go run example1.go arg1 arg2</code></pre><h3 id="指定了选项但是没有指定选项值时的默认值"><a href="#指定了选项但是没有指定选项值时的默认值" class="headerlink" title="指定了选项但是没有指定选项值时的默认值"></a>指定了选项但是没有指定选项值时的默认值</h3><pre><code class="go">var ip = pflag.IntP(&quot;flagname&quot;, &quot;f&quot;, 1234, &quot;help message&quot;)pflag.Lookup(&quot;flagname&quot;).NoOptDefVal = &quot;4321&quot;--flagname=1357 -&gt; ip=1357--flagname -&gt; ip=4321[nothing] -&gt; ip=1234</code></pre><h3 id="弃用标志或标志的简写"><a href="#弃用标志或标志的简写" class="headerlink" title="弃用标志或标志的简写"></a>弃用标志或标志的简写</h3><p>弃用标志在帮助文本中会被隐藏，并在使用不推荐的标志或简写时打印正确的用法提示</p><pre><code class="go">//  deprecate a flag by specifying its name and a usage messagepflag.CommandLine.MarkDeprecated(&quot;logmode&quot;, &quot;please use --log-mode instead&quot;)</code></pre><h3 id="弃用简写形式，保留标志"><a href="#弃用简写形式，保留标志" class="headerlink" title="弃用简写形式，保留标志"></a>弃用简写形式，保留标志</h3><p>隐藏了帮助文本中的简写 </p><pre><code class="go">pflag.IntVarP(&amp;port, &quot;port&quot;, &quot;P&quot;, 3306, &quot;MySQL service host port.&quot;)// deprecate a flag shorthand by specifying its flag name and a usage messagepflag.CommandLine.MarkShorthandDeprecated(&quot;port&quot;, &quot;please use --port only&quot;)</code></pre><h3 id="隐藏标志"><a href="#隐藏标志" class="headerlink" title="隐藏标志"></a>隐藏标志</h3><p>仍将正常运行，但不会显示在 usage&#x2F;help 文本中</p><pre><code class="go">// hide a flag by specifying its namepflag.CommandLine.MarkHidden(&quot;secretFlag&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn报错</title>
      <link href="/2023/02/16/yarn-bao-cuo/"/>
      <url>/2023/02/16/yarn-bao-cuo/</url>
      
        <content type="html"><![CDATA[<p>yarn install 报错<br>报错信息：</p><blockquote><p>yarn : 无法加载文件 C:\Users\yueyu\AppData\Roaming\npm\yarn.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.mi<br>crosoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies。<br>所在位置 行:1 字符: 1</p></blockquote><p>解决方法：</p><ol><li>以管理员身份打开powershell,</li><li>输入<code>set-ExecutionPolicy RemoteSigned</code> 选择Y</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about hexo</title>
      <link href="/2023/02/16/hello-world/"/>
      <url>/2023/02/16/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="更新部署必须先把修改代码推到source分支，之后才能运行-npm-run-ci"><a href="#更新部署必须先把修改代码推到source分支，之后才能运行-npm-run-ci" class="headerlink" title="更新部署必须先把修改代码推到source分支，之后才能运行 npm run ci"></a>更新部署必须先把修改代码推到source分支，之后才能运行 npm run ci</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>翻译-ES2015-Set</title>
      <link href="/2023/02/15/fan-yi-es2015-set/"/>
      <url>/2023/02/15/fan-yi-es2015-set/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://itnext.io/what-is-the-javascript-set-in-es2015-and-when-should-you-use-it-d7e3b8048891">https://itnext.io/what-is-the-javascript-set-in-es2015-and-when-should-you-use-it-d7e3b8048891</a></p><h1 id="ES2015中的Set是什么以及什么时候可以使用它？"><a href="#ES2015中的Set是什么以及什么时候可以使用它？" class="headerlink" title="ES2015中的Set是什么以及什么时候可以使用它？"></a>ES2015中的Set是什么以及什么时候可以使用它？</h1><strong>ES2015规范引入了许多新特性，这些新特性会不断在所有新版本的浏览器中被采用，Set集合就是这些新特性之一。</strong><p>我的第一想法就是，好吧我可以使用一个普通的数组！但是这篇文章里我会展示可以用Set集合做什么。</p><h2 id="什么是-ES2015-Set"><a href="#什么是-ES2015-Set" class="headerlink" title="什么是 ES2015 Set?"></a>什么是 ES2015 Set?</h2><p><code>Set</code>是什么？你可以用它来做什么？Mozilla文档关于这一点说得很清晰：</p><blockquote><p> <code>Set</code> 集合可以存储任意类型的唯一值，无论是原始类型还是引用类型。</p></blockquote><p>这个特殊对象可以像普通对象一样存储所有种类的值，但是他们必须是唯一的，重复的值会被过滤出去。</p><p>感谢Addy Osmani的推特,让我发现了 <code>Set()</code>!</p><blockquote><p>小提示: JavaScript的 <code>Array.from()</code> 接受第二个参数，是一个<code>map</code>函数 。用于调用你创建的数组的每个元素。 </p><img src="/2023/02/15/fan-yi-es2015-set/array_from.jpg" class=""></blockquote><p>从JavaScript中过滤出重复值一直都很麻烦，你需要自己循环整个数组计算出来，现在<code>Set</code> 让这件事变得容易了 😁。</p><h2 id="向-Set-中添加数据"><a href="#向-Set-中添加数据" class="headerlink" title="向 Set 中添加数据"></a>向 Set 中添加数据</h2><p>目前有几种方法来向<code>Set</code>集合中添加数据。</p><h3 id="作为参数传递"><a href="#作为参数传递" class="headerlink" title="作为参数传递"></a>作为参数传递</h3><p>这是一个将数据作为参数添加到 <code>Set</code> 集合的例子：</p><pre><code class="javascript">const numbersSet = new Set([1,2,3,4,5]);const stringSet = new Set([&#39;Jan&#39;, &#39;Rick&#39;, &#39;Raymon&#39;, &#39;Tim&#39;]);const objectSet = new Set([&#123;a: 1, b: 2&#125;]);const arraySet = new Set([[&#39;javascript&#39;, &#39;coffeescript&#39;], [&#39;css&#39;, &#39;sass&#39;]]);</code></pre><h3 id="通过add方法添加数据"><a href="#通过add方法添加数据" class="headerlink" title="通过add方法添加数据"></a>通过add方法添加数据</h3><p>另外一种传递数据到<code>Set</code>集合的方法是使用 <code>add()</code> </p><pre><code class="javascript">const newSetObject = new Set();newSetObject.add(&#39;Raymon&#39;);newSetObject.add(&#123;a: 1, b: 2&#125;);newSetObject.add(1).add(2).add(3).add(4).add(5)// Result: Raymon, &#123;a: 1, b: 2&#125;, 1, 2, 3, 4, 5</code></pre><h2 id="使用has-检查Set中值"><a href="#使用has-检查Set中值" class="headerlink" title="使用has()检查Set中值"></a>使用has()检查Set中值</h2><p><code>Set</code>集合有一个非常方便的方法用来检查对象内部是否有某个值</p><pre><code class="javascript">const numbersSet = new Set([1,2,3,4,5]);const stringSet = new Set([&#39;Jan&#39;, &#39;Rick&#39;, &#39;Raymon&#39;, &#39;Tim&#39;]);const objectSet = new Set([&#123;a: 1, b: 2&#125;]);const arraySet = new Set([[&#39;javascript&#39;, &#39;coffeescript&#39;], [&#39;css&#39;, &#39;sass&#39;]]);    numberSet.has(4); // truenumberSet.has(6); // falsestringSet.has(&#39;Raymon&#39;); // trueobjectSet.has(&#123;a: 1, b: 2&#125;); // falsearraySet.has(&#39;css&#39;); // false</code></pre><p><code>has()</code> 方法在原始值上非常奏效，但是在像对象和数组这样的非原始值上不起作用。</p><p>关于非原始值不能和原始值一样起作用是有原因的。因为 <code>has()</code>方法不止比较值，他同时还会用&#x3D;&#x3D;&#x3D;操作符比较引用。</p><p>如果你在变量中有对数组或者对象的引用，那么结果就会和预期一样：</p><pre><code class="javascript">const exampleObject = &#123;a: 1, b: 2&#125;;const exampleArray1 = [&#39;javascript&#39;, &#39;coffeescript&#39;]const exampleArray2 = [&#39;css&#39;, &#39;sass&#39;];const objectSet = new Set([exampleObject]);const arraySet = new Set([exampleArray1, exampleArray2]);    objectSet.has(&#123;a: 1, b: 2&#125;); // falseobjectSet.has(exampleObject); // truearraySet.has(&#39;css&#39;); // falsearraySet.has(exampleArray1); // truearraySet.has(exampleArray2); // true</code></pre><p>所以记住：当你在<code>Set</code>集合中使用<code>has()</code>方法的时候,引用非原始值很重要。</p><h2 id="从Set中移除数据"><a href="#从Set中移除数据" class="headerlink" title="从Set中移除数据"></a>从Set中移除数据</h2><p>向 Set 集合中添加数据很简单，删除数据也很容易。</p><h3 id="使用delete方法移除数据"><a href="#使用delete方法移除数据" class="headerlink" title="使用delete方法移除数据"></a>使用delete方法移除数据</h3><p>如果想要移除<code>Set</code>集合中的单个元素，只需要简单地使用移除方法</p><pre><code class="javascript">const numbersSetObject = new Set([1,2,3,4,5,6,7,8,9]);numbersSetObject.has(2); // truenumbersSetObject.delete(2);numbersSetObject.has(2); // falseconsole.log(numbersSetObject); // 1,3,4,5,6,7,8,9</code></pre><h3 id="用clear方法移除所有元素"><a href="#用clear方法移除所有元素" class="headerlink" title="用clear方法移除所有元素"></a>用clear方法移除所有元素</h3><p>但是如果你想要从Set集合中移除所有数据，只能使用clear方法</p><pre><code class="javascript">const numbersSetObject = new Set([1,2,3,4,5,6,7,8,9]);numbersSetObject.has(2); // truenumbersSetObject.clear();console.log([...numbersSetObject]); // []</code></pre><h2 id="使用size属性检查元素数量"><a href="#使用size属性检查元素数量" class="headerlink" title="使用size属性检查元素数量"></a>使用size属性检查元素数量</h2><p>类似在数组中，使用length属性检查元素数量，Set集合也可以用size属性实现同样的目的<br>如果我们检查上一个例子中检查Set集合，他的size是7。</p><pre><code class="javascript">newSetObject.size // 7</code></pre><h2 id="过滤重复的原始值"><a href="#过滤重复的原始值" class="headerlink" title="过滤重复的原始值"></a>过滤重复的原始值</h2><p>如果尝试把重复的原始值放入Set,最后保留下来的只有唯一的一个。</p><pre><code class="javascript">const uniqueArray = new Set([1,2,2,2,3,4,5,5,6,7,9,9,8]);console.log(&#39;uniqueArray: &#39;, uniqueArray)// unique: 1, 2, 3, 4, 5, 6, 7, 9, 8</code></pre><h2 id="过滤非原始类型值"><a href="#过滤非原始类型值" class="headerlink" title="过滤非原始类型值"></a>过滤非原始类型值</h2><p>在过滤重复的非原始值的时候情况有点不同.文档十分清晰,Set本身并没有比较对象，而是比较引用。</p><p>将它看作是使用&#x3D;&#x3D;操作符比较值，但是使用&#x3D;&#x3D;&#x3D;操作符会比较引用和值。</p><p>如果我们尝试向Set放入具有不同引用的两个相同的对象，是没有问题的。</p><pre><code class="javascript">const objectSet = new Set([&#123;a: 1, b: 2&#125;, &#123;a: 1, b: 2&#125;]);console.log(&#39;objectSet: &#39;, objectSet);// objectSet: &#123;a: 1, b: 2&#125;, &#123;a: 1, b: 2&#125;;</code></pre><p>但是如果我们放入相同引用的两个相同的对象会发生什么呢？</p><pre><code class="javascript">const demoObject = &#123;a: 1, b: 2&#125;;const objectSet = new Set([demoObject, demoObject]);console.log(&#39;objectSet: &#39;, objectSet);// objectSet: &#123;a: 1, b: 2&#125;;</code></pre><p>希望你已经猜到结果了：objectSet只包含了一个demoObject，去除了另外一个重复的😁</p><h2 id="循环一个-Set"><a href="#循环一个-Set" class="headerlink" title="循环一个 Set"></a>循环一个 Set</h2><p>Set的好处之一就是你可以循环一个Set集合</p><p>这个文档解释了更多关于Set方法的细节：</p><blockquote><p>Set 是值的集合. 你可以按照插入顺序遍历其中的元素。</p></blockquote><p>To loop over a Set collection we can use the for-of loop and the forEach method which is attached to the Set.</p><p>我们可以通过for-of和附加到Set集合的forEach 方法来循环一个Set集合。</p><h3 id="forEach-方法循环"><a href="#forEach-方法循环" class="headerlink" title="forEach 方法循环"></a>forEach 方法循环</h3><p>通过<code>Set.forEach()</code>,你可以循环Set集合中的所有元素。</p><pre><code class="javascript">const objectSet = new Set([&#123;a: 1, b: 2&#125;, &#123;a: 1, b: 2&#125;]);objectSet.forEach(object =&gt; &#123;    console.log(&#39;Object: &#39;, object);&#125;)    // result:  // Object:  &#123;a: 1, b: 2&#125;// Object:  &#123;a: 1, b: 2&#125;</code></pre><h3 id="使用-for-of"><a href="#使用-for-of" class="headerlink" title="使用 for-of"></a>使用 for-of</h3><p>通过for-of循环，我们有一些方法可以遍历Set集合内部的所有元素。</p><ul><li>entries()</li><li>keys()</li><li>values()</li></ul><pre><code class="javascript">const objectSet = new Set([&#123;a: 1, b: 2&#125;, &#123;a: 1, b: 2&#125;]);for (let [key, value] of objectSet.entries())  &#123;   console.log(key);&#125;    // &#123;a: 1, b: 2&#125;// &#123;a: 1, b: 2&#125;</code></pre><p>唯一奇怪的事情是： entries, keys 和 values方法在Set上会返回完全相同的结果。也许是因为 Set 和 Map Api有许多共同之处。</p><h2 id="Set和Map的区别"><a href="#Set和Map的区别" class="headerlink" title="Set和Map的区别"></a>Set和Map的区别</h2><p>map和set最大的区别是：Set看上去非常像一个数组，而map看上去更像一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何生成swagger-api文档</title>
      <link href="/2023/02/02/ru-he-sheng-cheng-swagger-api-wen-dang/"/>
      <url>/2023/02/02/ru-he-sheng-cheng-swagger-api-wen-dang/</url>
      
        <content type="html"><![CDATA[<p>使用依赖库：<a href="https://github.com/swaggo/swag">https://github.com/swaggo/swag</a></p><h3 id="在makefile中提供生成命令"><a href="#在makefile中提供生成命令" class="headerlink" title="在makefile中提供生成命令"></a>在makefile中提供生成命令</h3><pre><code>##genSwaggerDoc: generate swagger docs by swaggo/swag.PHONY: genSwaggerDocgenSwaggerDoc:    swag init -g ./cmd/notepad-apiserver/apiserver.go</code></pre><h3 id="apiserver-go"><a href="#apiserver-go" class="headerlink" title="apiserver.go"></a>apiserver.go</h3><pre><code class="go">package mainimport (    _ &quot;github.com/earthaYan/notePad/docs&quot;    &quot;github.com/gin-gonic/gin&quot;    swaggerFiles &quot;github.com/swaggo/files&quot;    ginSwagger &quot;github.com/swaggo/gin-swagger&quot;)// @titlenotepad api// @version1.0// @descriptionThis is a sample server celler server.// @host116.204.108.126:8080// @BasePath/v1// @securityDefinitions.basic  BasicAuthfunc main() &#123;    r := gin.Default()    c := controller.NewController()    v1 := r.Group(&quot;v1&quot;)    &#123;        accounts := v1.Group(&quot;/accounts&quot;)        &#123;            accounts.GET(&quot;:id&quot;, c.ShowAccount)            accounts.GET(&quot;&quot;, c.ListAccounts)            accounts.POST(&quot;&quot;, c.AddAccount)            accounts.DELETE(&quot;:id&quot;, c.DeleteAccount)            accounts.PATCH(&quot;:id&quot;, c.UpdateAccount)            accounts.POST(&quot;:id/images&quot;, c.UploadAccountImage)        &#125;        r.GET(&quot;/swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler))        r.Run(&quot;:8080&quot;)    &#125;    log.Println(&quot;start http server&quot;)    log.Fatal(http.ListenAndServe(&quot;:50052&quot;, nil))&#125;</code></pre><h3 id="controller-x2F-accounts-go"><a href="#controller-x2F-accounts-go" class="headerlink" title="controller&#x2F;accounts.go"></a>controller&#x2F;accounts.go</h3><pre><code class="go">package controllerimport (    &quot;fmt&quot;    &quot;net/http&quot;    &quot;strconv&quot;    &quot;github.com/gin-gonic/gin&quot;    &quot;github.com/swaggo/swag/example/celler/httputil&quot;    &quot;github.com/swaggo/swag/example/celler/model&quot;)// ShowAccount godoc////@SummaryShow an account//@Descriptionget string by ID//@Tagsaccounts//@Acceptjson//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;//@Success200&#123;object&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125; [get]func (c *Controller) ShowAccount(ctx *gin.Context) &#123;    id := ctx.Param(&quot;id&quot;)    aid, err := strconv.Atoi(id)    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    account, err := model.AccountOne(aid)    if err != nil &#123;        httputil.NewError(ctx, http.StatusNotFound, err)        return    &#125;    ctx.JSON(http.StatusOK, account)&#125;// ListAccounts godoc////@SummaryList accounts//@Descriptionget accounts//@Tagsaccounts//@Acceptjson//@Producejson//@Paramqquerystringfalse&quot;name search by q&quot;Format(email)//@Success200&#123;array&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts [get]func (c *Controller) ListAccounts(ctx *gin.Context) &#123;    q := ctx.Request.URL.Query().Get(&quot;q&quot;)    accounts, err := model.AccountsAll(q)    if err != nil &#123;        httputil.NewError(ctx, http.StatusNotFound, err)        return    &#125;    ctx.JSON(http.StatusOK, accounts)&#125;// AddAccount godoc////@SummaryAdd an account//@Descriptionadd by json account//@Tagsaccounts//@Acceptjson//@Producejson//@Paramaccountbodymodel.AddAccounttrue&quot;Add account&quot;//@Success200&#123;object&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts [post]func (c *Controller) AddAccount(ctx *gin.Context) &#123;    var addAccount model.AddAccount    if err := ctx.ShouldBindJSON(&amp;addAccount); err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    if err := addAccount.Validation(); err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    account := model.Account&#123;        Name: addAccount.Name,    &#125;    lastID, err := account.Insert()    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    account.ID = lastID    ctx.JSON(http.StatusOK, account)&#125;// UpdateAccount godoc////@SummaryUpdate an account//@DescriptionUpdate by json account//@Tagsaccounts//@Acceptjson//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;//@Paramaccountbodymodel.UpdateAccounttrue&quot;Update account&quot;//@Success200&#123;object&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125; [patch]func (c *Controller) UpdateAccount(ctx *gin.Context) &#123;    id := ctx.Param(&quot;id&quot;)    aid, err := strconv.Atoi(id)    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    var updateAccount model.UpdateAccount    if err := ctx.ShouldBindJSON(&amp;updateAccount); err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    account := model.Account&#123;        ID:   aid,        Name: updateAccount.Name,    &#125;    err = account.Update()    if err != nil &#123;        httputil.NewError(ctx, http.StatusNotFound, err)        return    &#125;    ctx.JSON(http.StatusOK, account)&#125;// DeleteAccount godoc////@SummaryDelete an account//@DescriptionDelete by account ID//@Tagsaccounts//@Acceptjson//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;Format(int64)//@Success204&#123;object&#125;model.Account//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125; [delete]func (c *Controller) DeleteAccount(ctx *gin.Context) &#123;    id := ctx.Param(&quot;id&quot;)    aid, err := strconv.Atoi(id)    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    err = model.Delete(aid)    if err != nil &#123;        httputil.NewError(ctx, http.StatusNotFound, err)        return    &#125;    ctx.JSON(http.StatusNoContent, gin.H&#123;&#125;)&#125;// UploadAccountImage godoc////@SummaryUpload account image//@DescriptionUpload file//@Tagsaccounts//@Acceptmultipart/form-data//@Producejson//@Paramidpathinttrue&quot;Account ID&quot;//@ParamfileformDatafiletrue&quot;account image&quot;//@Success200&#123;object&#125;controller.Message//@Failure400&#123;object&#125;httputil.HTTPError//@Failure404&#123;object&#125;httputil.HTTPError//@Failure500&#123;object&#125;httputil.HTTPError//@Router/accounts/&#123;id&#125;/images [post]func (c *Controller) UploadAccountImage(ctx *gin.Context) &#123;    id, err := strconv.Atoi(ctx.Param(&quot;id&quot;))    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    file, err := ctx.FormFile(&quot;file&quot;)    if err != nil &#123;        httputil.NewError(ctx, http.StatusBadRequest, err)        return    &#125;    ctx.JSON(http.StatusOK, Message&#123;Message: fmt.Sprintf(&quot;upload complete userID=%d filename=%s&quot;, id, file.Filename)&#125;)&#125;</code></pre><h3 id="浏览器中访问"><a href="#浏览器中访问" class="headerlink" title="浏览器中访问"></a>浏览器中访问</h3><p><a href="http://116.204.108.126:8080/swagger/index.html">http://116.204.108.126:8080/swagger/index.html</a></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><blockquote><p>golang swagger internal server error doc.json<br>解决方法：<br>在main.go 中导入docs.go </p></blockquote><pre><code class="go">import (  _ &quot;github.com/earthaYan/notePad/docs&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go.mod文件</title>
      <link href="/2023/01/30/go-mod-wen-jian/"/>
      <url>/2023/01/30/go-mod-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="go-mod常见用法以及注释"><a href="#go-mod常见用法以及注释" class="headerlink" title="go.mod常见用法以及注释"></a>go.mod常见用法以及注释</h2><pre><code class="go">// module path，一般采用仓库或者仓库+module_name定义module github.com/actiontech/dtle// go directive,非必须,指定代码所需要的go的最低版本，一般为go 1.xxgo 1.16// require段中列出了项目所需要的各个依赖库以及它们的版本require (    // 正规版本号    github.com/Shopify/sarama v1.26.4    // 伪版本号： go module 为它生成的一个类似符合语义化版本 2.0.0 版本，实际这个库并没有发布这个版本    // commit 的 base versio-本次提交时间-第三方库本次提交时最新的commitId    github.com/actiontech/golang-live-coverage-report v0.0.0-20210902074032-43aa91afdc2c    //indirect: 间接的使用了这个库，但是又没有被列到某个 go.mod 中    // 1. 当前项目依赖 A，但是 A 的go.mod 遗漏了 B，那么就会在当前项目的 go.mod 中补充 B，加 indirect 注释；    // 2.当前项目依赖 A，但是 A 没有 go.mod，同样就会在当前项目的 go.mod 中补充 B，加 indirect 注释；    // 3.当前项目依赖 A，A 又依赖 B。当对 A 降级的时候，降级的 A 不再依赖 B，这个时候 B 就标记 indirect 注释。我们可以执行go mod tidy来清理不依赖的 module。    github.com/go-playground/universal-translator v0.17.0 // indirect    // 没有采用go.mod管理或者module path 中依然没有添加 v2、v3 这样的后缀,不符合 Go 的 module 管理规范    github.com/go-playground/validator v9.31.0+incompatible)// 1. 替换库// 2.某个依赖库有问题，自己 fork 到本地做修改，通过替换成本地文件夹进行调试replace github.com/go-mysql-org/go-mysql =&gt; github.com/ffffwh/go-mysql v0.0.0-20211206100736-edbdc58f729a//replace github.com/Sirupsen/logrus =&gt; github.com/sirupsen/logrus v1.4.2replace github.com/araddon/qlbridge =&gt; github.com/ffffwh/qlbridge v0.0.0-20220113095321-0b48c80b13e9replace github.com/pingcap/dm =&gt; github.com/actiontech/dm v0.0.0-20211206092524-9e640f6da0acreplace github.com/pingcap/tidb =&gt; github.com/actiontech/tidb v0.0.0-20220928030323-1f192702a2c7replace github.com/pingcap/tidb/parser =&gt; github.com/actiontech/tidb/parser v0.0.0-20220928030323-1f192702a2c7// 后面的commitId为当时提交代码的时候依赖包的commitIdreplace github.com/hashicorp/go-discover =&gt; github.com/hashicorp/go-discover v0.0.0-20211203145537-8b3ddf4349a8// 将grpc版本固定为1.29.1replace google.golang.org/grpc =&gt; google.golang.org/grpc v1.29.1// exclude :Go 在版本选择的时候，如go get -u 或者go get github.com/xxx/xxx@latest 就会主动跳过这些版本// retract :go 1.16 中新增加的内容</code></pre><h2 id="第三方库的replace"><a href="#第三方库的replace" class="headerlink" title="第三方库的replace"></a>第三方库的replace</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>第三方库中缺少自己项目中需要的某个方法，自己fork一份并加入自定义的新方法，在项目中调用这个自定义方法</p><h3 id="解决方法1-引用新库"><a href="#解决方法1-引用新库" class="headerlink" title="解决方法1-引用新库"></a>解决方法1-引用新库</h3><ol><li>将fork的库的go.mod中module name 修改为一个新的 name</li><li>增加所需要的方法</li><li>增加新的 git tag</li><li>当前项目中，引用修改后的这个 repo，替换地址以及tag版本号</li></ol><h3 id="解决方法2-go-mod-replace"><a href="#解决方法2-go-mod-replace" class="headerlink" title="解决方法2 - go mod replace"></a>解决方法2 - go mod replace</h3><ol><li>fork第三方库</li><li>增加需要的方法</li><li>在当前项目中，执行 go mod edit -replace 命令:<code>go mod edit -replace=old[@v]=new[@v]</code></li></ol><pre><code class="go">go mod edit -replace=golang.org/x/image@v0.0.0-20180708004352-c73c2afc3b81=github.com/golang/image@v0.0.0-20180708004352-c73c2afc3b81</code></pre><ol start="4"><li>可以向第三方库提交PR，合并上去后可以删除replace语句</li></ol><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="初始化module"><a href="#初始化module" class="headerlink" title="初始化module"></a>初始化module</h3><p><code>go mod init project_name</code></p><h3 id="go-mod-tidy作用"><a href="#go-mod-tidy作用" class="headerlink" title="go mod tidy作用"></a>go mod tidy作用</h3><ol><li>解析项目文件，并找到所使用的包</li><li>生成 go.sum 文件，其中保存了所使用包的版本</li></ol><h3 id="执行项目"><a href="#执行项目" class="headerlink" title="执行项目"></a>执行项目</h3><p><code>go run main.go</code></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>session vs cookie</title>
      <link href="/2023/01/13/session/"/>
      <url>/2023/01/13/session/</url>
      
        <content type="html"><![CDATA[<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在<font color=red>本地计算机【浏览器端】</font>保存用户操作的历史信息，如登录信息，并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作。</p><img src="/2023/01/13/session/6.1.cookie2.png" class="" title="cookie原理"><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>有时间限制，分为会话cookie和持久cookie</p><ul><li>会话cookie:<ol><li>不设置过期时间，生命周期为从创建到浏览器关闭为止,一般不保存在硬盘上而是保存在内存里</li><li>cookie是否可以在不同的浏览器进程间共享由不同浏览器决定</li></ol></li><li>持久cookie:<ol><li>设置过期时间,cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效</li><li>cookie可以在不同的浏览器进程间共享</li></ol></li></ul><h3 id="go使用"><a href="#go使用" class="headerlink" title="go使用"></a>go使用</h3><h4 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h4><p><code>http.setCookie(w ResponseWriter, cookie *Cookie)</code></p><blockquote><p>w表示需要写入的response，cookie是一个struct</p></blockquote><pre><code class="go">// cookie对象type Cookie struct &#123;    Name       string //常用    Value      string //常用，    Path       string    Domain     string    Expires    time.Time//常用    RawExpires string  // MaxAge=0 means no &#39;Max-Age&#39; attribute specified.  // MaxAge&lt;0 means delete cookie now, equivalently &#39;Max-Age: 0&#39;  // MaxAge&gt;0 means Max-Age attribute present and given in seconds    MaxAge   int    Secure   bool    HttpOnly bool    Raw      string    Unparsed []string // Raw text of unparsed attribute-value pairs&#125;</code></pre><p>示例：</p><pre><code class="go">expiration := time.Now()expiration = expiration.AddDate(1, 0, 0)cookie := http.Cookie&#123;Name: &quot;username&quot;, Value: &quot;astaxie&quot;, Expires: expiration&#125;http.SetCookie(w, &amp;cookie)</code></pre><p><a href="https://jiapan.me/2017/cookies-max-age-vs-expires/">maxAge和expires区别</a></p><h4 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h4><p>通过request获取cookie：<code>cookie, _ := r.Cookie(&quot;username&quot;)</code></p><hr><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在<font color=red>服务器</font>上保存用户操作的历史信息。服务器使用session id来标识session，session id由服务器负责产生，相当于一个唯一的随机密钥，避免在握手或传输中暴露用户真实密码。但该方式下，仍然需要将发送请求的客户端与session进行对应，所以可以借助cookie机制来获取客户端的标识（即session id），也可以通过GET方式将id提交给服务器。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>session通过cookie，在客户端保存session id</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-数据库</title>
      <link href="/2023/01/12/go-shu-ju-ku/"/>
      <url>/2023/01/12/go-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><pre><code class="go">package mainimport (    &quot;database/sql&quot;    &quot;fmt&quot;    _ &quot;github.com/go-sql-driver/mysql&quot;)func checkErr(err error) &#123;    if err != nil &#123;        panic(err)    &#125;&#125;func useMysql() &#123;    // 打开一个注册过的数据库驱动,第二个参数为data source name    db, err := sql.Open(&quot;mysql&quot;, &quot;root:123456@tcp(116.204.108.126:3306)/test?charset=utf8&quot;)    checkErr(err)    // 插入数据    // 返回准备要执行的sql操作，然后返回准备完毕的执行状态    stmt, err := db.Prepare(&quot;INSERT INTO userinfo SET username=?,department=?,created=?&quot;)    checkErr(err)    // 执行stmt准备好的SQL语句    // 传入的参数都是=?对应的数据    res, err := stmt.Exec(&quot;amy&quot;, &quot;研发部门&quot;, &quot;2012-12-09&quot;)    checkErr(err)    id, err := res.LastInsertId()    checkErr(err)    fmt.Println(id)    // 修改数据    stmt, err = db.Prepare(&quot;update userinfo set username=? where uid=?&quot;)    checkErr(err)    res, err = stmt.Exec(&quot;astaxieupdate&quot;, id)    checkErr(err)    affect, err := res.RowsAffected()    checkErr(err)    fmt.Println(affect)    // 查询数据    // 直接执行Sql返回Rows结果    rows, err := db.Query(&quot;SELECT * FROM userinfo&quot;)    checkErr(err)    for rows.Next() &#123;        var uid int        var username string        var department string        var created string        err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)        checkErr(err)        fmt.Println(uid)        fmt.Println(username)        fmt.Println(department)        fmt.Println(created)     &#125;    // 删除数据    stmt, err = db.Prepare(&quot;delete from userinfo where uid=?&quot;)    checkErr(err)    res, err = stmt.Exec(id)    checkErr(err)    affect, err = res.RowsAffected()    checkErr(err)    fmt.Println(affect)    db.Close() //关闭数据库连接&#125;</code></pre><h3 id="sql-Open第二参数形式"><a href="#sql-Open第二参数形式" class="headerlink" title="sql.Open第二参数形式"></a>sql.Open第二参数形式</h3><pre><code class="bash">user@unix(/path/to/socket)/dbname?charset=utf8user:password@tcp(localhost:5555)/dbname?charset=utf8user:password@/dbnameuser:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname</code></pre><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>sql.Open()：打开一个注册过的数据库驱动</li><li>db.Prepare()：返回准备要执行的sql操作，然后返回准备完毕的执行状态</li><li>db.Query()：用来直接执行Sql返回Rows结果</li><li>stmt.Exec()：用来执行stmt准备好的SQL语句</li></ul><blockquote><p>传入的参数都是&#x3D;?对应的数据，可以一定程度上防止SQL注入</p></blockquote><h4 id="必须引入的两个包"><a href="#必须引入的两个包" class="headerlink" title="必须引入的两个包"></a>必须引入的两个包</h4><ol><li><pre><code>&quot;database/sql&quot;</code></pre></li><li>_ “github.com&#x2F;go-sql-driver&#x2F;mysql” &#x2F;&#x2F;驱动</li></ol><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><h3 id="必须导入的包"><a href="#必须导入的包" class="headerlink" title="必须导入的包"></a>必须导入的包</h3><ul><li>“database&#x2F;sql”</li><li>_ “github.com&#x2F;mattn&#x2F;go-sqlite3” &#x2F;&#x2F;驱动</li></ul><h3 id="和mysql区别"><a href="#和mysql区别" class="headerlink" title="和mysql区别"></a>和mysql区别</h3><p>导入驱动：<code>db, err := sql.Open(&quot;sqlite3&quot;, &quot;./foo.db&quot;)</code></p><h2 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h2><h3 id="必须导入的包-1"><a href="#必须导入的包-1" class="headerlink" title="必须导入的包"></a>必须导入的包</h3><ul><li>“database&#x2F;sql”</li><li>_ “github.com&#x2F;lib&#x2F;pq” &#x2F;&#x2F;驱动</li></ul><h3 id="和mysql区别-1"><a href="#和mysql区别-1" class="headerlink" title="和mysql区别"></a>和mysql区别</h3><ol><li>PostgreSQL是通过$1,$2这种方式来指定要传递的参数，而不是MySQL中的?</li><li>sql.Open中的dsn信息的格式也与MySQL的驱动中的dsn格式不一样</li></ol><pre><code class="go">func usePostgreSQL() &#123;    connStr := &quot;postgres://postgres:123456@116.204.108.126:3306/test?sslmode=disable&quot;    db, err := sql.Open(&quot;postgres&quot;, connStr)    checkErr(err)    // 插入数据    stmt, err := db.Prepare(&quot;INSERT INTO userinfo(username,department,created) VALUES($1,$2,$3) RETURNING uid&quot;)    checkErr(err)    res, err := stmt.Exec(&quot;astaxie&quot;, &quot;研发部门&quot;, &quot;2012-12-09&quot;)    checkErr(err)    var lastInsertId int    err = db.QueryRow(&quot;INSERT INTO userinfo(username,department,created) VALUES($1,$2,$3) returning uid;&quot;, &quot;astaxie&quot;, &quot;研发部门&quot;, &quot;2012-12-09&quot;).Scan(&amp;lastInsertId)    checkErr(err)    fmt.Println(&quot;最后插入id =&quot;, lastInsertId, res)    // 修改数据    stmt, err = db.Prepare(&quot;update userinfo set username=$1 where uid=$2&quot;)    checkErr(err)    res, err = stmt.Exec(&quot;astaxieupdate&quot;, lastInsertId)    checkErr(err)    affect, err := res.RowsAffected()    checkErr(err)    fmt.Println(affect)    // 查看数据    rows, err := db.Query(&quot;SELECT * FROM userinfo&quot;)    checkErr(err)    for rows.Next() &#123;        var uid int        var username string        var department string        var created string        err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)        checkErr(err)        fmt.Println(uid)        fmt.Println(username)        fmt.Println(department)        fmt.Println(created)    &#125;    // 删除数据    stmt, err = db.Prepare(&quot;delete from userinfo where uid=$1&quot;)    checkErr(err)    res, err = stmt.Exec(lastInsertId)    checkErr(err)    affect, err = res.RowsAffected()    checkErr(err)    fmt.Println(affect)    db.Close()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装</title>
      <link href="/2023/01/11/docker-an-zhuang/"/>
      <url>/2023/01/11/docker-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="基于centos7的设置Docker方式的安装"><a href="#基于centos7的设置Docker方式的安装" class="headerlink" title="基于centos7的设置Docker方式的安装"></a>基于centos7的设置Docker方式的安装</h2><p>官方文档：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h3 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h3><ol><li>删除旧版本的docker engine</li></ol><pre><code class="bash">sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine</code></pre><ol start="2"><li>安装提供<code>yum-config-manager</code>工具的yum-utils包</li></ol><pre><code class="bash">yum install -y yum-utilsyum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><h3 id="安装docker-引擎"><a href="#安装docker-引擎" class="headerlink" title="安装docker 引擎"></a>安装docker 引擎</h3><pre><code class="bash">yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin #安装最新版#安装指定版本yum list docker-ce --showduplicates | sort -ryum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io docker-compose-plugin </code></pre><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><pre><code class="bash">systemctl start docker# 验证docker run hello-world</code></pre><h3 id="创建docker-组和用户-非必须"><a href="#创建docker-组和用户-非必须" class="headerlink" title="创建docker 组和用户(非必须)"></a>创建docker 组和用户(非必须)</h3><pre><code class="bash">groupadd docker # 创建docker用户组usermod -aG docker $USER #将用户添加到组内</code></pre><p>退出登录后重新登录,组和用户才会生效，此时即使是非root用户也不需要使用sudo</p><h4 id="解决报错"><a href="#解决报错" class="headerlink" title="解决报错"></a>解决报错</h4><blockquote><p>WARNING: Error loading config file: &#x2F;home&#x2F;user&#x2F;.docker&#x2F;config.json - stat &#x2F;home&#x2F;user&#x2F;.docker&#x2F;config.json: permission denied<br>解决方法</p></blockquote><pre><code class="bash">sudo chown &quot;$USER&quot;:&quot;$USER&quot; /home/&quot;$USER&quot;/.docker -Rsudo chmod g+rwx &quot;$HOME/.docker&quot; -R</code></pre><h3 id="设置为开机自启动"><a href="#设置为开机自启动" class="headerlink" title="设置为开机自启动"></a>设置为开机自启动</h3><pre><code class="bash">systemctl enable docker.servicesystemctl enable containerd.service# 停止开机自启动systemctl disable docker.servicesystemctl disable containerd.service</code></pre><h2 id="创建一个mysql容器"><a href="#创建一个mysql容器" class="headerlink" title="创建一个mysql容器"></a>创建一个mysql容器</h2><p><code>docker run --name test_sql -e MYSQL_ROOT_PASSWORD=123 -d mysql:latest</code></p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><pre><code class="bash">docker exec -it test_sql bash# 查看日志docker logs test_sql </code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-表单处理文件上传</title>
      <link href="/2023/01/11/go-biao-dan-chu-li-wen-jian-shang-chuan/"/>
      <url>/2023/01/11/go-biao-dan-chu-li-wen-jian-shang-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="form的enctype属性"><a href="#form的enctype属性" class="headerlink" title="form的enctype属性"></a>form的<code>enctype</code>属性</h2><ol><li>application&#x2F;x-www-form-urlencoded   表示在发送前编码所有字符（默认）</li><li>multipart&#x2F;form-data  不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</li><li>text&#x2F;plain  空格转换为 “+” 加号，但不对特殊字符编码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web工作方式</title>
      <link href="/2023/01/10/web-gong-zuo-fang-shi/"/>
      <url>/2023/01/10/web-gong-zuo-fang-shi/</url>
      
        <content type="html"><![CDATA[<h5 id="表现："><a href="#表现：" class="headerlink" title="表现："></a>表现：</h5><p>浏览网页的时候,会打开浏览器，输入网址后按下回车键，然后就会显示出你想要浏览的内容</p><h2 id="背后流程"><a href="#背后流程" class="headerlink" title="背后流程"></a>背后流程</h2><p>普通上网过程：</p><ol><li>输入URL时,浏览器(客户端)请求DNS服务器，获取到应对应的IP</li><li>通过ip地址找到ip对应的服务器，要求建立TCP连接</li><li>浏览器发送完HTTP Request（请求）包</li><li>服务器接收到请求包之后开始处理请求包</li><li>服务器调用自身服务，返回HTTP Response（响应）包</li><li>客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body）</li><li>收到全部的内容随后断开与该服务器之间的TCP连接</li></ol><h2 id="Web服务器的工作原理"><a href="#Web服务器的工作原理" class="headerlink" title="Web服务器的工作原理"></a>Web服务器的工作原理</h2><ol><li>客户机通过TCP&#x2F;IP协议建立到服务器的TCP连接</li><li>客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档</li><li>服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端</li><li>客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果</li></ol><blockquote><p>注意：客户机与服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户机断开连接，等待下一次请求</p></blockquote><h2 id="url和DNS解析"><a href="#url和DNS解析" class="headerlink" title="url和DNS解析"></a>url和DNS解析</h2><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><pre><code>scheme://host[:port#]/path/.../[?query-string][#anchor]scheme         指定底层使用的协议(例如：http, https, ftp)host           HTTP服务器的IP地址或者域名port#          HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/path           访问资源的路径query-string   发送给http服务器的数据anchor         锚</code></pre><h3 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS-域名系统"></a>DNS-域名系统</h3><p>用于TCP&#x2F;IP网络，将主机名或域名转换为实际IP地址</p><img src="/2023/01/10/web-gong-zuo-fang-shi/3.1.dns_hierachy.png" class="" title="dns"><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><ol><li>在浏览器中输入<a href="http://www.qq.com域名,操作系统会先检查自己本地的hosts文件是否有这个网址映射关系,如果有,就先调用这个ip地址映射,完成域名解析/">www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析</a></li><li>如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</li><li>如果前两步都没有相应的网址映射关系，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器【本地DNS服务器】，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析</li><li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析</li><li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，<ul><li>如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机./">www.qq.com主机。</a></li><li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管本地DNS服务器用的是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机</li></ul></li></ol>  <img src="/2023/01/10/web-gong-zuo-fang-shi/3.1.dns_inquery.png" class="" title="inquery"><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>功能：让Web服务器与浏览器(客户端)通过Internet发送与接收数据<br>基于：TCP协议，一般使用TCP 80端口<br>无状态：同一个客户端的这次请求和上次请求没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端<br>解决问题：引入了Cookie机制来维护连接的可持续状态来解决识别两个请求是否来自同一个客户端问题</p><h3 id="客户端请求包——浏览器信息"><a href="#客户端请求包——浏览器信息" class="headerlink" title="客户端请求包——浏览器信息"></a>客户端请求包——浏览器信息</h3><pre><code>GET /domains/example/ HTTP/1.1//请求行: 请求方法 请求URI HTTP协议/协议版本Host：www.iana.org//服务端的主机名User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4//浏览器信息Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8//客户端能接收的MIMEAccept-Encoding：gzip,deflate,sdch//是否支持流压缩Accept-Charset：UTF-8,*;q=0.5//客户端字符编码集//空行,用于分割请求头和消息体//消息体Body,请求资源参数,例如POST传递的参数</code></pre><h4 id="与服务器交互的请求方法"><a href="#与服务器交互的请求方法" class="headerlink" title="与服务器交互的请求方法"></a>与服务器交互的请求方法</h4><p>GET,POST,PUT,DELETE-&gt;查，增，改，删</p><h4 id="get与post区别"><a href="#get与post区别" class="headerlink" title="get与post区别"></a>get与post区别</h4><img src="/2023/01/10/web-gong-zuo-fang-shi/3.1.http.png" class="" title="get请求"> <img src="/2023/01/10/web-gong-zuo-fang-shi/3.1.httpPOST.png" class="" title="post请求"><ol><li>GET请求消息体为空，POST请求带有消息体</li><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连；POST方法是把提交的数据放在HTTP包的body中</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码</li></ol><blockquote><p>浏览器对url长度限制:<br>IE浏览器:2048字节<br>360极速浏览器:2118字节<br>Firefox(Browser):65536字节<br>Safari(Browser):80000字节<br>Opera(Browser):190000字节<br>Google(chrome):8182字节</p></blockquote><h3 id="服务器端响应包"><a href="#服务器端响应包" class="headerlink" title="服务器端响应包"></a>服务器端响应包</h3><pre><code>HTTP/1.1 200 OK//状态行=HTTP协议版本号+状态码+状态消息Server: nginx/1.0.8//服务器使用的WEB软件名及版本Date:Date: Tue, 30 Oct 2012 04:14:25 GMT//发送时间Content-Type: text/html//服务器发送信息的类型Transfer-Encoding: chunked//表示发送HTTP包是分段发的Connection: keep-alive//保持连接状态Content-Length: 90//主体内容长度//空行 用来分割消息头和主体&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体</code></pre><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul><li>1XX 提示信息 - 表示请求已被成功接收，继续处理</li><li>2XX 成功 - 表示请求已被成功接收，理解，接受</li><li>3XX 重定向 - 要完成请求必须进行更进一步的处理，302表示跳转</li><li>4XX 客户端错误 - 请求有语法错误或请求无法实现</li><li>5XX 服务器端错误 - 服务器未能实现合法的请求</li></ul><h3 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h3><p>从HTTP&#x2F;1.1起，默认都开启了Keep-Alive保持连接特性</p><ol><li>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。</li><li>无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）</li><li>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接</li><li>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>第一次请求url，服务器端返回的是html页面，然后浏览器开始渲染HTML</li><li>当解析到HTML DOM里面的图片连接，css脚本和js脚本的链接，浏览器就会自动发起一个请求静态资源的HTTP请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。</li></ol><h4 id="网页优化："><a href="#网页优化：" class="headerlink" title="网页优化："></a>网页优化：</h4><p>减少HTTP请求次数，就是把尽量多的css和js资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。</p><h2 id="Go与web"><a href="#Go与web" class="headerlink" title="Go与web"></a>Go与web</h2><p>一个简单的web服务器</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;net/http&quot;    &quot;strings&quot;    &quot;log&quot;)func sayhelloName(w http.ResponseWriter, r *http.Request) &#123;    r.ParseForm()  //解析参数，默认是不会解析的    fmt.Println(r.Form)  //这些信息是输出到服务器端的打印信息    fmt.Println(&quot;path&quot;, r.URL.Path)    fmt.Println(&quot;scheme&quot;, r.URL.Scheme)    fmt.Println(r.Form[&quot;url_long&quot;])    for k, v := range r.Form &#123;        fmt.Println(&quot;key:&quot;, k)        fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))    &#125;    fmt.Fprintf(w, &quot;Hello astaxie!&quot;) //这个写入到w的是输出到客户端的&#125;func main() &#123;    http.HandleFunc(&quot;/&quot;, sayhelloName) //设置访问的路由,注册了请求/的路由规则    err := http.ListenAndServe(&quot;:9090&quot;, nil) //设置监听的端口,第二个参数默认为空则获取handler = DefaultServeMux  // 上述 DefaultServeMux变量本质是一个路由器，用来匹配url跳转到其相应的handle函数    if err != nil &#123;        log.Fatal(&quot;ListenAndServe: &quot;, err)    &#125;&#125;</code></pre><h3 id="服务器端的基本概念"><a href="#服务器端的基本概念" class="headerlink" title="服务器端的基本概念"></a>服务器端的基本概念</h3><ul><li>Request:用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息</li><li>Response:服务器需要返回给客户端的信息</li><li>Conn:用户的每次请求链接</li><li>Handler:处理请求和生成返回信息的处理逻辑</li></ul><h3 id="http包执行流程"><a href="#http包执行流程" class="headerlink" title="http包执行流程"></a>http包执行流程</h3><img src="/2023/01/10/web-gong-zuo-fang-shi/3.3.http.png" class="" title="http包执行流程"><ol><li>创建Listen Socket，监听指定端口,等待客户端请求到来</li><li>Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信</li><li>处理客户端的请求<ul><li>首先从Client Socket读取HTTP请求的协议头,</li><li>如果是POST方法, 还可能要读取客户端提交的数据</li><li>然后交给相应的handler处理请求</li><li>handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。</li></ul></li></ol><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li>如何监听端口:使用<code>net/http</code>包的<code>ListenAndServe</code>方法</li><li>如何接收客户端请求</li><li>如何分配handler</li></ul><pre><code class="go">// ListenAndServe方法实现func ListenAndServe(addr string, handler Handler) error &#123;    server := &amp;Server&#123;Addr: addr, Handler: handler&#125; //初始化一个Server对象    return server.ListenAndServe()//调用Server对象的方法ListenAndServe&#125;func ListenAndServe(addr string, handler Handler) error &#123;    server := &amp;Server&#123;Addr: addr, Handler: handler&#125; //初始化Server对象    return server.ListenAndServe()                  //调用Server对象的方法ListenAndServe&#125;func (srv *Server) ListenAndServe() error &#123;    addr := srv.Addr    ln, err := net.Listen(&quot;tcp&quot;, addr) //底层用TCP协议搭建了一个服务    if err != nil &#123;        return err    &#125;    return srv.Serve(ln) //调用srv.Serve监控我们设置的端口&#125;func (srv *Server) Serve(l net.Listener) error &#123;    ctx := context.WithValue(baseCtx, ServerContextKey, srv)    for &#123;        rw, err := l.Accept() //通过Listener接收请求        c := srv.newConn(rw)  //创建一个Conn        go c.serve(connCtx)   //单独开了一个goroutine，把这个请求的数据当做参数扔给这个conn去服务        //高并发体现:用户的每一次请求都是在一个新的goroutine去服务，相互不影响。    // 客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，    // 然后再传递到对应的handler，该handler中便可以读取到相应的header信息，这样保证了每个请求的独立性。    &#125;&#125;func (c *conn) serve(ctx context.Context) &#123;    for &#123;        w, err := c.readRequest(ctx)                //解析request        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) //获取相应的handler去处理请求    &#125;&#125;func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;    handler := sh.srv.Handler    if handler == nil &#123;        handler = DefaultServeMux    &#125;    handler.ServeHTTP(rw, req)&#125;</code></pre><img src="/2023/01/10/web-gong-zuo-fang-shi/3.3.illustrator.png" class="" title="一个http连接处理流程"><h2 id="Go的http包"><a href="#Go的http包" class="headerlink" title="Go的http包"></a>Go的http包</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google浏览器自动更新失败</title>
      <link href="/2023/01/05/google-liu-lan-qi-zi-dong-geng-xin-shi-bai/"/>
      <url>/2023/01/05/google-liu-lan-qi-zi-dong-geng-xin-shi-bai/</url>
      
        <content type="html"><![CDATA[<p>报错：</p><blockquote><p>无法启动更新检查（错误代码为 4: 0x80070005 — system level）</p></blockquote><p>解决方法：<br>快捷键 Win R 输入：services.msc，找到 “Google 更新服务 (gupdatem)”、“Google 更新服务 (gupdate)”服务，改为手动即可，再去更新Chrome。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn-install</title>
      <link href="/2022/12/21/yarn-install/"/>
      <url>/2022/12/21/yarn-install/</url>
      
        <content type="html"><![CDATA[<h2 id="yarn-install-报错："><a href="#yarn-install-报错：" class="headerlink" title="yarn install 报错："></a>yarn install 报错：</h2><blockquote><p>Error: unable to verify the first certificate</p></blockquote><pre><code>  at TLSSocket.onConnectSecure (node:_tls_wrap:1539:34)  at TLSSocket.emit (node:events:513:28)  at TLSSocket._finishInit (node:_tls_wrap:953:8)  at TLSWrap.ssl.onhandshakedone (node:_tls_wrap:734:12)</code></pre><p>解决方法：暂时关闭 ssl 验证 <code>yarn config set strict-ssl false</code></p><h2 id="yarn-start-报错："><a href="#yarn-start-报错：" class="headerlink" title="yarn start 报错："></a>yarn start 报错：</h2><blockquote><p>node:internal&#x2F;errors:478</p></blockquote><pre><code>ErrorCaptureStackTrace(err);^Error: ENOSPC: System limit for number of file watchers reached, watch &#39;/root/umc-ui&#39;</code></pre><p>解决方法：</p><pre><code class="go">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -pcat /proc/sys/fs/inotify/max_user_watches //查看是否修改成功</code></pre><h2 id="全局安装-yarn"><a href="#全局安装-yarn" class="headerlink" title="全局安装 yarn"></a>全局安装 yarn</h2><p>node -v</p><ul><li><blockquote><p>16 执行<code>corepack enable</code></p></blockquote></li><li>&lt;16 执行<code>npm i -g corepack</code></li></ul><h2 id="yarn-常用操作"><a href="#yarn-常用操作" class="headerlink" title="yarn 常用操作"></a>yarn 常用操作</h2><pre><code class="bash"># 初始化项目yarn init# 安装所有依赖yarn yarn install# 添加单个依赖yarn add [package]yarn add [package]@[version]yarn add [package]@[tag]# 添加依赖到不同种类的依赖yarn add [package] --dev  # dev dependenciesyarn add [package] --peer # peer dependencies# 升级单个依赖yarn up [package]yarn up [package]@[version]yarn up [package]@[tag]# 移除依赖yarn remove [package]# 升级yarn 本身yarn set version latestyarn set version from sources</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC-API</title>
      <link href="/2022/12/16/rpc-api/"/>
      <url>/2022/12/16/rpc-api/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC基本含义："><a href="#RPC基本含义：" class="headerlink" title="RPC基本含义："></a>RPC基本含义：</h2><p>远程过程调用(Remote Procedure Call),属于计算机通信协议。<br>允许A计算机调用B计算机的子程序而不用为这个交互作用编程，屏蔽了底层的网络通信细节</p><img src="/2022/12/16/rpc-api/RPC.webp" class="" title="RPC的调用过程"><ol><li>Client 通过本地调用，调用 Client Stub。</li><li>Client Stub 将参数打包（也叫 Marshalling）成一个消息，然后发送这个消息。</li><li>Client 所在的 OS 将消息发送给 Server。</li><li>Server 端接收到消息后，将消息传递给 Server Stub。</li><li>Server Stub 将消息解包（也叫 Unmarshalling）得到参数。</li><li>Server Stub 调用服务端的子程序（函数），处理完后，将最终结果按照相反的步骤返回给 Client。</li></ol><blockquote><p>Stub 负责调用参数和返回值的流化（serialization）、参数的打包和解包，以及网络层的通信。Client 端一般叫 Stub，Server 端一般叫 Skeleton</p></blockquote><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>google RPC</p><ol><li>支持多种语言，比如用Go语言实现gRPC服务,可以通过Java客户端调用gRPC服务提供的方法</li><li>基于IDL（Interface Definition Language）文件定义服务</li></ol><ul><li>gRPC服务预先定义好接口(名称&#x2F;入参&#x2F;返回值)。</li><li>服务端实现定义的接口</li><li>客户端,gRPC存根提供了跟服务端相同的方法</li><li>通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub</li></ul><ol start="3"><li>通信协议基于HTTP&#x2F;2设计</li><li>支持 Protobuf 和 JSON 序列化数据格式</li></ol><ul><li>Protobuf ：和语言无关的序列化框架，可以减少网络传输流量,提高通信效率</li></ul><h2 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h2><p>gRPC API接口常用的数据传输格式，对数据结构进行序列化。<br>既可以做数据通信协议，也可以作为数据格式</p><ol><li>数据传输速度快：传输时会把数据序列化为二进制数据</li></ol><ul><li>相对于XML和JSON的文本传输格式可以节省大量IO操作，提高传输速度</li></ul><ol start="2"><li>跨平台多语言</li></ol><ul><li>自带的编译工具 protoc可以基于protobuf定义文件，编译出不同语言的客户端&#x2F;服务端</li></ul><ol start="3"><li>扩展性&#x2F;兼容性</li></ol><ul><li>不破坏原有程序的基础手上更新已有的数据结构</li></ul><ol start="4"><li>基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端和客户端接口</li></ol><h2 id="Protocol-Buffers在gRPC接口中的作用"><a href="#Protocol-Buffers在gRPC接口中的作用" class="headerlink" title="Protocol Buffers在gRPC接口中的作用"></a>Protocol Buffers在gRPC接口中的作用</h2><ol><li>定义数据结构</li></ol><pre><code class="go">// SecretInfo contains secret details.message SecretInfo &#123;    string name = 1;    string secret_id  = 2;    string username   = 3;    string secret_key = 4;    int64 expires = 5;    string description = 6;    string created_at = 7;    string updated_at = 8;&#125;</code></pre><ol start="2"><li>定义服务接口</li></ol><pre><code class="go">// 此处定义了一个Cache服务,服务包含ListSecrets和ListPolicies两个API接口// Cache implements a cache rpc service.service Cache&#123;  rpc ListSecrets(ListSecretsRequest) returns (ListSecretsResponse) &#123;&#125;  rpc ListPolicies(ListPoliciesRequest) returns (ListPoliciesResponse) &#123;&#125;&#125;</code></pre><ol start="3"><li>通过 protobuf 序列化和反序列化，提升传输效率</li></ol><h2 id="gRPC使用"><a href="#gRPC使用" class="headerlink" title="gRPC使用"></a>gRPC使用</h2><h3 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h3><pre><code class="bash"># 第一步：安装 protobuf$ cd /tmp/$ git clone -b v3.21.1 --depth=1 https://github.com/protocolbuffers/protobuf$ cd protobuf$ ./autogen.sh$ ./configure$ make$ make install $ protoc --version # 查看 protoc 版本，成功输出版本号，说明安装成功libprotoc 3.21.1# 第二步：安装 protoc-gen-gogo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2# 第三步:客户端和服务器代码# 生成的 .pb.go 文件在输出目录中的放置位置取决于编译器标志protoc   --go_out=. --go_opt=paths=source_relative  helloworld/helloworld.protoprotoc   --go-grpc_out=. --go-grpc_opt=paths=source_relative helloworld/helloworld.proto</code></pre><p>编译器标志：输出模式</p><ol><li>paths&#x3D;import: 默认输出模式，输出文件将存放在以GO软件包的导入路径命名的目录中<br>输入文件:&#x2F;root&#x2F;protos&#x2F;buzz.proto<br>GO文件导入路径：example.com&#x2F;project&#x2F;protos&#x2F;fizz<br>输出文件：&#x2F;root&#x2F;..&#x2F;example.com&#x2F;project&#x2F;protos&#x2F;fizz&#x2F;buzz.pb.go</li><li>paths&#x3D;source_relative: 输出文件将与输入文件位于同一相对目录中<br>输入文件:protos&#x2F;buzz.proto<br>输出文件:protos&#x2F;buzz.pb.go。</li><li>module&#x3D;$PREFIX:输出文件会被放置在一个以 Go 软件包的导入路径命名的目录中，但指定的目录前缀会从输出文件名中移除<br>输入文件：protos&#x2F;buzz.proto<br>go导入路径：example.com&#x2F;project&#x2F;protos&#x2F;fizz<br>前缀：example.com&#x2F;project<br>输出文件：protos&#x2F;fizz&#x2F;buzz.pb.go</li></ol><blockquote><p>Go 导入路径与 .proto 文件中的 package 说明符之间没有关联。后者只与 protobuf 命名空间相关，而前者仅与 &gt;  Go 命名空间相关。此外，Go 导入路径与 .proto 导入路径之间没有任何关联。</p></blockquote><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h4 id="执行-x2F-autogen-sh报错"><a href="#执行-x2F-autogen-sh报错" class="headerlink" title="执行.&#x2F;autogen.sh报错"></a>执行.&#x2F;autogen.sh报错</h4><ol><li>.&#x2F;autogen.sh: line 41: autoreconf: command not found<br>解决方法：yum安装 autoconf</li><li>Can’t exec “aclocal”: No such file or directory at &#x2F;usr&#x2F;share&#x2F;autoconf&#x2F;Autom4te&#x2F; FileUtils.pm line 326.<br>解决方法：yum 安装automake</li><li>configure.ac:109: error: possibly undefined macro: AC_PROG_LIBTOOL.If this token and others are legitimate, please use m4_pattern_allow.See the Autoconf documentation.<br>解决方法：yum 安装libtool</li></ol><h4 id="执行-x2F-configure报错"><a href="#执行-x2F-configure报错" class="headerlink" title="执行.&#x2F;configure报错"></a>执行.&#x2F;configure报错</h4><ol><li>configure: error: in <code>/tmp/protobuf&#39;:configure: error: C++ preprocessor &quot;/lib/cpp&quot; fails sanity check  See &#39;config.log&#39; for more details 解决方法：由于c++编译器的相关package没有安装，yum 安装</code>yum install glibc-headers gcc-c++&#96;</li></ol><h2 id="gRPC-demo-实现"><a href="#gRPC-demo-实现" class="headerlink" title="gRPC demo 实现"></a>gRPC demo 实现</h2><ol><li>定义gPRC服务</li><li>生成客户端和服务器代码</li><li>实现gRPC服务</li><li>实现gRPC客户端</li></ol><pre><code class="go">tree├── client│   └── main.go├── helloworld│   ├── helloworld.pb.go│   └── helloworld.proto└── server    └── main.go</code></pre><p>client:存放客户端代码<br>helloworld:存放服务的IDL定义<br>server：存放server目录</p><h3 id="proto文件：定义服务"><a href="#proto文件：定义服务" class="headerlink" title="proto文件：定义服务"></a>proto文件：定义服务</h3><p>编译命令：<br><code>protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto</code></p><h3 id="服务方法类型"><a href="#服务方法类型" class="headerlink" title="服务方法类型"></a>服务方法类型</h3><ol><li>简单模式:客户端发起一次请求，服务端响应一个数据</li></ol><pre><code class="go">rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</code></pre><ol start="2"><li>服务端数据流模式:客户端发送一个请求，服务器返回数据流响应，客户端从流中读取数据直到为空</li></ol><pre><code class="go">rpc SayHello (HelloRequest) returns (stream HelloReply) &#123;&#125;</code></pre><ol start="3"><li>客户端数据流模式：客户端将消息以流的方式发送给服务器，服务器全部处理完成之后返回一次响应。</li></ol><pre><code class="go"> rpc SayHello (stream HelloRequest) returns (HelloReply) &#123;&#125;</code></pre><ol start="4"><li>双向数据流模式:客户端和服务端都可以向对方发送数据流，这个时候双方的数据可以同时互相发送</li></ol><pre><code class="go">rpc SayHello (stream HelloRequest) returns (stream HelloReply) &#123;&#125;</code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><img src="/2022/12/16/rpc-api/grpc-vs-restful.webp" class="" title="接口类型比较">]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO中的while</title>
      <link href="/2022/12/15/go-zhong-de-while/"/>
      <url>/2022/12/15/go-zhong-de-while/</url>
      
        <content type="html"><![CDATA[<p>GO语言中没有while关键字，所以需要使用for代替</p><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    sum := 1    for sum &lt; 1000 &#123;        sum += sum    &#125;    fmt.Println(sum)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-maps-and-memory-leaks-in-go</title>
      <link href="/2022/12/10/fan-yi-maps-and-memory-leaks-in-go/"/>
      <url>/2022/12/10/fan-yi-maps-and-memory-leaks-in-go/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-中的-Maps-和内存泄漏"><a href="#Go-中的-Maps-和内存泄漏" class="headerlink" title="Go 中的 Maps 和内存泄漏"></a>Go 中的 Maps 和内存泄漏</h1><p>待完成<br><a href="https://teivah.medium.com/maps-and-memory-leaks-in-go-a85ebe6e7e69">https://teivah.medium.com/maps-and-memory-leaks-in-go-a85ebe6e7e69</a></p><p><b>长话短说：</b> map 在内存中会一直增长,不会缩小。因此如果它引起了一些内存问题，你可以尝试不同的选项：比如强制 GO 重新创建 map 或者使用指针。</p><p>使用 Go 语言的时候,我们需要了解 map 如何扩大和缩小的一些重要特征。深入了解这一点可以预防会导致内存泄漏的问题。</p><p>首先为了看这个问题的具体的例子，我们假设一个场景，在这个场景下我们会使用下面的 map:</p><pre><code class="go">m:=make(map[int][128]byte)</code></pre><p>m 的每一个值都是一个 128 byte 的数组。我们会执行下面的操作：</p><ol><li>分配一个空的 map</li><li>添加一百万个元素</li><li>移除所有元素,运行垃圾回收(GC)</li></ol><p>在每一步完成后，我们想要打印堆的大小(使用工具函数 <code>printAlloc</code> )。这个程序向我们展示了这个例子里内存的变化:</p><pre><code class="go">func main() &#123;    n := 1_000_000    m := make(map[int][128]byte)    printAlloc()    for i := 0; i &lt; n; i++ &#123; // Adds 1 million elements        m[i] = [128]byte&#123;&#125;    &#125;    printAlloc()    for i := 0; i &lt; n; i++ &#123; // Deletes 1 million elements        delete(m, i)    &#125;    runtime.GC() // Triggers a manual GC    printAlloc()    runtime.KeepAlive(m) // Keeps a reference to m so that the map isn’t collected&#125;func printAlloc() &#123;    var m runtime.MemStats    runtime.ReadMemStats(&amp;m)    fmt.Printf(&quot;%d KB\n&quot;, m.Alloc/1024)&#125;</code></pre><p>我们分配一个空的 map,添加了 100 万个元素,又移除了 100 万个元素,然后运行一个垃圾回收器。我们也使用了 <code>runtime.KeepAlive</code> 确保对 map 的引用，这样 map 也不会被回收。让我们运行这个例子：</p><blockquote><p>0 MB &lt;– After m is allocated<br>461 MB &lt;– After we add 1 million elements<br>293 MB &lt;– After we remove 1 million elements</p></blockquote><p>我们能够观察到什么呢?刚开始堆的大小是极小的。向 map 里面添加 100 万个元素之后,它开始明显增长。但是如果我们期望堆大小在移除所有元素之后有所减少，这在 GO 里是不可能的。最后，即使 GC 已经回收了所有元素,堆大小仍然还有 293M。尽管内存减少了,但是并没有达到我们的期望。根本原因是什么呢？我们需要深入了解 Go 语言中 map 是如何工作的。</p><p>map 会提供一个无序的键值对集合,并且里面的键名都不一样。在 Go 语言中,map 是基于哈希表数据结构：这是一个数组并且其中的每一个元素都是一个指针，指向一桶键值对,如图 1 所示。</p><img src="/2022/12/10/fan-yi-maps-and-memory-leaks-in-go/hash_table.webp" class="" title="图1-关注桶0的哈希表示例"><p>每个桶都是一个大小固定的数组,有 8 个元素。在插入到一个满桶(桶溢出)的情况下,Go 会创建一个新的 8 个元素的桶并且连接到前面那个桶。图 2 展示了这个例子：</p><img src="/2022/12/10/fan-yi-maps-and-memory-leaks-in-go/buket.webp" class="" title="图2-在桶溢出的情况下，Go会分配一个新的桶并连接到前面的桶"><p>从底层来看,一个 Go map 就是一个指针,指向 <code>runtime.hmap</code> 结构。这个结构包含了多个域，如 B 域,它给出了 map 中桶的数量：</p><pre><code class="go">type hmap struct &#123;    B uint8 // log_2 of # of buckets            // (可以容纳 系数* 2^B 项)    // ...&#125;</code></pre><p>在添加 100 万个元素以后,B 的值为 18,这意味着有 2<sup>18</sup>&#x3D;262144 个桶。当我们移除这些元素的时候,B 的值是多少呢?仍然是 18。所以 map 仍然包含了同样数量的桶。</p><p>原因就是 map 中的桶的数量不能减少。因此从 map 中移除元素并不影响已经存在的桶的数量;它只是把桶内的插槽归零。map 只会增长,出现更多的桶;但从来不会减少。</p><p>在之前的例子中,我们从 461M 到 293M,因为元素被回收了,但是运行 GC 并不影响 map 本身。即使是额外桶(因为桶溢出而创建的桶)的数量也会保持一样。</p><p>我们退一步讨论：map 不能缩小这个事什么时候会成为一个问题?假设使用 <code>map[int][128]byte</code> 构造一个 cache。这个 map 包含每个用户的 ID(int)，一个 128 byte 的序列。现在假设我们想要保存最后的 1000 个用户。map 的 size 将会保持为一个常量,所以我们不需要担心 map 不能缩小的问题。</p><p>但是,假如我们想要保存一小时内的数据呢。与此同时公司决定在黑色星期五开展一个大促销：在一小时内可能会有数以百万的用户连接我们的系统。但是之后的几天里,我们的 map 会包含和高峰期的时候同样数量的桶。这就解释了为什么在这种情况下我们会遇到内存消耗大但是并没有明显减少的情况。</p><p>如果我们不想要手动重启服务来清除被 map 消耗的内存数量有什么解决方案呢?一个解决方案是有规律的重建一个当前 map 的拷贝。例如,我们可以每隔一个小时构建一个新的 map,这个 map 会复制所有的元素并释放之前的那个 map。这个方案的主要缺陷是在复制和直到下一次垃圾回收之前，短期内我们可能会消耗当前内存的两倍。</p><p>另外一个解决方案是修改 map 类型来存储一个数组指针：<code>map[int]*[128]byte</code>。它并不能解决桶数量大的问题;但是每个桶的入口将会保留指针的大小,而不是128字节(64位系统上的8字节,32位系统上的4字节)。</p><p>回到最初的设想场景,让我们来比较一下每个步骤之后的每种map类型的内存消耗。结果如下面的表格所示：</p><table><thead><tr><th>Step</th><th><code>map[int][128]byte</code></th><th><code>map[int]*[128]byte</code></th></tr></thead><tbody><tr><td>Allocate an empty map</td><td>0 MB</td><td>0 MB</td></tr><tr><td>Add 1 million elements</td><td>461 MB</td><td>182 MB</td></tr><tr><td>Remove all the elements and run a GC</td><td>293 MB</td><td>38 MB</td></tr></tbody></table><p>正如我们所看到的，移除所有元素之后,使用 <code>map[int]*[128]byte</code> 类型的需要的内存数量很明显更少。而且在这个案例中，由于做了一些优化来减少内存消耗，所以高峰期需要的内存数量也没那么重要了。</p><p>【注意】如果key或者valu超过128字节,GO就不会直接在map桶中存储它。而是储存一个指向key或者value的指针</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如我们所见,添加n个元素到map中，然后移除所有元素意味着在内存中保持相同的桶数量。所以必须记住：因为map在size上只会增长，所以内存消耗也只会增长。目前没有自动化策略去缩小它。如果因为这个引起了高内存消耗,我们可以尝试不同的方法去解决这个问题，比如重新创建map或者使用指针来检查它是否可以被优化。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证机制</title>
      <link href="/2022/12/10/ren-zheng-ji-zhi/"/>
      <url>/2022/12/10/ren-zheng-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>基础认证</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>前端将 <code>用户名:密码</code> 进行base64编码后，放到 HTTP Authorization Header 中。<br>后端接受到Http请求后，解析出Authorization Header 中的 base64 字符串，获取用户名和密码，并将用户名和密码根数据库记录中的值进行比较<br>如果匹配则认证通过</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>不安全，密码和反编译</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>将它和 SSL 配合使用，来确保整个认证过程是安全的。比如支持前端通过用户名和密码登录，使用Basic认证，但是前后端使用HTTPS通信，保证安全性</p><p>注意：不要在请求参数中使用明文密码，也不要在任何存储中保存明文密码。</p><pre><code class="go">basic=`echo -n &#39;admin:Admin@2021&#39;|base64`curl -XPOST -H&quot;Authorization: Basic $&#123;basic&#125;&quot; http://127.0.0.1:8080/login</code></pre><h2 id="OAuth2-0——开放授权"><a href="#OAuth2-0——开放授权" class="headerlink" title="OAuth2.0——开放授权"></a>OAuth2.0——开放授权</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><p>允许用户让第三方应用访问该用户再某一web服务器上存储的私密资源，而无需给第三方应用提供用户名和密码。</p><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h3><p>概念：用户把用户名&#x2F;密码直接提供给第三方应用用来换取令牌<br>前提：无法使用其他授权方式且用户高度信任第三方应用<br>过程：</p><ol><li>网站 A 向用户发出获取用户名和密码的请求</li><li>用户同意后，网站 A 凭借用户名和密码向网站 B 换取令牌</li><li>网站 B 验证用户身份后，给出网站 A 令牌，网站 A 凭借令牌可以访问网站 B 对应权限的资源。</li></ol><h3 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a>隐藏式</h3><p>适用于前端应用<br>过程：</p><ol><li>A 网站提供一个跳转到 B 网站的链接，用户点击后跳转至 B 网站，并向用户请求授权；</li><li>用户登录 B 网站，同意授权后，跳转回 A 网站指定的重定向 redirect_url 地址，并携带 B 网站返回的令牌，用户在 B 网站的数据给 A 网站使用。</li></ol><h3 id="凭借式"><a href="#凭借式" class="headerlink" title="凭借式"></a>凭借式</h3><p>适用于命令行应用<br>过程：</p><ol><li>应用 A 在命令行向应用 B 请求授权，此时应用 A 需要携带应用 B 提前颁发的 secretID 和 secretKey，其中 secretKey 出于安全性考虑，需在后端发送；</li><li>应用 B 接收到 secretID 和 secretKey，并进行身份验证，验证通过后返回给应用 A 令牌。</li></ol><h2 id="Bearer——令牌认证"><a href="#Bearer——令牌认证" class="headerlink" title="Bearer——令牌认证"></a>Bearer——令牌认证</h2><h3 id="核心：bearer-token"><a href="#核心：bearer-token" class="headerlink" title="核心：bearer token"></a>核心：bearer token</h3><p>bearer token算是一个加密字符串,由服务端根据密钥生成。需要和HTTPS一起使用保证安全性</p><h3 id="必要条件："><a href="#必要条件：" class="headerlink" title="必要条件："></a>必要条件：</h3><p>客户端在请求服务端时，必须在请求头中包含Authorization: Bearer 。<br>服务端收到请求后，解析出 ，并校验 的合法性，如果校验通过，则认证通过</p><h3 id="token-编码方式："><a href="#token-编码方式：" class="headerlink" title="token 编码方式："></a>token 编码方式：</h3><p>JSON WEB TOKEN(JWT)：Bearer Token 的一个具体实现</p><h2 id="基于-JWT-的-Token-认证机制"><a href="#基于-JWT-的-Token-认证机制" class="headerlink" title="基于 JWT 的 Token 认证机制"></a>基于 JWT 的 Token 认证机制</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>为了区分用户和保证安全，必须对 API 请求进行鉴权，但是不能要求每一个请求都进行登录操作</p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在第一次登录之后产生一个有一定有效期的 token，并将它存储在浏览器的 Cookie 或 LocalStorage 之中。之后的请求都携带这个 token ，请求到达服务器端后，服务器端用这个 token 对请求进行认证。在第一次登录之后，服务器会将这个 token 用文件、数据库或缓存服务器等方法存下来，用于之后请求中的比对。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>无需在服务端存储用户数据，可以减轻服务端压力</li><li>采用 JSON 数据格式，比较易读</li><li>使用 JWT Token 可以跨语言</li><li>属于轻量级</li></ol><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>客户端【前端】使用用户名和密码请求登录</li><li>服务端【后端】收到请求后，去验证用户名和密码。</li><li>如果用户名和密码跟数据库记录不一致，则验证失败；如果一致则验证通过，服务端会签发一个 Token 返回给客户端</li><li>客户端收到请求后会将 Token 缓存起来，比如放在浏览器 Cookie 中或者 LocalStorage 中，之后每次请求都会携带该 Token</li><li>服务端收到请求后，会验证请求中的 Token，验证通过则进行业务逻辑处理，处理完后返回处理后的结果。</li></ol><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Header.Payload.Signature</p><pre><code class="go">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NDI4NTY2MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2MzUwODA2MzcsInN1YiI6ImFkbWluIn0.Shw27RKENE_2MVBq7-c8OmgYdF92UmdwS8xE-Fts2FM</code></pre><img src="/2022/12/10/ren-zheng-ji-zhi/jwt.webp" class="" title="jwt"><h2 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h2><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>包含信息：Token类型+Token所使用的加密算法</p><pre><code class="json">&#123;  &quot;typ&quot;: &quot;JWT&quot;,//Token类型  &quot;alg&quot;: &quot;HS256&quot;//加密算法&#125;//base64编码后为eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>包含信息：JWT 标准中注册的声明+公共的声明+私有的声明</p><pre><code class="json">&#123; &quot;aud&quot;: &quot;iam.authz.marmotedu.com&quot;, &quot;exp&quot;: 1604158987,//开发环境7天，生产环境2小时 &quot;iat&quot;: 1604151787, &quot;iss&quot;: &quot;iamctl&quot;, &quot;nbf&quot;: 1604151787&#125;</code></pre><img src="/2022/12/10/ren-zheng-ji-zhi/payload.webp" class="" title="payload"><h3 id="signature-签名"><a href="#signature-签名" class="headerlink" title="signature 签名"></a>signature 签名</h3><p>生成方式：</p><ol><li>将 Header 和 Payload 分别 base64 编码后，用 . 连接</li><li>使用 Header 中声明的加密方式，利用 secretKey(密钥，保存在服务器中，通过配置文件来保存) 对连接后的字符串进行加密，加密后的字符串即为最终的 Signature。<img src="/2022/12/10/ren-zheng-ji-zhi/config.webp" class="" title="密钥配置文件">步骤：</li><li>签名后服务端会返回生成的 Token，客户端下次请求会携带该 Token。</li><li>服务端收到 Token 后会解析出 header.payload，</li><li>服务端用相同的加密算法和密钥对 header.payload 再进行一次加密，得到 Signature。</li><li>对比加密后的 Signature 和收到的 Signature 是否相同，如果相同则验证通过，不相同则返回 HTTP 401 Unauthorized 的错误</li></ol><hr><h2 id="iam的访问认证"><a href="#iam的访问认证" class="headerlink" title="iam的访问认证"></a>iam的访问认证</h2><ul><li>IAM 项目的 iam-apiserver 服务，提供了 IAM 系统的管理流功能接口，它的客户端可以是前端（这里也叫控制台），也可以是 App 端。</li><li>为了方便用户在 Linux 系统下调用，IAM 项目还提供了 iamctl 命令行工具。</li><li>为了支持在第三方代码中调用 iam-apiserver 提供的 API 接口，还支持了 API 调用。</li><li>为了提高用户在代码中调用 API 接口的效率，IAM 项目提供了 Go SDK</li></ul><p>控制台&#x2F;app端：需要使用<code>用户名：密码</code>登陆系统—&gt;Basic认证<br>iamctl&#x2F;API调用&#x2F;GO SDK：不需要登录—&gt; Bearer认证</p><blockquote><p>Basic 认证需要用户名和密码，Bearer 认证则需要密钥，所以 iam-apiserver 需要将用户名&#x2F;密码&#x2F;密钥等信息保存在后端的 MySQL 中，持久存储起来。</p></blockquote><img src="/2022/12/10/ren-zheng-ji-zhi/design.webp" class=""><h3 id="区别控制流和数据流"><a href="#区别控制流和数据流" class="headerlink" title="区别控制流和数据流"></a>区别控制流和数据流</h3><p>将密钥的 CURD 操作也放在了 iam-apiserver 中，但是 iam-authz-server 需要用到这些密钥信息。 iam-authz-server 需要用到这些密钥信息：<br>解决方法：</p><ol><li>iam-authz-server 通过 gRPC API 请求 iam-apiserver，获取所有的密钥信息</li><li>当 iam-apiserver 有密钥更新时，会 Pub 一条消息到 Redis Channel 中。因为 iam-authz-server 订阅了同一个 Redis Channel，iam-authz-searver 监听到 channel 有新消息时，会获取、解析消息，并更新它缓存的密钥信息。确保 iam-authz-server 内存中缓存的密钥和 iam-apiserver 中的密钥保持一致</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iam项目的部署</title>
      <link href="/2022/12/08/iam-xiang-mu-de-bu-shu/"/>
      <url>/2022/12/08/iam-xiang-mu-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="IAM的核心功能使用步骤"><a href="#IAM的核心功能使用步骤" class="headerlink" title="IAM的核心功能使用步骤"></a>IAM的核心功能使用步骤</h2><h3 id="创建平台资源"><a href="#创建平台资源" class="headerlink" title="创建平台资源"></a>创建平台资源</h3><ol><li>用户通过前端请求 iam-apiserver 提供的 RESTful API 接口完成用户、密钥、授权策略的增删改查</li><li>iam-apiserver 将这些资源持久化存储在MySQL中</li><li>为了确保通信安全，客户端访问服务端都是通过HTTPS协议</li></ol><h3 id="请求API完成资源授权"><a href="#请求API完成资源授权" class="headerlink" title="请求API完成资源授权"></a>请求API完成资源授权</h3><ol><li>用户通过前端请求 iam-authz-server 提供的 &#x2F;v1&#x2F;authz 接口进行资源授权</li></ol><ul><li>先通过密钥认证</li><li>认证通过后,&#x2F;v1&#x2F;authz 接口会查询授权策略，决定资源请求是否被允许</li></ul><ol start="2"><li>iam-authz-server 将密钥和策略信息缓存在内存中，实现快速查询，提高&#x2F;v1&#x2F;authz接口性能</li><li>如何实现密钥和策略信息的缓存</li></ol><ul><li>iam-authz-server 调用 iam-apiserver 提供的 gRPC接口，将上述信息缓存到内存中</li><li>为了保持内存中的缓存和iam-apiserver保持一致，iam-apiserver有上述信息被更新的时候，iam-apiserver 会往特定的 Redis Channel（iam-authz-server 也会订阅该 Channel）中发送 PolicyChanged 和 SecretChanged 消息。</li><li>当 iam-authz-server 监听到有新消息时就会获取并解析消息，根据消息内容判断是否需要重新调用 gRPC 接来获取密钥和授权策略信息，再更新到内存中。</li></ul><h3 id="授权日志分析"><a href="#授权日志分析" class="headerlink" title="授权日志分析"></a>授权日志分析</h3><ol><li>iam-authz-server将授权日志上报到redis高速缓存中</li><li>iam-pump异步消费授权日志，把清理后的数据保存在 MongoDB 中，供运营系统查询</li></ol><ul><li>iam-authz-server 将授权日志保存在 Redis 中，可以最大化减少写入延时。</li><li>不保存在内存中是因为授权日志量我们没法预测，当授权日志量很大时，很可能会将内存耗尽，造成服务中断。</li></ul><h3 id="运营平台授权数据展示"><a href="#运营平台授权数据展示" class="headerlink" title="运营平台授权数据展示"></a>运营平台授权数据展示</h3><img src="/2022/12/08/iam-xiang-mu-de-bu-shu/iam-operating-system.webp" class="" title="iam操作系统前后端分离架构"><p>总结：</p><blockquote><ol><li>首先，用户通过调用 iam-apiserver 提供的 RESTful API 接口完成注册和登录系统，</li><li>再调用接口创建密钥和授权策略。</li><li>创建完密钥对和授权策略之后，IAM 可以通过调用 iam-authz-server 的授权接口完成资源的授权。<ul><li>具体来说，iam-authz-server 通过 gRPC 接口获取 iam-apiserver 中存储的密钥和授权策略信息，通过 JWT 完成认证之后，再通过 ory&#x2F;ladon 包完成资源的授权。i</li><li>iam-pump 组件异步消费 Redis 中的数据，并持久化存储在 MongoDB 中，供 iam-operating-system 运营平台展示。</li><li>最后，IAM 相关的产品、研发人员可以通过 IAM 的运营系统 iam-operating-system 来查看 IAM 系统的使用情况，进行运营分析。例如某个用户的授权 &#x2F; 失败次数、授权失败时的授权信息等。</li></ul></li></ol></blockquote><h2 id="iam主要功能"><a href="#iam主要功能" class="headerlink" title="iam主要功能"></a>iam主要功能</h2><ol><li>认证：用来判断是否是平台的合法用户，比如使用用户名和密码</li><li>授权：用来判断是否可以访问平台的某类资源</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7-防火墙端口</title>
      <link href="/2022/11/30/centos7-fang-huo-qiang-duan-kou/"/>
      <url>/2022/11/30/centos7-fang-huo-qiang-duan-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><pre><code class="bash">lsof -i:8000</code></pre><h2 id="开启-x2F-关闭端口"><a href="#开启-x2F-关闭端口" class="headerlink" title="开启&#x2F;关闭端口"></a>开启&#x2F;关闭端口</h2><pre><code class="bash">firewall-cmd --zone=public --add-port=5672/tcp --permanent   # 开放5672端口firewall-cmd --zone=public --remove-port=5672/tcp --permanent  #关闭5672端口firewall-cmd --reload   # 配置立即生效</code></pre><h2 id="查看防火墙开放的所有端口"><a href="#查看防火墙开放的所有端口" class="headerlink" title="查看防火墙开放的所有端口"></a>查看防火墙开放的所有端口</h2><pre><code class="bash">firewall-cmd --zone=public --list-ports</code></pre><h2 id="全局关闭防火墙"><a href="#全局关闭防火墙" class="headerlink" title="全局关闭防火墙"></a>全局关闭防火墙</h2><pre><code class="bash">systemctl stop firewalld.service</code></pre><h2 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h2><pre><code class="bash"> firewall-cmd --state</code></pre><h2 id="检查端口被进程占用情况"><a href="#检查端口被进程占用情况" class="headerlink" title="检查端口被进程占用情况"></a>检查端口被进程占用情况</h2><pre><code class="bash">netstat -lnpt |grep 5672</code></pre><h2 id="查看进程的详细信息"><a href="#查看进程的详细信息" class="headerlink" title="查看进程的详细信息"></a>查看进程的详细信息</h2><pre><code class="bash">ps pid</code></pre><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><pre><code class="bash">kill -9 pid</code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-go-web服务</title>
      <link href="/2022/11/29/16-go-web-fu-wu/"/>
      <url>/2022/11/29/16-go-web-fu-wu/</url>
      
        <content type="html"><![CDATA[<img src="/2022/11/29/16-go-web-fu-wu/web%E6%9C%8D%E5%8A%A1.webp" class="" title="web服务分类"><blockquote><p>前提：要实现一个web服务，必须先选择通信协议和通信格式。如果服务本身主要是提供REST 风格的API，则使用HTTP+JSON。反之则使用gRpc+Protobuf</p></blockquote><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>概念：根据(HTTP方法, 请求路径)匹配到处理这个请求的函数，最终由该函数处理这次请求，并返回结果</p><img src="/2022/11/29/16-go-web-fu-wu/%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D.webp" class="" title="路由匹配"><p>如上图所示：</p><ul><li>最终这个请求由<code>Delete(c *gin.Context)</code>处理</li><li>参数c存放了请求参数</li><li>在函数Delete中进行业务处理(参数解析-&gt;参数校验-&gt;逻辑处理-&gt;返回结果)：也是web服务的核心诉求</li></ul><h3 id="路由分组"><a href="#路由分组" class="headerlink" title="路由分组"></a>路由分组</h3><p>原因：API 接口随着需求的更新迭代，可能会有多个版本，为了便于管理，所以需要进行路由分组</p><h3 id="一进程多服务"><a href="#一进程多服务" class="headerlink" title="一进程多服务"></a>一进程多服务</h3><p>原因：避免为相同功能启动多个进程<br>典型例子：在一个服务进程中，同时开启 HTTP 服务的 80 端口和 HTTPS 的 443 端口对内的服务，访问 80 端口，简化服务访问复杂度；对外的服务，访问更为安全的 HTTPS 服务；此时有了</p><hr><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>原因：进行http请求的时候需要针对每一次请求都设置一些通用的操作，比如添加 Header、添加 RequestID、统计请求次数等</p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><ul><li>方式1：基于用户名和密码</li><li>方式2：基于Token</li></ul><h3 id="RequestID"><a href="#RequestID" class="headerlink" title="RequestID"></a>RequestID</h3><p>原因：定位和跟踪某一次请求用来排障</p><h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><p>原因：项目前后端分离，前端访问地址和后端访问地址不同，会因为浏览器的同源策略产生跨域问题</p><hr><h2 id="Gin框架"><a href="#Gin框架" class="headerlink" title="Gin框架"></a>Gin框架</h2><p>基于net&#x2F;http包封装的开源框架</p><h3 id="选择web框架的考虑因素"><a href="#选择web框架的考虑因素" class="headerlink" title="选择web框架的考虑因素"></a>选择web框架的考虑因素</h3><ol><li>路由功能</li><li>是否具有中间件或者过滤功能</li><li>http的参数的解析和返回能力</li><li>性能，稳定性</li><li>使用门槛</li><li>社区活跃度</li></ol><hr><h3 id="http-x2F-https支持"><a href="#http-x2F-https支持" class="headerlink" title="http&#x2F;https支持"></a>http&#x2F;https支持</h3><pre><code class="go">// 一进程多端口// 开启http服务insecureServer := &amp;http.Server&#123;    Addr:         &quot;:8080&quot;,    Handler:      router(),    ReadTimeout:  5 * time.Second,    WriteTimeout: 10 * time.Second,&#125;// 开启https端口secureServer := &amp;http.Server&#123;    Addr:         &quot;:8443&quot;,    Handler:      router(),    ReadTimeout:  5 * time.Second,    WriteTimeout: 10 * time.Second,&#125;</code></pre><hr><h3 id="json-数据支持"><a href="#json-数据支持" class="headerlink" title="json 数据支持"></a>json 数据支持</h3><ol><li>通过c.ShouldBindJSON函数解析Body 中的 JSON 格式数据参数</li><li>通过c.JSON函数返回 JSON 格式的数据</li></ol><pre><code class="go">if err := c.ShouldBindJSON(&amp;product); err != nil &#123;    c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)    return&#125;c.JSON(http.StatusOK, product)</code></pre><hr><h3 id="路由匹配-1"><a href="#路由匹配-1" class="headerlink" title="路由匹配"></a>路由匹配</h3><h4 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h4><p>精确匹配——路由为 &#x2F;products&#x2F;:name</p><img src="/2022/11/29/16-go-web-fu-wu/%E8%B7%AF%E7%94%B1%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D.webp" class="" title="路由精确匹配"><h4 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h4><p>模糊匹配——路由为 &#x2F;products&#x2F;*name</p><img src="/2022/11/29/16-go-web-fu-wu/%E8%B7%AF%E7%94%B1%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D.webp" class="" title="模糊匹配"><hr><h3 id="路由分组-1"><a href="#路由分组-1" class="headerlink" title="路由分组"></a>路由分组</h3><p>Gin通过Group函数实现分组</p><pre><code class="go">func router() http.Handler &#123;    router := gin.Default()    productHandler := newProductHandler()    // 路由分组、中间件、认证    // 给所有属于 v1 分组的路由都添加 gin.BasicAuth 中间件，以实现认证功能    v1 := router.Group(&quot;/v1&quot;, gin.BasicAuth(gin.Accounts&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;colin&quot;: &quot;colin404&quot;&#125;))    &#123;        productv1 := v1.Group(&quot;/products&quot;)        &#123;            // 路由匹配            productv1.POST(&quot;&quot;, productHandler.Create)            productv1.GET(&quot;:name&quot;, productHandler.Get)        &#125;    &#125;    return router&#125;</code></pre><hr><h3 id="一进程多服务-1"><a href="#一进程多服务-1" class="headerlink" title="一进程多服务"></a>一进程多服务</h3><h4 id="go的并发"><a href="#go的并发" class="headerlink" title="go的并发"></a>go的并发</h4><p>Go语言支持并发,通过go关键词来开启一个goroutine(轻量级线程,其调度由GoLang运行时进行管理)</p><pre><code class="go">go 函数名( 参数列表 )</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>实现了2个相同的服务，分别监听在不同端口。</p><pre><code class="go">var eg errgroup.GroupinsecureServer := &amp;http.Server&#123;...&#125;secureServer := &amp;http.Server&#123;...&#125;// insecureServer// 启动一个 goroutine 去处理eg.Go(func() error &#123;  err := insecureServer.ListenAndServe()  if err != nil &amp;&amp; err != http.ErrServerClosed &#123;    log.Fatal(err)  &#125;  return err&#125;)// secureServereg.Go(func() error &#123;  err := secureServer.ListenAndServeTLS(&quot;server.pem&quot;, &quot;server.key&quot;)  if err != nil &amp;&amp; err != http.ErrServerClosed &#123;    log.Fatal(err)  &#125;  return err&#125;// 等待所有的 goroutine 结束后退出，返回的错误是一个出错的 errif err := eg.Wait(); err != nil &#123;  log.Fatal(err)&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译-Slice length vs. capacity in Go</title>
      <link href="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/"/>
      <url>/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://teivah.medium.com/slice-length-vs-capacity-in-go-af71a754b7d8">https://teivah.medium.com/slice-length-vs-capacity-in-go-af71a754b7d8</a></p><h1 id="Go-语言中的切片-length-和-capacity"><a href="#Go-语言中的切片-length-和-capacity" class="headerlink" title="Go 语言中的切片 length 和 capacity"></a>Go 语言中的切片 length 和 capacity</h1><p><b>长话短说</b>:切片长度是指切片中可访问元素的数量,而切片容量是指从切片第一个元素开始,数组中元素的数量。</p><hr><p>Go 开发者混淆或者没有完全理解切片 length 和 capacity 的现象非常普遍。理解这两个概念有利于高效地处理一些核心操作,比如初始化切片,使用 append 添加元素,复制,截取。而这种错误理解会导致切片滥用甚至内存泄漏。</p><p>在 Go 语言中, slice 是由数组返回的。这意味着切片的数据是持久化的存在一个数组形式的数据结构中。如果数组满了，切片可以处理添加元素的逻辑,或者如果数组几乎是空的话,切片也可以处理缩小数组的逻辑。</p><p>在计算机内部, 切片包含一个指向数组的指针,一个 length 属性和一个 capacity 属性。length 是切片包含的元素个数,而 capacity 是从切片第一个元素开始计算的后备数组的元素个数。让我们通过一些例子来让事情更清晰一些。首先通过给定的 length 和 capacity 初始化切片：</p><pre><code class="go">s := make([]int, 3, 6)  /// length 3, 容量 6 的切片</code></pre><p>代表 length 的第一个参数是必须的，但是代表 capacity 的第二个参数是可选参数。图 1 展示了这段代码在内存中的执行结果。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice.webp" class="" title="图1-一个长度3，容量6的切片"><p>这个例子里,<code>make</code> 创建了一个 6(capacity) 个元素的数组。但是因为 length 被设置为 3, 所以 Go 只初始化了前 3 个元素。而且由于 slice 被设置为 <code>[]int</code> 类型，所以前三个元素的初始值被设置为 <code>int</code> 的零值: 0。灰色元素是已经分配但还没被使用。</p><p>我们打印这个切片,可以得到 length 范围内的元素: <code>[0,0,0]</code>。如果我们设置 <code>s[1]</code> 为 1,切片的第二个元素会被修改，但是不会影响它的 length 和 capacity。图 2 说明了这一点。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice_update.webp" class="" title="图2——更新切片第二个元素:s[1]&#x3D;1"><p>但是, length 范围以外的元素即使已经在内存中分配了空间已经也是禁止访问的。举个例子, <code>s[4]=0</code> 就会引发下面的报错:</p><blockquote><p>panic: runtime error: index out of range [4] with length 3</p></blockquote><p>那我们怎样使用切片的剩余空间呢?答案是通过内置的 <code>append</code> 方法:</p><pre><code class="go">s = append(s, 2)</code></pre><p>这行代码会追加一个新的元素到已经存在的 <code>s</code> 切片。如图 3 所示,他会使用第一个灰色元素(已经被分配空间但还未使用)来存储元素 <code>2</code></p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slice_3.webp" class="" title="图3——追加元素到s"><p>此时切片的 length 会从 3 更新到 4,因为切片现在包含了 4 个元素。如果我们现在再追加 3 个元素,让背后的数组不够大的话会发生什么呢?</p><pre><code class="go">s=append(s,3,4,5)fmt.Println(s)</code></pre><p>运行这段代码,我们看到切片依然能够处理我们的请求:</p><blockquote><p>[0 1 0 2 3 4 5]</p></blockquote><p>数组是大小固定的结构,所以只能存储新元素到 4 。当我们想要插入元素 5 的时候,数组已经满了:此时 Go 会在内部另外创建一个数组：capacity 是原来的两倍,拷贝原数组中的所有元素,然后插入元素 5。图 4 展示了这个过程。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/new.webp" class="" title="图4——初始数组已满,GO创建了另一个数组并复制了所有的元素"><p>切片现在指向了新的后备数组。那之前的后备数组会发生什么呢?如果堆中分配了空间,且它不再被引用,那么最终会被垃圾收集器(GC)释放。(我们在 #95 错误中讨论了堆内存:”<a href="https://livebook.manning.com/book/100-go-mistakes-and-how-to-avoid-them/chapter-12/240">不理解栈和堆</a>“,并且在 #99 错误中学习了 GC 是如何工作的。)</p><p>截取切片会发生什么呢?截取是在数组或切片执行的操作,提供了半开区间范围。索引 1 是被包含的,而索引 2 是不被包含的。接下来的例子展示了这个影响，图 5 展示了内存中的结果：</p><pre><code class="go">s1 := make([]int,3,6)s2 := s1[1:3] //截取自索引1~3</code></pre><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/slicing.webp" class="" title="图5——s1和s2以不同的length和capacity引用了同一个后备数组"><p>首先 <code>s1</code> 作为 length 3 和 capacity 6 的切片被创建。当通过截取 <code>s1</code> 创建 <code>s2</code> 时,两个切片引用了同一个后备数组。但是 <code>s2</code> 是从索引 1 开始的。因此它的 length 和 capacity 和 s1 是不一样的(length 等于 2,capacity 为 5)。如果我们修改 <code>s1[0]</code> 或者 <code>s2[0]</code>,这个修改是作用域同一个数组的,因此会如图 6 所示在两个切片中都是可见的。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/visible_change.webp" class="" title="图6——因为s1和s2共用一个后备数组，所以修改一个元素会使得两个切片都会产生变化"><p>现在如果我们追加一个元素到 <code>s2</code> 会发生什么呢?接下来的代码也会修改 <code>s1</code> 么?</p><pre><code class="go">s2 = append(s2, 2)</code></pre><p>共享的后备数组会被修改,但是只有 <code>s2</code> 的 length 变了。图 7 展示了追加元素到 <code>s2</code> 的结果。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/append.webp" class="" title="图7——追加一个元素到s2"><p><code>s1</code> 仍然是一个 length 为 3,capacity 为 6 的切片。因此如果打印 <code>s1</code> 和 <code>s2</code>,添加的元素只在 <code>s2</code>中可见：</p><blockquote><p>s1&#x3D;[0 1 0], s2&#x3D;[1 0 2]</p></blockquote><p>理解这个行为非常重要，这样我们在使用 append 的时候不会做出错误的假设。</p><p>【注意】：在这些例子中,后备数组都是内部创建, GO 开发者不能直接获取。唯一的例外是：切片是从对现有数组进行切片创建的。</p><p>最后需要注意的一点是:假使我们一直追加元素到 s2 到后备数组变满会怎么样呢?就智能内存而言状态会是什么样? 让我们再添加 3 个元素，这样后备数组就不会有剩余的容量了：</p><pre><code class="go">s2 = append(s2, 3)s2 = append(s2, 4) // At this stage, the backing is already fulls2 = append(s2, 5)</code></pre><p>这段代码会使得 GO 创建另一个后备数组。图 8 展示了内存中的结果。</p><img src="/2022/11/25/fan-yi-slice-length-vs-capacity-in-go/figure8.webp" class="" title="图8——向s2追加元素直至后备元素没有剩余空间"><p>此时 s1 和 s2 指向了两个不同的数组。因为 s1 依旧 length 为 3,capacity 为 6,仍然有可用的缓存空间，所以它还是引用原来的数组。同时，新的后备数组通过从 s2 的第一个索引开始复制原数组创建。这就是为什么新数组从元素 1 而不是从元素 0 开始。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说, slice length 是切片中可用元素的个数,而 slice capacity 是后备数组中元素个数。向一个满切片(length &#x3D;&#x3D; capacity) 添加元素会创建一个新后备数组,这个数组拥有新的 capacity,然后从之前的数组中复制所有元素，修改切片指针指向新的数组。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-go-viper-cobra-pflag</title>
      <link href="/2022/11/22/15-go-viper-cobra-pflag/"/>
      <url>/2022/11/22/15-go-viper-cobra-pflag/</url>
      
        <content type="html"><![CDATA[<h2 id="如何构建应用框架"><a href="#如何构建应用框架" class="headerlink" title="如何构建应用框架"></a>如何构建应用框架</h2><h3 id="命令行参数解析-pflag-包"><a href="#命令行参数解析-pflag-包" class="headerlink" title="命令行参数解析 pflag 包"></a>命令行参数解析 pflag 包</h3><p>用来解析命令行参数【启动参数】，这些命令行参数可以影响命令的运行效果。</p><h4 id="flag-定义"><a href="#flag-定义" class="headerlink" title="flag 定义"></a>flag 定义</h4><p>一个命令行参数在 Pflag 包中会解析为一个 Flag 类型的变量，即:</p><pre><code class="go">type Flag struct &#123;    Name                string // flag长选项的名称    Shorthand           string // flag短选项的名称，一个缩写的字符    Usage               string // flag的使用文本    Value               Value  // flag的值    DefValue            string // flag的默认值    Changed             bool // 记录flag的值是否有被设置过    NoOptDefVal         string // 当flag出现在命令行，但是没有指定选项值时的默认值    Deprecated          string // 记录该flag是否被放弃    Hidden              bool // 如果值为true，则从help/usage输出信息中隐藏该flag    ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息    Annotations         map[string][]string // 给flag设置注解&#125;</code></pre><p>Flag 的值是一个 Value 类型的接口，通过将 Flag 的值抽象成一个 interface 接口，可以自定义 Flag 的类型了,只要实现了 Value 接口的结构体，就是一个新类型</p><pre><code class="go">type Value interface &#123;    String() string // 将flag类型的值转换为string类型的值，并返回string的内容    Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错    Type() string // 返回flag的类型，例如：string、int、ip等&#125;</code></pre><p>实际使用：</p><pre><code class="go">package mainimport (    &quot;fmt&quot;)type Value interface &#123;    String() string // 将flag类型的值转换为string类型的值，并返回string的内容    Set(string) error // 将string类型的值转换为flag类型的值，转换失败报错    Type() string // 返回flag的类型，例如：string、int、ip等&#125;type Flag struct &#123;    Name                string // flag长选项的名称    Shorthand           string // flag短选项的名称，一个缩写的字符    Usage               string // flag的使用文本    Value               Value  // flag的值    DefValue            string // flag的默认值    Changed             bool // 记录flag的值是否有被设置过    NoOptDefVal         string // 当flag出现在命令行，但是没有指定选项值时的默认值    Deprecated          string // 记录该flag是否被放弃    Hidden              bool // 如果值为true，则从help/usage输出信息中隐藏该flag    ShorthandDeprecated string // 如果flag的短选项被废弃，当使用flag的短选项时打印该信息    Annotations         map[string][]string // 给flag设置注解&#125;func (flag1 Flag) String() &#123;    fmt.Println(&quot;将flag类型的值转换为string类型的值，并返回string的内容&quot;)&#125;type Flag2 struct &#123;  Value               Value  // flag的值&#125;func (flag2 Flag2) String() &#123;    fmt.Println(&quot;自定义flag类型&quot;)&#125;func main() &#123;    var val Value    flag1 = new(Flag)    flag1.String()    flag2 = new(Flag2)    flag2.String()&#125;</code></pre><h4 id="FlagSet-定义"><a href="#FlagSet-定义" class="headerlink" title="FlagSet 定义"></a>FlagSet 定义</h4><p>预先定义好的 Flag 的集合<br>获取并使用 Flag 的方法：</p><ol><li>调用 NewFlagSet 创建一个 FlagSet,通过定义一个新的 FlagSet 来定义命令及其子命令的 Flag。</li></ol><pre><code class="go">var version boolflagSet:=pflag.NewFlagSet(&quot;test&quot;,pflag.ContinueOnError)flagSet.BoolVar(&amp;version,&quot;version&quot;,true,&quot;Print version information and quit.&quot;)</code></pre><ol start="2"><li>使用 Pflag 包定义的全局 FlagSet：CommandLine。实际上 CommandLine 也是由 NewFlagSet 函数创建的<br>在一些不需要定义子命令的命令行工具中，我们可以直接使用全局的 FlagSet</li></ol><pre><code class="go">import (    &quot;github.com/spf13/pflag&quot;)pflag.BoolVarP(&amp;version, &quot;version&quot;, &quot;v&quot;, true, &quot;Print version information and quit.&quot;)func BoolVarP(p *bool, name, shorthand string, value bool, usage string) &#123;  flag := CommandLine.VarPF(newBoolValue(value, p), name, shorthand, usage)  flag.NoOptDefVal = &quot;true&quot;&#125;</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><hr><ol><li>支持多种命令行参数定义方式</li></ol><ul><li>支持长选项、默认值和使用文本，并将标志的值存储在指针中</li></ul><pre><code class="go">var name=pflag.String(&quot;name&quot;,&quot;colin&quot;,&quot;Input ur name&quot;)</code></pre><ul><li>支持长选项、短选项、默认值和使用文本，并将标志的值存储在指针中</li></ul><pre><code class="go">var name=pflag.StringP(&quot;name&quot;,&quot;n&quot;,&quot;colin&quot;,&quot;input ur name&quot;)</code></pre><ul><li>支持长选项、默认值和使用文本，并将标志的值绑定到变量</li></ul><pre><code class="go">var name stringpflag.StringVar(&amp;name,&quot;name&quot;,&quot;colin&quot;,&quot;Input ur name&quot;)</code></pre><ul><li>支持长选项、短选项、默认值和使用文本，并将标志的值绑定到变量</li></ul><pre><code class="go">var name stringpflag.StringVarP(&amp;name, &quot;name&quot;, &quot;n&quot;,&quot;colin&quot;, &quot;Input Your Name&quot;)</code></pre><blockquote><ol><li>函数名带有 Var 说明是将标志的值绑定到变量，否则就是将标志的值存储在指针中</li><li>函数名带 P 说明支持短选项，否则不支持短选项。</li></ol></blockquote><hr><ol start="2"><li>使用 Get<Type> 获取参数的值</li></ol><pre><code class="go">i, err := flagset.GetInt(&quot;flagname&quot;)</code></pre><hr><ol start="3"><li>获取非选项参数</li></ol><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;github.com/spf13/pflag&quot;)// 定义标志var  flagvar = pflag.Int(&quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)func main() &#123;    // 解析定义的标志    pflag.Parse()    // 返回无选项参数    fmt.Printf(&quot;argument number is: %v\n&quot;, pflag.NArg())    // 返回所有的非选项参数    fmt.Printf(&quot;argument list is: %v\n&quot;, pflag.Args())    //pflag.Arg(i) 返回第 i 个非选项参数    fmt.Printf(&quot;the first argument is: %v\n&quot;, pflag.Arg(0))&#125;// go run example1.go arg1 arg2// argument number is: 2// argument list is: [arg1 arg2]// the first argument is: arg1</code></pre><hr><ol start="4"><li>指定了选项但是没有指定选项值时的默认值</li></ol><pre><code class="go">// 定义标志var ip = pflag.IntP(&quot;flagname&quot;, &quot;f&quot;, 1234, &quot;help message&quot;)// 为ip这个flag设置NoOptDefVal,pflag.Lookup(&quot;flagname&quot;).NoOptDefVal = &quot;4321&quot;</code></pre><table><thead><tr><th>命令行参数</th><th>解析结果</th></tr></thead><tbody><tr><td>–flagname&#x3D;1357</td><td>ip&#x3D;1357</td></tr><tr><td>–flagname</td><td>ip&#x3D;4321</td></tr><tr><td></td><td>ip&#x3D;1234</td></tr></tbody></table><hr><ol start="5"><li>弃用标志或者弃用标志的简写</li></ol><p>在帮助文本中会被隐藏，并在使用不推荐的标志或简写时打印正确的用法提示</p><pre><code class="go">pflag.CommandLine.MarkDeprecated(&quot;logmode&quot;,&quot;please use --log-mode instead&quot;)//隐藏帮助文本中的logmode.当使用logmode的时候，打印出 Flag --logmode has been deprecated, please use --log-mode instead。</code></pre><hr><ol start="6"><li>只弃用简写形式</li></ol><pre><code class="go">pflag.IntVarP(&amp;port,&quot;port&quot;,&quot;p&quot;,3306,&quot;MySQL service host port.&quot;)// 弃用简写形式pflag.CommandLine.MarkShorthandDeprecated(&quot;port&quot;, &quot;please use --port only&quot;)// 这样隐藏了帮助文本中的简写 P，并且当使用简写 P 时，打印了Flag shorthand -P has been deprecated, please use --port only。usage message 在此处必不可少，并且不应为空。</code></pre><hr><ol start="7"><li>隐藏标志</li></ol><p>将 Flag 标记为隐藏，仍然可以正常运行，但不会显示在 usage&#x2F;help 中,只在内部使用</p><pre><code class="go">// hide a flag by specifying its namepflag.CommandLine.MarkHidden(&quot;secretFlag&quot;)</code></pre><hr><h3 id="配置文件解析-viper"><a href="#配置文件解析-viper" class="headerlink" title="配置文件解析 viper"></a>配置文件解析 viper</h3><p>小型应用：配置项较少,可以通过命令行参数来传递配置<br>大型应用：配置项较多,通常具有很多参数，通过命令行参数传递不好维护。<br>解决方法：将这些配置信息保存在配置文件中，由程序启动时加载和解析<br>Viper 特点：<br>高优先级配置会覆盖低优先级相同配置</p><h4 id="优先级排序"><a href="#优先级排序" class="headerlink" title="优先级排序"></a>优先级排序</h4><ol><li>通过 viper.Set 函数显示设置的配置</li><li>命令行参数</li><li>环境变量</li><li>配置文件</li><li>Key&#x2F;Value 存储</li><li>默认值</li></ol><h4 id="读入配置：将配置读入到-Viper-中"><a href="#读入配置：将配置读入到-Viper-中" class="headerlink" title="读入配置：将配置读入到 Viper 中"></a>读入配置：将配置读入到 Viper 中</h4><ol><li>设置默认的配置文件名</li></ol><pre><code class="go">viper.SetDefault(&quot;ContentDir&quot;, &quot;content&quot;)viper.SetDefault(&quot;LayoutDir&quot;, &quot;layouts&quot;)viper.SetDefault(&quot;Taxonomies&quot;, map[string]string&#123;&quot;tag&quot;: &quot;tags&quot;, &quot;category&quot;: &quot;categories&quot;&#125;)</code></pre><hr><ol start="2"><li>读取配置文件</li></ol><p>支持 JSON、TOML、YAML、YML、Properties、Props、Prop、HCL、Dotenv、Env 格式的配置文件</p><pre><code class="go">package mainimport (  &quot;fmt&quot;  &quot;github.com/spf13/pflag&quot;  &quot;github.com/spf13/viper&quot;)var (  cfg  = pflag.StringP(&quot;config&quot;, &quot;c&quot;, &quot;&quot;, &quot;Configuration file.&quot;)  help = pflag.BoolP(&quot;help&quot;, &quot;h&quot;, false, &quot;Show this help message.&quot;))func main() &#123;  pflag.Parse()  if *help &#123;    pflag.Usage()    return  &#125;  // 从配置文件中读取配置  if *cfg != &quot;&quot; &#123;    viper.SetConfigFile(*cfg)   // 指定配置文件名    // 如果配置文件名中没有文件扩展名，则需要指定配置文件的格式，告诉viper以何种格式解析文件    viper.SetConfigType(&quot;yaml&quot;)  &#125; else &#123;    // 会根据添加的路径顺序搜索配置文件，如果找到则停止搜索    viper.AddConfigPath(&quot;.&quot;)          // 把当前目录加入到配置文件的搜索路径中    viper.AddConfigPath(&quot;$HOME/.iam&quot;) // 配置文件搜索路径，可以设置多个配置文件搜索路径    viper.SetConfigName(&quot;config&quot;)     // 配置文件名称（没有文件扩展名）  &#125;  if err := viper.ReadInConfig(); err != nil &#123;    // 读取配置文件。如果指定了配置文件名，则使用指定的配置文件，否则在注册的搜索路径中搜索    panic(fmt.Errorf(&quot;Fatal error config file: %s \n&quot;, err))  &#125;  fmt.Printf(&quot;Used configuration file is: %s\n&quot;, viper.ConfigFileUsed())&#125;</code></pre><hr><ol start="3"><li>监听和重新读取配置文件【不推荐】</li></ol><p>在运行的时候应用程序实时读取配置文件[热加载配置]。通过<code>WatchConfig</code>函数进行操作。<br>在操作之前需要确保已经添加了配置文件的搜索路径<br>可以为 Viper 提供一个回调函数，以便在每次发生更改时运行<br>不推荐使用原因：因为即使配置热加载了，程序中的代码也不一定会热加载。例如：修改了服务监听端口，但是服务没有重启，这时候服务还是监听在老的端口上，会造成不一致。</p><pre><code class="go">viper.WatchConfig()viper.OnConfigChange(func(e fsnotify.Event) &#123;   // 配置文件发生变更之后会调用的回调函数  fmt.Println(&quot;Config file changed:&quot;, e.Name)&#125;)</code></pre><hr><ol start="4"><li>从 io.Reader 读取配置</li></ol><hr><ol start="5"><li>从环境变量读取【区分大小写】<ul><li>AutomaticEnv()</li><li>BindEnv(input …string)</li><li>errorSetEnvPrefix(in string)</li><li>SetEnvKeyReplacer(r *strings.Replacer)</li><li>AllowEmptyEnv(allowEmptyEnv bool)</li></ul></li></ol><hr><ol start="6"><li>从命令行标志读取</li></ol><pre><code class="go">// 绑定单个标志viper.BindPFlag(&quot;token&quot;, pflag.Lookup(&quot;token&quot;))</code></pre><hr><ol start="7"><li>从远程 Key&#x2F;Value 存储读取</li></ol><hr><h4 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h4><h3 id="应用的命令行框架-Cobra"><a href="#应用的命令行框架-Cobra" class="headerlink" title="应用的命令行框架 Cobra"></a>应用的命令行框架 Cobra</h3><ol><li>命令需要具备 Help 功能，这样才能告诉使用者如何去使用</li><li>命令需要能够解析命令行参数和配置文件</li><li>命令需要能够初始化业务代码，并最终启动业务进程</li></ol><h2 id="应用的三大基本功能"><a href="#应用的三大基本功能" class="headerlink" title="应用的三大基本功能"></a>应用的三大基本功能</h2><ul><li><p>API 服务：通过对外提供 HTTP&#x2F;RPC 接口来完成指定的功能。比如订单服务，通过调用创建订单的 API 接口，来创建商品订单。</p></li><li><p>非 API 服务：通过监听、定时运行等方式，而不是通过 API 调用来完成某些任务。比如数据处理服务，定时从 Redis 中获取数据，处理后存入后端存储中。再比如消息处理服务，监听消息队列（如 NSQ&#x2F;Kafka&#x2F;RabbitMQ），收到消息后进行处理。</p></li></ul><h3 id="启动流程一致"><a href="#启动流程一致" class="headerlink" title="启动流程一致"></a>启动流程一致</h3><img src="/2022/11/22/15-go-viper-cobra-pflag/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.webp" class="" title="启动流程"><ol><li>应用框架构建<br>a. 命令行程序<br>b. 命令行参数解析<br>c. 配置文件解析</li><li>应用初始化</li><li>服务启动<br>a. 创建 API 服务或非 API 服务<br>b. 启动服务</li></ol><blockquote><p>应用框架构建和业务关系不大，可以抽象成统一的框架。<br>应用初始化和服务启动，与业务联系较密切，难以抽象称一个统一的框架</p></blockquote><h2 id="iam-apiServer"><a href="#iam-apiServer" class="headerlink" title="iam-apiServer"></a>iam-apiServer</h2>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/2022/11/21/fan-yi-why-i-love-golang/"/>
      <url>/2022/11/21/fan-yi-why-i-love-golang/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么我喜欢-Golang"><a href="#为什么我喜欢-Golang" class="headerlink" title="为什么我喜欢 Golang"></a>为什么我喜欢 Golang</h1><p>我喜欢 Go 语言编程,也就是一些人提到的 Golang。它简单且伟大。</p><p>我写的有点跑题。没想到 GoLang 会这么好。</p><p>我第一次遇到 Go 大概是在 2016 年 1 月份,它在以色列有一个比较小众却很活跃的社区。</p><p>当时也没多想,只是想磨练编程技能,GoLang 也只是我用来完成任务的一个工具。</p><p>即使是一年以前,使用 Go 也是非常明智的。一旦掌握了这门语言的核心要领,整个过程就很简单易懂。</p><p>我为公司<a href="https://www.visualead.com/">Visualead</a>写了一段关键代码,它没有让我们失望,一年之后仍然以零维护的形式运行在生产环境。</p><p>最近我发现自己一次又一次地使用了 Golang,感觉有必要写一篇文章来描述我为什么对 GoLang 情有独钟了。</p><h2 id="GoPATH-环境"><a href="#GoPATH-环境" class="headerlink" title="GoPATH 环境"></a>GoPATH 环境</h2><p>当你开始使用 Go 写代码的时候,这是你必须要处理的事情之一。</p><p>将你的电脑上的任意一个位置设置为 GOPATH 目录,并且里面包含 bin,src 和 pkg 目录,那就可以开始编码了。</p><pre><code class="bash">// How the directory structure looks like:go- bin- pkg- src</code></pre><p>我在 home 目录下为用到的每种编程语言都创建了一个新目录。home 目录的文件夹结构如下所示：</p><pre><code class="bash">chefcppelixirelmgojavascriptmeteorocamlphppythonscala</code></pre><p>除了 Go 以外,没有一种语言是强制执行这种结构的。Go 迫使你为所有的 GoLang 项目定义一个根目录，这样做是非常有好处的,接下来我们马上就会讲到。</p><h2 id="GoLang-应用"><a href="#GoLang-应用" class="headerlink" title="GoLang 应用"></a>GoLang 应用</h2><p>想要创建一个新的 GoLang 应用?非常简单。</p><p>进入 <code>$GOPATH/src</code> 目录,创建一个新文件夹,并且创建一个新的 <code>file.go</code>，调用 <code>main</code> 包,添加一个 <code>func main() &#123;&#125;</code> 函数,这就大功告成了。从此以后你可以使用 go 所有的好东西了。</p><p>更多 Go 的好东西出现！但首先要提的必须是 GoLang modules。</p><h2 id="GoLang-modules"><a href="#GoLang-modules" class="headerlink" title="GoLang modules"></a>GoLang modules</h2><p>我最喜欢的编程范式做得很好，我把模块系统视为面向对象类系统的一种替代方案。</p><p>GoLang 调用它的模块包。所以从现在起每次我们说一个模块就意味着一个包，反之亦然。</p><pre><code class="bash">Module == Package == Module</code></pre><p>在 GoLang 里面,你创建的每一个目录都会变成一个包。如果包的名称是 main,那他会变成一个应用。这有助于将代码自然分隔为可管理的逻辑块。</p><p>你总是想要从可复用的组件或者 Golang 的包中创建业务逻辑。</p><p>在现在的应用中,我必须在部分文件中操作一些行,并且一旦完成就会将他们上传到 AWS S3。</p><p>我的应用结构如下所示：</p><pre><code class="bash">src- my_app- - main.go- - main_test.go- - uploader- - - uploader.go- - - uploader_test.go- - replace_file_lines- - - replace.go- - - replace_test.go- - - strings_util.go- - - strings_util_test.go</code></pre><p><code>_test.go</code> 文件毫无疑问是 Golang 的单元测试文件,其核心部分有一个构建好的测试框架。</p><p>对于来自面向对象编程语言的人来说,把每个目录认为是一个完整的静态类是很有用的,并且 <code>.go</code> 文件中的每个函数或者变量会变成它的属性或者方法。</p><p>这里有个 <code>replace.go</code> 的例子：</p><pre><code class="go">package replace_file_linesimport (  // ...)// Variables that begin with an uppercase is exposedvar PublicVariable int = 42// While those that begin with loweracse are private to the modulevar privateVariable int = 0// Function that begins with an uppercase is exposedfunc Replace(oldFilePath, outputFilePath, with, what string) &#123; // ...&#125;// Function that begins with an uppercase is exposedfunc PublicFunction(/* .. */) &#123;  // ...)// While lowercase names makes functions private to the modulefunc privateFunction(/* .. */) &#123;  // ...)</code></pre><p>如果一个目录有不止一个的 <code>.go</code> 文件,所有的方法和变量甚至是私有的,在整个包里面都是可共享的。这有助于将一个包分割成更小的块,也可以避免大的单个文件出现。</p><p>在不讨论面向对象 vs 功能&#x2F;程序的情况下,知道 Go 创始人决定不再将经典的类放在语言里是很重要的。取而代之的是使用 struct&#x2F;interface ，当然还有包。</p><h2 id="Golang-gofmt"><a href="#Golang-gofmt" class="headerlink" title="Golang gofmt"></a>Golang gofmt</h2><p>GoLang 有一个公约:一切该如何看待，每个案例和每行需要的精确空间。</p><p>这允许开发者可以专注于写代码而不是开始关于花括号位置的战争。</p><p>旧的 {} vs {\n} 战争：</p><img src="/2022/11/21/fan-yi-why-i-love-golang/cruly-brarce.png" class="" title="Or perhaps I am only happy because my side won in Go?"><p>点击此处阅读关于该问题的更多信息:<a href="https://golang.org/cmd/gofmt/">https://golang.org/cmd/gofmt/</a></p><h2 id="GoLang-Import"><a href="#GoLang-Import" class="headerlink" title="GoLang Import"></a>GoLang Import</h2><p>import 总是相对于 <code>GOPATH/src</code> 来说的。一直如此。我不会夸大这个决定在这个程度上在沮丧中拯救了我。</p><p>警告：下一行会令人迷惑。【todo:此处翻译不确定】</p><p>当使用其他语言的时候,你既可以使用相对&#x2F;绝对路径,也可以以某种方式设置古怪的 import,这使得你可以从鬼知道的任意地方导入一个文件(Python 我已经注意到你了)。</p><p>Go 用一种独特的方式解决了这个问题。所有的 import，无论是哪一个文件，都是相对于 <code>GOPATH/src</code> 而言。</p><p>所以在 my_app 中,主要的 import 如下所示：</p><pre><code class="go">package mainimport (    &quot;my_app/replace_file_lines&quot;    &quot;my_app/uploader&quot;    // ...)</code></pre><p>my_app 在 src 目录下,所以我们首先需要提到它,然后导入存在于 my_app 下的包,比如 <code>uploader</code> 和 <code>replace_file_lines</code>。注意,我们不再是引入单个文件,而是引入了整个包。像挂件一样工作并且引起 零值可用。【todo:此处翻译不确定】</p><p>此外,除非你实际使用了导入的包,否则 GoLang 不会编译,这个小特性有助于你了解实际使用的每一个 import。</p><p>期望你的程序员能够写一个没有未使用的 import 的干净代码?那为什么不让你本地的 Go 关注这个呢?</p><h2 id="Golang-Get-System"><a href="#Golang-Get-System" class="headerlink" title="Golang Get System"></a>Golang Get System</h2><p>import 章节让我们了解了 GoLang 下一个伟大的特性, <code>go get</code> 特性。当其他人对<a href="https://www.npmjs.com/">JavaScripts NPM</a> 包管理印象深刻,Go 采用了任意的 git 仓库作为它的包管理。</p><p>它是怎么工作的呢?</p><p>我之前写过我需要上传到 S3 对么?然后这意味着我需要 AWS SDK 来完成这个任务。</p><p>为了让它可以工作,我只需要打开终端并且写下:</p><pre><code>go get github.com/aws/aws-sdk-go</code></pre><p>然后会发生什么呢?没有什么特殊的,GoLang 只是从<a href="https://github.com/aws/aws-sdk-go">https://github.com/aws/aws-sdk-go</a> 下载了仓库到你的 <code>GOPATH/src</code> 目录下。</p><p>然后你为了使用 aws-sdk 需要做的只是导入它：</p><pre><code class="go">package uploaderimport (    &quot;github.com/aws/aws-sdk-go/service/s3&quot;    &quot;github.com/aws/aws-sdk-go/aws/session&quot;    &quot;github.com/aws/aws-sdk-go/aws&quot;    // ...)</code></pre><p>还记得所有的 import 都是相对于 <code>GOPATH/src</code> 么? 现在你可以知道 <code>s3</code> 包位于<code>GOPATH/src/github.com/aws/aws-sdk-go/services/s3</code> 下面。</p><p>简单,优雅。对于 Go 而言是另外一个闪光点。</p><h2 id="Golang-Build-和-Package-Systems"><a href="#Golang-Build-和-Package-Systems" class="headerlink" title="Golang Build 和 Package Systems"></a>Golang Build 和 Package Systems</h2><p>我们一直关注 <code>GOPATH/src</code> ,但是仍然有其他目录我们需要处理,<code>GOPATH/pkg</code> 和 <code>GOPATH/bin</code>。</p><p>GoLang 是一种编译型语言,这意味着代码必须先完成编译才能运行。GoLang 编译速度很快。它是怎么做的呢?</p><p>每次你编译代码运行的时候,GoLang 会在同样的路径创建一个 <code>.a</code> 文件作为包，它只出现在 <code>GOPATH/pkg</code> 目录里。这<br>意味着比如你编译了 aws-sdk,一次编译之后,就可以在你其他代码之间共享。</p><p>这当然不是 GoLang 编译快速的唯一原因,但是它只是一个引子来帮助你理解 <code>GOPATH/pkg</code> 的角色。</p><p>现在,关于 <code>GOPATH/bin</code> 有哪些用途呢? 当你运行 <code>go install</code> 命令的时候,go 会创建一个二进制文件,放在 <code>GOPATH/bin</code> 下面,文件获取到你的 main 包目录的名字,即我们案例里面的 <code>my_app</code>。</p><p>为什么说它非常棒呢? 因为你可以添加 <code>GOPATH/bin</code> 到环境变量中,这样构建的所有二进制文件都可以在命令行中获取到,而且不需要做任何额外的工作!(是不是很棒呢?)</p><h2 id="GoLang-跨平台构建"><a href="#GoLang-跨平台构建" class="headerlink" title="GoLang 跨平台构建"></a>GoLang 跨平台构建</h2><p>想要部署到编码平台以外的其他平台?别担心,你不需要使用 windows 机器来构建你的 windows 版本的代码。<a href="https://github.com/golang/go/wiki/WindowsCrossCompiling">GoLang 已经为你做好了</a>。</p><p>主要运行:</p><pre><code class="bash">GOOS=windows GOARCH=amd64 go install</code></pre><p>我们的代码将会输出可以在 windows 机器上部署的二进制文件。 <code>.exe</code> 文件会出现在 <code>GOPATH/bin/windows_amd64/my_app.exe</code>。难度就像在公园里散步一样。</p><h2 id="Golang-编程语言"><a href="#Golang-编程语言" class="headerlink" title="Golang 编程语言"></a>Golang 编程语言</h2><p>GoLang 旨在成为一门简单的编程语言。</p><p>我很喜欢下面这个帖子,它问道:为什么 Go 没有被设计成函数式语言： <a href="https://www.quora.com/Why-wasnt-Go-written-as-a-functional-language">https://www.quora.com/Why-wasnt-Go-written-as-a-functional-language</a></p><blockquote><p>在 google 工作的程序员职业生涯开始得很早，并且最熟悉过程式编程语言，尤其是来自于 c 语言家族的。需要程序员快速提高生产力,这意味着语言不能过于激进。</p></blockquote><p>它确实很简单。</p><p>这是 GoLang 不支持的部分特性清单:</p><ol><li>类</li><li>操作符重载</li><li>函数重载</li><li>可选参数</li><li>异常</li></ol><p>尽管有时候我发现写 Go 的时候会丢掉一些语言特性,但是最终总是能够完成想做的事。只是有时候,需要更多的写和偶尔的思考。底线就是它使得代码更容易推理,不会那么抽象。</p><p>有时候我很惊讶,在没有多年经验的情况下,用 Go 写代码,我竟然可以如此之快地达到目标,仅仅因为这门语言如此包容和清晰。</p><h2 id="Golang-并发"><a href="#Golang-并发" class="headerlink" title="Golang 并发"></a>Golang 并发</h2><p>我有意把关于并发的讨论留在最后。为什么?因为我不认为它不是那么重要。</p><p>它是 Go 语言中令人震惊的特性。但是有时候被认为是 Go 语言的本质,我不认同这种说法。</p><p>因此我准备尝试用一段话总结一下。</p><p>是的,GoLang 有很棒的并发性。你不需要处理线程,只需要创建简单的 goroutine,它的制作和管理都很简单。 Goroutines 使你可以在所有的 CPU 上分配负载，而不需要担心如何管理。</p><p>有兴趣进一步了解 goroutines?可以阅读：<a href="https://tour.golang.org/concurrency/1">https://tour.golang.org/concurrency/1</a></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-go静态代码检查</title>
      <link href="/2022/11/20/14-go-jing-tai-dai-ma-jian-cha/"/>
      <url>/2022/11/20/14-go-jing-tai-dai-ma-jian-cha/</url>
      
        <content type="html"><![CDATA[<h2 id="静态代码校验"><a href="#静态代码校验" class="headerlink" title="静态代码校验"></a>静态代码校验</h2><p>工具：golangci-lint</p><ol><li>安装：</li></ol><pre><code class="bash">go get github.com/golangci/golangci-lint/cmd/golangci-lint@latestgolangci-lint version # 输出 golangci-lint 版本号，说明安装成功golangci-lint has version v1.39.0 built from (unknown, mod sum: &quot;h1:aAUjdBxARwkGLd5PU0vKuym281f2rFOyqh3GB4nXcq8=&quot;) on (unknown)</code></pre><ol start="2"><li>使用：</li></ol><pre><code class="bash">golangci-lint run</code></pre><h2 id="生成-swagger-api-文档"><a href="#生成-swagger-api-文档" class="headerlink" title="生成 swagger api 文档"></a>生成 swagger api 文档</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>方法 1：</p><pre><code class="bash">go get -u github.com/go-swagger/go-swagger/cmd/swaggerswagger version</code></pre><p>方法 2：</p><pre><code class="bash">yum install binutils binutils-devel -yrm -rf ~/.cache/go-build# 安装dev版本go install ./cmd/swagger# 安装指定版本git checkout v0.25.0go install -ldflags &quot;-X github.com/go-swagger/go-swagger/cmd/swagger/commands.Version=$(git describe --tags) -X github.com/go-swagger/go-swagger/cmd/swagger/commands.Commit=$(git rev-parse HEAD)&quot; ./cmd/swagger# 验证是否安装成功swagger version</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过解析源码中的注释来生成 Swagger 文档</p><pre><code class="bash"> swagger generate spec -o docs/swagger.yaml swagger serve --no-open -F=swagger --port 36666  ./docs/swagger.yaml # 在浏览器中打开localhost:36666/docs</code></pre><h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p><a href="https://github.com/go-swagger/go-swagger/issues/2756">#2756</a></p><h3 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h3><ol><li>swagger:route：swagger:route 代表 API 接口描述的开始，后面的字符串格式为 HTTP 方法 URL Tag ID。可以填写多个 tag，相同 tag 的 API 接口在 Swagger 文档中会被分为一组。ID 是一个标识符，swagger:parameters 是具有相同 ID 的 swagger:route 的请求参数。swagger:route 下面的一行是该 API 接口的描述，需要以英文点号为结尾。responses:定义了 API 接口的返回参数，例如当 HTTP 状态码是 200 时，返回 createUserResponse，createUserResponse 会跟 swagger:response 进行匹配，匹配成功的 swagger:response 就是该 API 接口返回 200 状态码时的返回。</li><li>swagger:response：swagger:response 定义了 API 接口的返回，例如 getUserResponseWrapper，关于名字，我们可以根据需要自由命名，并不会带来任何不同。getUserResponseWrapper 中有一个 Body 字段，其注释为&#x2F;&#x2F; in:body，说明该参数是在 HTTP Body 中返回。swagger:response 之上的注释会被解析为返回参数的描述。api.User 自动被 go-swagger 解析为 Example Value 和 Model。我们不用再去编写重复的返回字段，只需要引用已有的 Go 结构体即可，这也是通过工具生成 Swagger 文档的魅力所在</li><li>swagger:parameters：swagger:parameters 定义了 API 接口的请求参数，例如 userParamsWrapper。userParamsWrapper 之上的注释会被解析为请求参数的描述，&#x2F;&#x2F; in:body 代表该参数是位于 HTTP Body 中。同样，userParamsWrapper 结构体名我们也可以随意命名，不会带来任何不同。swagger:parameters 之后的 createUserRequest 会跟 swagger:route 的 ID 进行匹配，匹配成功则说明是该 ID 所在 API 接口的请求参数。</li></ol><h2 id="错误码设计"><a href="#错误码设计" class="headerlink" title="错误码设计"></a>错误码设计</h2><ul><li>错误码由两部分组成：HTTP status code 和 业务code。</li><li>业务code采用数字格式拼接而成，一般包括，服务，模块，错误三部分</li><li>返回的数据格式应该是固定的、规范的。</li></ul><h3 id="错误代码说明：100101"><a href="#错误代码说明：100101" class="headerlink" title="错误代码说明：100101:"></a>错误代码说明：100101:</h3><ul><li>10：服务</li><li>01: 某个服务下的某个模块。</li><li>01: 模块下的错误码序号，每个模块可以注册 100 个错误。<br>结论：服务 A，数据库模块下的记录没有找到错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-go在vscode中的调试</title>
      <link href="/2022/11/18/13-go-zai-vscode-zhong-de-diao-shi/"/>
      <url>/2022/11/18/13-go-zai-vscode-zhong-de-diao-shi/</url>
      
        <content type="html"><![CDATA[<ol><li>新建.vscode&#x2F;launch.json</li><li>文件-将文件夹添加到工作区</li></ol><pre><code class="json">// launch.json&#123;  // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;Launch file&quot;,      &quot;type&quot;: &quot;go&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;mode&quot;: &quot;debug&quot;,      &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/main.go&quot;    &#125;  ]&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-go-常用设计模式</title>
      <link href="/2022/10/24/12-go-chang-yong-she-ji-mo-shi/"/>
      <url>/2022/10/24/12-go-chang-yong-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="go-项目【工程化】"><a href="#go-项目【工程化】" class="headerlink" title="go 项目【工程化】"></a>go 项目【工程化】</h2><img src="/2022/10/24/12-go-chang-yong-she-ji-mo-shi/go_engeneer.webp" class="" title="go项目"><h3 id="go-应用"><a href="#go-应用" class="headerlink" title="go 应用"></a>go 应用</h3><img src="/2022/10/24/12-go-chang-yong-she-ji-mo-shi/go_app.webp" class="" title="go应用"><h4 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h4><p>推荐：按功能拆分<br>不推荐：按 MVC 这样的层拆分<br>案例：<br>订单系统&#x3D;用户模块+订单模块+计费模块</p><blockquote><p>【注】:按功能拆分的</p></blockquote><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><p><a href="https://github.com/xxjwxc/uber_go_guide_cn">Uber Go 语言编码规范</a></p><ul><li>最佳实践<br><a href="https://go.dev/doc/effective_go">Effective Go</a><br><a href="https://github.com/golang/go/wiki/CodeReviewComments">CodeReviewComments</a><br><a href="https://rakyll.org/style-packages/">Style guideline for Go packages</a></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ol><li><p>尽可能减少 function 中的依赖，让其只依赖必要模块</p></li><li><p>依赖模块应该易于 mock</p></li><li><p>提高单元测试覆盖率</p><ul><li>使用 gotests 工具自动生成单元测试代码，减少编写单元测试用例的工作量</li><li>定期检查单元测试覆盖率。你可以通过以下方法来检查</li></ul><pre><code class="go">$ go test -race -cover -coverprofile=./coverage.out -timeout=10m -short -v ./...$ go tool cover -func ./coverage.out</code></pre></li></ol><p>不可测试代码：</p><pre><code class="go">package postimport &quot;google.golang.org/grpc&quot;type Post struct &#123;Name    stringAddress string&#125;func ListPosts(client *grpc.ClientConn) ([]*Post, error) &#123;return client.ListPosts()&#125;</code></pre><p>可测试代码：</p><pre><code class="go">package maintype Post struct &#123;  Name    string  Address string&#125;type Service interface &#123;  ListPosts() ([]*Post, error)&#125;func ListPosts(svc Service) ([]*Post, error) &#123;  return svc.ListPosts()&#125;</code></pre><p>常用 mock 工具：<br><a href="https://github.com/golang/mock">golang&#x2F;mock</a><br><a href="https://github.com/DATA-DOG/go-sqlmock">sqlmock</a><br><a href="https://github.com/jarcoal/httpmock">httpmock</a><br><a href="https://github.com/bouk/monkey">bouk&#x2F;monkey</a></p><h4 id="自动生成代码"><a href="#自动生成代码" class="headerlink" title="自动生成代码"></a>自动生成代码</h4><ul><li>错误码、错误码说明文档。</li><li>自动生成缺失的 doc.go 文件。</li><li>利用 gotests 工具，自动生成单元测试用例。</li><li>使用 Swagger 工具，自动生成 Swagger 文档。</li><li>使用 Mock 工具，自动生成接口的 Mock 实例。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><img src="/2022/10/24/12-go-chang-yong-she-ji-mo-shi/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.webp" class=""><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：全局只有一个实例，并且它负责创建自己的对象<br>优势：有利于减少内存开支，还能减少系统性能开销、防止多个实例产生冲突<br>适合场景：全局共享一个实例，且只需要被初始化一次，如数据库实例、全局配置、全局任务池</p><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>定义：全局的单例实例在包被加载时创建</p><pre><code class="go">package singletontype singleton struct &#123;&#125;var ins *singleton = &amp;singleton&#123;&#125;func GetInsOr() *singleton &#123;    return ins&#125;</code></pre><hr><h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>定义：全局的单例实例在第一次被使用时创建</p><pre><code class="go">package singletontype singleton struct &#123;&#125;var ins *singletonfunc GetInsOr() *singleton &#123;    if ins == nil &#123;        ins = &amp;singleton&#123;&#125;    &#125;    return ins&#125;// 带检查锁import &quot;sync&quot;type singleton struct &#123;&#125;var ins *singletonvar mu sync.Mutexfunc GetIns() *singleton &#123;  if ins == nil &#123;    mu.Lock()    if ins == nil &#123;      ins = &amp;singleton&#123;&#125;    &#125;        mu.Unlock()  &#125;  return ins&#125;// =======================更完美方式package singletonimport (    &quot;sync&quot;)type singleton struct &#123;&#125;var ins *singletonvar once sync.Oncefunc GetInsOr() *singleton &#123;    once.Do(func() &#123;      //使用once.Do可以确保 ins 实例全局只被创建一次，once.Do 函数还可以确保当同时有多个创建动作时，只有一个创建动作在被执行。        ins = &amp;singleton&#123;&#125;    &#125;)    return ins&#125;</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Go 中的结构体，可以理解为面向对象编程中的类，例如 Person 结构体（类）实现了 Greet 方法。</p><pre><code class="go">type Person struct &#123;  Name string  Age int&#125;func (p Person) Greet() &#123;  fmt.Printf(&quot;Hi! My name is %s&quot;, p.Name)&#125;</code></pre><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>一个接受一些参数，然后返回 Person 实例的函数。确保我们创建的实例具有需要的参数，进而保证实例的方法可以按预期执行，例如，通过 NewPerson 创建 Person 实例时，可以确保实例的 name 和 age 属性被设置。</p><pre><code class="go">type Person struct &#123;  Name string  Age int&#125;func (p Person) Greet() &#123;  fmt.Printf(&quot;Hi! My name is %s&quot;, p.Name)&#125;func NewPerson(name string, age int) *Person &#123;  return &amp;Person&#123;    Name: name,    Age: age,  &#125;&#125;</code></pre><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>和简单工厂模式的唯一区别，就是它返回的是接口而不是结构体</p><pre><code class="go">type Person interface &#123;  Greet()&#125;type person struct &#123;  name string  age int&#125;func (p person) Greet() &#123;  fmt.Printf(&quot;Hi! My name is %s&quot;, p.name)&#125;// Here, NewPerson returns an interface, and not the person struct itselffunc NewPerson(name string, age int) Person &#123;  return person&#123;    name: name,    age: age,  &#125;&#125;</code></pre><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><pre><code class="go">type Person struct &#123;  name string  age int&#125;func NewPersonFactory(age int) func(name string) Person &#123;  return func(name string) Person &#123;    return Person&#123;      name: name,      age: age,    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos二三事</title>
      <link href="/2022/10/20/centos-er-san-shi/"/>
      <url>/2022/10/20/centos-er-san-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="centos7-安装-mariadb"><a href="#centos7-安装-mariadb" class="headerlink" title="centos7 安装 mariadb"></a>centos7 安装 mariadb</h2><ol><li>配置 MariaDB Yum 源</li></ol><pre><code class="bash">#/etc/yum.repos.d/mariadb.repo# MariaDB 10.5 CentOS repository list - created 2020-10-23 01:54 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://mirrors.aliyun.com/mariadb/mariadb-10.7.6/yum/centos/7/x86_64/module_hotfixes=1gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=0</code></pre><ol start="2"><li>安装 MariaDB 和 MariaDB 客户端<br><code>yum -y install MariaDB-server MariaDB-client</code></li><li>启动 MariaDB，并设置开机启动<br><code>systemctl enable mariadb</code><br><code>systemctl start mariadb</code></li><li>设置 root 初始密码<br><code>mysqladmin -u$&#123;MARIADB_ADMIN_USERNAME&#125; password $&#123;MARIADB_ADMIN_PASSWORD&#125;</code></li><li>验证<br><code>mysql -h127.0.0.1 -uroot -p&#39;iam59!z$&#39;</code></li></ol><h2 id="centos7-安装-redis"><a href="#centos7-安装-redis" class="headerlink" title="centos7 安装 redis"></a>centos7 安装 redis</h2><p>由于 yum 不支持 redis，所以通过源码方式安装</p><ol><li><p>获取最新稳定版本的 redis 并解压<br><code>wget https://download.redis.io/redis-stable.tar.gz</code><br><code>tar -zxvf redis-4.0.8.tar.gz</code></p></li><li><p>安装 python3</p></li><li><p>编译</p></li></ol><pre><code class="bash">cd redis-stablemakemake install prefix=/usr/local/redismkdir /usr/local/redis/etcmv redis.conf /usr/local/redis/etc</code></pre><ol start="4"><li>修改为后台启动<br><code>将daemonize no 改成daemonize yes</code></li><li>将 redis 加入到开机启动</li></ol><h2 id="centos7-安装-Python3-7"><a href="#centos7-安装-Python3-7" class="headerlink" title="centos7 安装 Python3.7"></a>centos7 安装 Python3.7</h2><ol><li>安装依赖包<br><code>yum install gcc patch libffi-devel python-devel zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel -y </code></li><li>下载 Python<br><code>wget https://www.python.org/ftp/python/3.7.10/Python-3.7.10.tgz</code></li><li>创建一个空文件夹，存放 python3 程序<br><code>mkdir /usr/local/python3</code></li><li>编译&#x2F;安装</li></ol><pre><code class="bash">./configure --prefix=/usr/local/python3./configure --enable-optimizationmakemake install prefix=/usr/local/python3</code></pre><h2 id="centos7替换国内yum源"><a href="#centos7替换国内yum源" class="headerlink" title="centos7替换国内yum源"></a>centos7替换国内yum源</h2><ol><li>备份源yum文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo_bak</code></li><li>下载阿里云镜像文件  <code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li><li>清空缓存 <code>yum clean all</code></li><li>重新生成缓存 <code>yum makecache</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git二三事</title>
      <link href="/2022/10/19/git-er-san-shi/"/>
      <url>/2022/10/19/git-er-san-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="git-链接失败"><a href="#git-链接失败" class="headerlink" title="git 链接失败"></a>git 链接失败</h2><p>报错失败：kex_exchange_identification: Connection closed by remote host<br>解决方法：将 Github 的连接端口从 22 改为 443 即可<br>.ssh&#x2F;config 文件</p><pre><code class="bash">Host github.com    HostName ssh.github.com    User git    Port 443</code></pre><h2 id="git-clone-报错-1"><a href="#git-clone-报错-1" class="headerlink" title="git clone 报错 1"></a>git clone 报错 1</h2><p>具体报错信息：</p><blockquote><p>git clone <a href="mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>:marmotedu&#x2F;iam.git<br>Cloning into ‘iam’…<br>Unable to negotiate with 192.30.255.112 port 22: no matching MAC found. Their offer: <a href="mailto:&#x68;&#x6d;&#97;&#x63;&#x2d;&#x73;&#x68;&#97;&#x32;&#45;&#53;&#x31;&#50;&#45;&#x65;&#116;&#x6d;&#x40;&#x6f;&#x70;&#101;&#110;&#x73;&#115;&#104;&#x2e;&#99;&#111;&#109;">&#x68;&#x6d;&#97;&#x63;&#x2d;&#x73;&#x68;&#97;&#x32;&#45;&#53;&#x31;&#50;&#45;&#x65;&#116;&#x6d;&#x40;&#x6f;&#x70;&#101;&#110;&#x73;&#115;&#104;&#x2e;&#99;&#111;&#109;</a>,<br><a href="mailto:&#x68;&#109;&#x61;&#99;&#x2d;&#x73;&#x68;&#x61;&#50;&#x2d;&#50;&#53;&#x36;&#45;&#x65;&#x74;&#109;&#64;&#x6f;&#112;&#x65;&#x6e;&#x73;&#115;&#104;&#46;&#x63;&#x6f;&#x6d;">&#x68;&#109;&#x61;&#99;&#x2d;&#x73;&#x68;&#x61;&#50;&#x2d;&#50;&#53;&#x36;&#45;&#x65;&#x74;&#109;&#64;&#x6f;&#112;&#x65;&#x6e;&#x73;&#115;&#104;&#46;&#x63;&#x6f;&#x6d;</a>,hmac-sha2-512,hmac-sha2-256<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights</p></blockquote><p>解决方法：<br>在<code>/etc/ssh/ssh_config</code>文件最后一行修改<code>MACs hmac-sha1</code>为<code>MACs hmac-sha1,hmac-sha2-256,hmac-sha2-512</code></p><h2 id="git-clone-报错-2"><a href="#git-clone-报错-2" class="headerlink" title="git clone 报错 2"></a>git clone 报错 2</h2><blockquote><p>fatal: unable to access ‘<a href="https://github.com/protocolbuffers/protobuf/&#39;">https://github.com/protocolbuffers/protobuf/&#39;</a>: Failed connect to github.com:443; Connection timed out</p></blockquote><p>解决方法：<br>使用 ssh 链接 <code>git clone -b v3.21.1 --depth=1 git@github.com:protocolbuffers/protobuf.git</code></p><h2 id="git-clone-报错-3"><a href="#git-clone-报错-3" class="headerlink" title="git clone 报错 3"></a>git clone 报错 3</h2><blockquote><p>ERROR: You’re using an RSA key with SHA-1, which is no longer allowed. Please use a newer client or a different key type.<br>Please see <a href="https://github.blog/2021-09-01-improving-git-protocol-security-github/">https://github.blog/2021-09-01-improving-git-protocol-security-github/</a> for more information.</p></blockquote><p>解决方法：<br>ssh-keygen -t ecdsa -b 521 -C “<a href="mailto:&#x79;&#x6f;&#x75;&#x72;&#x5f;&#101;&#109;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;">&#x79;&#x6f;&#x75;&#x72;&#x5f;&#101;&#109;&#97;&#105;&#108;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#x2e;&#99;&#111;&#109;</a>“</p><h2 id="centos7-安装-最新版-git"><a href="#centos7-安装-最新版-git" class="headerlink" title="centos7 安装 最新版 git"></a>centos7 安装 最新版 git</h2><ol><li>将最新版压缩包上传到云服务器（scp 命令）<code>scp git-2.38.1.tar.gz root@36.133.137.19:/root/setup/</code></li><li>安装依赖并解压，进入解压后的文件夹</li></ol><pre><code class="bash">yum -y install curl-devel expat-devel openssl-devel zlib-develyum -y install gcctar -zxf git-2.38.1.tar.gzcd git-2.38.1</code></pre><ol start="3"><li>编译并安装</li></ol><pre><code class="bash">makemake install prefix=/usr/local/git</code></pre><p>此时会在&#x2F;usr&#x2F;local&#x2F;下生成文件夹 git</p><img src="/2022/10/19/git-er-san-shi/make.jpg" class="" title="生成文件夹git"><p>进入文件夹后执行<code>./git --version</code></p><ol start="4"><li>使其全局生效</li></ol><ul><li>通过将其添加至环境变量</li></ul><pre><code class="bash"># /etc/profilePATH=$PATH:/usr/local/git/binEXPORT PATH# shellsource /etc/profile</code></pre><ul><li>软链接[实测并不生效]</li></ul><h3 id="克隆指定分支-x2F-tag代码"><a href="#克隆指定分支-x2F-tag代码" class="headerlink" title="克隆指定分支&#x2F;tag代码"></a>克隆指定分支&#x2F;tag代码</h3><p>git clone -b v1.1.0  <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:marmotedu&#x2F;iam.git</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h3><ol><li><a href="https://git-scm.com/download/linux">https://git-scm.com/download/linux</a></li><li><a href="https://www.cnblogs.com/zhi-leaf/p/10978538.html">https://www.cnblogs.com/zhi-leaf/p/10978538.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-go-api</title>
      <link href="/2022/10/18/11-go-api/"/>
      <url>/2022/10/18/11-go-api/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的-API-风格"><a href="#常用的-API-风格" class="headerlink" title="常用的 API 风格"></a>常用的 API 风格</h2><ol><li>REST:表现层状态转移(REpresentational State Transfer)</li><li>RPC</li><li>GraphQL[不常用]<img src="/2022/10/18/11-go-api/http.webp" class=""></li></ol><h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>以资源 (resource) 为中心，所有的东西都抽象成资源</p><ul><li>资源<ul><li>Collection:<br>一堆资源的集合,比如用户(User)的集合就是 Collection。<br>域名&#x2F;资源名复数:<code>https://xxx.com/users</code></li><li>Member<br>单个特定资源<br>域名&#x2F;资源名复数&#x2F;资源名称:<code>https://xxx.com/users/admin</code></li></ul></li></ul><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ol><li>URI 结尾不应包含&#x2F;</li><li>URI 中不能出现下划线 _，必须用中杠线 - 代替【不强制】</li><li>路径用小写，不要用大写</li><li>避免层级过深的 URI。超过 2 层的资源嵌套会很乱，建议将其他资源转化为?参数</li><li>有些操作不能很好地映射为一个 REST 资源的时候,将一个操作变成资源的一个属性或者将操作当作是一个资源的嵌套资源</li><li>返回格式统一【成功和失败】</li></ol><pre><code class="bash">/schools/tsinghua/classes/rooma/students/zhang # 不推荐/students?school=qinghua&amp;class=rooma # 推荐/users/zhangsan?active=false # 禁用某个用户PUT /gists/:id/star # github star actionDELETE /gists/:id/star # github unstar action</code></pre><h3 id="安全性和幂等性"><a href="#安全性和幂等性" class="headerlink" title="安全性和幂等性"></a>安全性和幂等性</h3><p>安全性：不会改变资源状态，可以理解为只读的。<br>幂等性：执行 1 次和执行 N 次，对资源状态改变的效果是等价的。</p><img src="/2022/10/18/11-go-api/safe.webp" class=""><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>HTTP 的 DELETE 方法不能携带多个资源名<br>解决方法：</p><ol><li>发起多个 DELETE 请求。</li><li>操作路径中带多个 id，id 之间用分隔符分隔, 例如：DELETE &#x2F;users?ids&#x3D;1,2,3 。</li><li>直接使用 POST 方式来批量删除，body 中传入需要删除的资源列表。</li></ol><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>&#x2F;v1&#x2F;login</p><h3 id="API-命名"><a href="#API-命名" class="headerlink" title="API 命名"></a>API 命名</h3><ul><li>驼峰命名法 ：&#x2F;resetUserPasswd</li><li>蛇形命名法 ：&#x2F;reset_user_passwd</li><li>脊柱命名法 ：&#x2F;reset-user-passwd</li></ul><h3 id="统一分页，排序，过滤"><a href="#统一分页，排序，过滤" class="headerlink" title="统一分页，排序，过滤"></a>统一分页，排序，过滤</h3><p>资源的查询接口，通常情况下都需要实现分页、过滤、排序、搜索功能，因为这些功能是每个 REST 资源都能用到的，所以可以实现为一个公共的 API 组件</p><ul><li>分页：在列出一个 Collection 下所有的 Member 时，应该提供分页功能，例如&#x2F;users?offset&#x3D;0&amp;limit&#x3D;20（limit，指定返回记录的数量；offset，指定返回记录的开始位置）。</li><li>过滤：如果用户不需要一个资源的全部状态属性，可以在 URI 参数里指定返回哪些属性，例如&#x2F;users?fields&#x3D;email,username,address。</li><li>排序：用户很多时候会根据创建时间或者其他因素，列出一个 Collection 中前 100 个 Member，这时可以在 URI 参数中指明排序参数，例如&#x2F;users?sort&#x3D;age,desc。</li><li>搜索：当一个资源的 Member 太多时，用户可能想通过搜索，快速找到所需要的 Member，或着想搜下有没有名字为 xxx 的某类资源，这时候就需要提供搜索功能。搜索建议按模糊匹配来搜索。</li></ul><hr><h2 id="RPC-API"><a href="#RPC-API" class="headerlink" title="RPC API"></a>RPC API</h2><p>服务端实现了一个函数，客户端使用 RPC 框架提供的接口，像调用本地函数一样调用这个函数，并获取返回值。RPC 屏蔽了底层的网络通信细节，使得开发人员无需关注网络编程的细节，可以将更多的时间和精力放在业务逻辑本身的实现上，从而提高开发效率。</p><img src="/2022/10/18/11-go-api/RPC.webp" class=""><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>Client 通过本地调用，调用 Client Stub。</li><li>Client Stub 将参数打包（也叫 Marshalling）成一个消息，然后发送这个消息。</li><li>Client 所在的 OS 将消息发送给 Server。</li><li>Server 端接收到消息后，将消息传递给 Server Stub。</li><li>Server Stub 将消息解包（也叫 Unmarshalling）得到参数。</li><li>Server Stub 调用服务端的子程序（函数），处理完后，将最终结果按照相反的步骤返回给 Client。</li></ol><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>google Remote Procedure Call</p><h4 id="Protocol-Buffers"><a href="#Protocol-Buffers" class="headerlink" title="Protocol Buffers"></a>Protocol Buffers</h4><p>对数据结构进行序列化的方法，可用作（数据）通信协议、数据存储格式等，也是一种更加灵活、高效的数据格式，与 XML、JSON 类似。它的传输性能非常好，所以常被用在一些对数据传输性能要求比较高的系统中，作为数据传输格式</p><ol><li>定义数据结构</li></ol><pre><code class="go">// 定义一个 SecretInfo 数据结构// SecretInfo contains secret details.message SecretInfo &#123;  string name = 1;  string secret_id  = 2;  string username   = 3;  string secret_key = 4;  int64 expires = 5;  string description = 6;  string created_at = 7;  string updated_at = 8;&#125;</code></pre><ol start="2"><li>定义服务接口</li></ol><pre><code class="go">// Cache implements a cache rpc service.service Cache&#123;  rpc ListSecrets(ListSecretsRequest) returns (ListSecretsResponse) &#123;&#125;  rpc ListPolicies(ListPoliciesRequest) returns (ListPoliciesResponse) &#123;&#125;&#125;</code></pre><ol start="3"><li>通过 protobuf 序列化和反序列化，提升传输效率</li></ol><h4 id="gRPC-demo"><a href="#gRPC-demo" class="headerlink" title="gRPC demo"></a>gRPC demo</h4><ul><li>定义 gRPC 服务。</li><li>生成客户端和服务器代码。</li><li>实现 gRPC 服务。</li><li>实现 gRPC 客户端。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-go-项目实战</title>
      <link href="/2022/10/17/10-go-gui-fan/"/>
      <url>/2022/10/17/10-go-gui-fan/</url>
      
        <content type="html"><![CDATA[<img src="/2022/10/17/10-go-gui-fan/landscape.webp" class="" title="go"><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p><code>yum -y install make autoconf automake cmake perl-CPAN libcurl-devel libtool gcc gcc-c++ glibc-headers zlib-devel git-lfs telnet lrzsz jq expat-devel openssl-devel </code></p><h2 id="Go-编译环境安装和配置"><a href="#Go-编译环境安装和配置" class="headerlink" title="Go 编译环境安装和配置"></a>Go 编译环境安装和配置</h2><p>见 <a href="https://earthayan.github.io/2022/10/01/01-golang-proxy/">https://earthayan.github.io/2022/10/01/01-golang-proxy/</a></p><h2 id="安装-ProtoBuf-的编译环境"><a href="#安装-ProtoBuf-的编译环境" class="headerlink" title="安装 ProtoBuf 的编译环境"></a>安装 ProtoBuf 的编译环境</h2><pre><code class="bash"># 第一步：安装 protobuf$ cd /tmp/$ git clone -b v3.21.1 --depth=1 https://github.com/protocolbuffers/protobuf$ cd protobuf$ ./autogen.sh$ ./configure$ make$ make install$ protoc --version # 查看 protoc 版本，成功输出版本号，说明安装成功# 第二步：安装 protoc-gen-go$ go install github.com/golang/protobuf/protoc-gen-go@v1.5.2</code></pre><blockquote><p>go install 之后会在 GOPATH 的 pkg 目录下生成对应的文件夹</p></blockquote><h3 id="多工作区模式"><a href="#多工作区模式" class="headerlink" title="多工作区模式"></a>多工作区模式</h3><ol><li>go work init .&#x2F;testDemo</li><li>go work use .&#x2F;iam</li></ol><p>上述操作会在 workSpace 目录下生成 go.work 文件</p><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="统一规范的作用："><a href="#统一规范的作用：" class="headerlink" title="统一规范的作用："></a>统一规范的作用：</h2><ul><li>统一代码风格，增加可读性</li><li>统一目录，增加代码的可维护性</li><li>统一对外提供的 API 接口</li><li>规范错误码，降低用户理解难度</li></ul><h2 id="规范的分类："><a href="#规范的分类：" class="headerlink" title="规范的分类："></a>规范的分类：</h2><h3 id="非编码类规范："><a href="#非编码类规范：" class="headerlink" title="非编码类规范："></a>非编码类规范：</h3><blockquote><ul><li>开源规范</li><li>文档规范</li><li>版本规范</li><li>commit 规范</li><li>项目发布规范</li></ul></blockquote><h3 id="编码类规范"><a href="#编码类规范" class="headerlink" title="编码类规范"></a>编码类规范</h3><blockquote><ul><li>目录规范</li><li>代码规范</li><li>接口规范</li><li>日志规范</li><li>错误码规范</li></ul></blockquote><h1 id="开源规范"><a href="#开源规范" class="headerlink" title="开源规范"></a>开源规范</h1><img src="/2022/10/17/10-go-gui-fan/opensource.webp" class="" title="开源规范选择"><p>开源项目附加规范：</p><ol><li>高单元测试覆盖率</li><li>代码库和提交记录中不能出现敏感信息和内部业务相关信息</li><li>及时处理 issue ,PR 等</li><li>能够持续地更新功能，修复 Bug,并及时进行文档输出</li></ol><h1 id="文档规范"><a href="#文档规范" class="headerlink" title="文档规范"></a>文档规范</h1><ul><li>README 规范：主要是用来介绍项目的功能、安装、部署和使用</li></ul><pre><code># 项目名称&lt;!-- 写一段简短的话描述项目 --&gt;## 功能特性&lt;!-- 描述该项目的核心功能点 --&gt;## 软件架构(可选)&lt;!-- 可以描述下项目的架构 --&gt;## 快速开始### 依赖检查&lt;!-- 描述该项目的依赖，比如依赖的包、工具或者其他任何依赖项 --&gt;### 构建&lt;!-- 描述如何构建该项目 --&gt;### 运行&lt;!-- 描述如何运行该项目 --&gt;## 使用指南&lt;!-- 描述如何使用该项目 --&gt;## 如何贡献&lt;!-- 告诉其他开发者如果给该项目贡献源码 --&gt;## 社区(可选)&lt;!-- 如果有需要可以介绍一些社区相关的内容 --&gt;## 关于作者&lt;!-- 这里写上项目作者 --&gt;## 谁在用(可选)&lt;!-- 可以列出使用本项目的其他有影响力的项目，算是给项目打个广告吧 --&gt;## 许可证&lt;!-- 这里链接上该项目的开源许可证 --&gt;</code></pre><ul><li>项目文档规范：包括一切需要文档化的内容，集中放在 &#x2F;docs 目录下</li></ul><p>常用目录结构</p><pre><code class="bash">docs├── devel                            # 开发文档，可以提前规划好，英文版文档和中文版文档│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构│       └── development.md           # 开发手册，可以说明如何编译、构建、运行项目├── guide                            # 用户文档│   ├── en-US/                       # 英文版文档，可以根据需要组织文件结构│   └── zh-CN                        # 中文版文档，可以根据需要组织文件结构│       ├── api/                     # API文档│       ├── best-practice            # 最佳实践，存放一些比较重要的实践文章│       │   └── authorization.md│       ├── faq                      # 常见问题│       │   ├── iam-apiserver│       │   └── installation│       ├── installation             # 安装文档│       │   └── installation.md│       ├── introduction/            # 产品介绍文档│       ├── operation-guide          # 操作指南，里面可以根据RESTful资源再划分为更细的子目录，用来存放系统核心/全部功能的操作手册│       │   ├── policy.md│       │   ├── secret.md│       │   └── user.md│       ├── quickstart               # 快速入门│       │   └── quickstart.md│       ├── README.md                # 用户文档入口文件│       └── sdk                      # SDK文档│           └── golang.md└── images                           # 图片存放目录    └── 部署架构v1.png</code></pre><ul><li><p>开发文档：说明项目的开发流程，比如如何搭建开发环境、构建二进制文件、测试、部署</p><ul><li>API 接口文档：描述组件提供的 API 接口，以及如何调用这些 API 接口<img src="/2022/10/17/10-go-gui-fan/api.webp" class="" title="接口文档编写方式"></li></ul></li><li><p>用户文档：软件的使用手册</p></li></ul><h1 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h1><ol><li>主版本号.次版本号.修订号（X.Y.Z）（初始值：0.1.0）<blockquote><p>X、Y 和 Z 为非负的整数，且禁止在数字前方补零。<br>主版本号：当做了不兼容的 API 修改<br>次版本号：当做了向下兼容的功能性新增及修改。这里有个不成文的约定需要你注意，偶数为稳定版本，奇数为开发版本。<br>修订号（PATCH）：当做了向下兼容的问题修正</p></blockquote></li><li>标记版本号的软件发行后，禁止改变该版本软件的内容，任何修改都必须以新版本发行</li><li>1.0.0 的版本号被界定为第一个稳定版本，之后的所有版本号更新都基于该版本进行修改</li></ol><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><ol><li>在实际开发的时候，使用 0.1.0 作为第一个开发版本号，并在后续的每次发行时递增次版本号</li><li>当我们的版本是一个稳定的版本，并且第一次对外发布时，版本号可以定为 1.0.0</li><li>严格按照 Angular commit message 规范提交代码时，版本号可以这么来确定：<ul><li>fix 类型的 commit 可以将修订号 +1</li><li>feat 类型的 commit 可以将次版本号 +1</li><li>带有 BREAKING CHANGE 的 commit 可以将主版本号 +1</li></ul></li></ol><h1 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h1><ol><li>每个 commit 的变更内容清晰，符合语义化</li><li>可依据 commit message 进行过滤查找 <code>git log --oneline --grep &quot;^feat|^fix|^perf&quot;</code></li><li>可以依据 commit message 生成 Change Log</li><li>格式规范化，可以依据某些类型的 Commit Message 触发构建或者发布流程，比如当 type 类型为 feat、fix 时才触发 CI 流程<img src="/2022/10/17/10-go-gui-fan/commit.webp" class="" title="commit规范"></li><li>Commit Message 规范自动化</li></ol><blockquote><p>注意:</p><ul><li>提交频率:<ol><li>只要对项目进行了修改，一通过测试就立即 commit，比如修复完一个 bug、开发完一个小功能，或者开发完一个完整的功能，自测和单元测试通过后就提交</li><li>规定一个时间，定期提交。下班前固定提交一次，并且要确保本地未提交的代码，延期不超过 1 天</li></ol></li></ul></blockquote><h1 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h1><ol><li>命名清晰简洁：能清晰表达出该目录实现的功能</li><li>功能明确：当需要新增一个功能时，能够非常清楚地知道把这个功能放在哪个目录下</li><li>全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。</li><li>可预测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</li><li>可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能</li></ol><h1 id="目录详解"><a href="#目录详解" class="headerlink" title="目录详解"></a>目录详解</h1><img src="/2022/10/17/10-go-gui-fan/dir.webp" class="" title="目录"><h2 id="Go-应用-前后端代码："><a href="#Go-应用-前后端代码：" class="headerlink" title="Go 应用-前后端代码："></a>Go 应用-前后端代码：</h2><ul><li><p>&#x2F;cmd<br>一个项目有很多组件，可以把组件 main 函数所在的文件夹统一放在&#x2F;cmd 目录下，需要保证</p><ol><li>每个组件的目录名应该跟你期望的可执行文件名是一致的</li><li>保证 &#x2F;cmd&#x2F;&lt;组件名&gt; 目录下不要存放太多的代码，如果你认为代码可以导入并在其他项目中使用，那么它应该位于 &#x2F;pkg 目录中</li><li>如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 &#x2F;internal 目录中</li></ol></li><li><p>&#x2F;internal<br>存放私有应用和库代码。如果一些代码，你不希望在其他应用和库中被导入，可以将这部分代码放在&#x2F;internal 目录下.</p><blockquote><p>在引入其它项目 internal 下的包时，Go 语言会在编译时报错</p></blockquote><ul><li><p>&#x2F;internal&#x2F;appName<br>存放真实的应用代码，应用的共享代码存放在&#x2F;- internal&#x2F;pkg 中</p><ul><li>&#x2F;internal&#x2F;appName&#x2F;api&#x2F;v1:HTTP API 接口的具体实现</li><li>&#x2F;internal&#x2F;appName&#x2F;options:应用的 command flag</li><li>&#x2F;internal&#x2F;appName&#x2F;config：根据命令行参数创建应用配置</li><li>&#x2F;internal&#x2F;appName&#x2F;service：存放应用复杂业务处理代码</li><li>&#x2F;internal&#x2F;appName&#x2F;store&#x2F;mysql：一个应用可能要持久化的存储一些数据，这里主要存放跟数据库交互的代码，比如 Create、Update、Delete、Get、List 等</li></ul></li><li><p>&#x2F;internal&#x2F;pkg<br>存放项目内可共享，项目外不共享的包。这些包提供了比较基础、通用的功能，例如工具、错误码、用户验证等功能。</p><ul><li>&#x2F;internal&#x2F;pkg&#x2F;code：项目业务 Code 码</li><li>&#x2F;internal&#x2F;pkg&#x2F;validation：一些通用的验证函数</li><li>&#x2F;internal&#x2F;pkg&#x2F;middleware：HTTP 处理链</li></ul></li></ul></li><li><p>&#x2F;pkg<br>存放可以被外部应用使用的代码库，其他项目可以直接通过 import 导入这里的代码</p></li><li><p>&#x2F;vendor<br>可通过 <code>go mod vendor</code> 创建</p></li><li><p>&#x2F;third_party<br>外部帮助工具，分支代码或其他第三方应用（例如 Swagger UI）</p></li></ul><hr><h2 id="Go-应用-测试相关："><a href="#Go-应用-测试相关：" class="headerlink" title="Go 应用-测试相关："></a>Go 应用-测试相关：</h2><ul><li>&#x2F;test<br>测试相关代码</li></ul><hr><h2 id="Go-应用-部署相关："><a href="#Go-应用-部署相关：" class="headerlink" title="Go 应用-部署相关："></a>Go 应用-部署相关：</h2><ul><li><p>&#x2F;configs<br>这个目录用来配置文件模板或默认配置。例如，可以在这里存放 confd 或 consul-template 模板文件。这里有一点要注意，配置中不能携带敏感信息，这些敏感信息，我们可以用占位符来替代</p></li><li><p>&#x2F;deployments<br>用来存放 Iaas、PaaS 系统和容器编排部署配置和模板（Docker-Compose，Kubernetes&#x2F;Helm，Mesos，Terraform，Bosh）。在一些项目，特别是用 Kubernetes 部署的项目中，这个目录可能命名为 deploy。</p></li><li><p>&#x2F;init<br>存放初始化系统（systemd，upstart，sysv）和进程管理配置文件（runit，supervisord）。比如 sysemd 的 unit 文件。这类文件，在非容器化部署的项目中会用到。</p><hr></li></ul><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><ul><li>&#x2F;Makefile<br>项目管理,format -&gt; lint -&gt; test -&gt; build</li><li>&#x2F;scripts<br>该目录主要用来存放脚本文件，实现构建、安装、分析等不同功能<ul><li>&#x2F;scripts&#x2F;make-rules<br>用来存放 makefile 文件，实现 &#x2F;Makefile 文件中的各个功</li><li>&#x2F;scripts&#x2F;lib<br>shell 库，用来存放 shell 脚本。一个大型项目中有很多自动化任务，比如发布、更新文档、生成代码等</li><li>&#x2F;scripts&#x2F;install<br>如果项目支持自动化部署，可以将自动化部署脚本放在此目录下。如果部署脚本简单，也可以直接放在 &#x2F;scripts 目录下。</li></ul></li><li>&#x2F;build<br>这里存放安装包和持续集成相关的文件。<ul><li>&#x2F;build&#x2F;package：存放容器（Docker）、系统（deb, rpm, pkg）的包配置和脚本。</li><li>&#x2F;build&#x2F;ci：存放 CI（travis，circle，drone）的配置文件和脚本。</li><li>&#x2F;build&#x2F;docker：存放子项目各个组件的 Dockerfile 文件</li></ul></li><li>&#x2F;tools<br>存放这个项目的支持工具。这些工具可导入来自 &#x2F;pkg 和 &#x2F;internal 目录的代码</li><li>&#x2F;githooks<br>Git 钩子。比如，我们可以将 commit-msg 存放在该目录</li><li>&#x2F;assets<br>静态资源</li><li>&#x2F;website<br>放置项目网站相关的数据</li></ul><hr><h2 id="文档："><a href="#文档：" class="headerlink" title="文档："></a>文档：</h2><ul><li>&#x2F;README.md</li><li>&#x2F;docs<ul><li>&#x2F;docs&#x2F;devel：存放开发文档、hack 文档等。</li><li>&#x2F;docs&#x2F;guide: 存放用户手册，安装、quickstart、产品文档等，分为中文文档和英文文档。</li><li>&#x2F;docs&#x2F;images：存放图片文件</li></ul></li><li>&#x2F;api<br>存放的是当前项目对外提供的各种不同类型的 API 接口定义文件</li><li>&#x2F;examples<br>存放应用程序或者公共包的示例代码。这些示例代码可以降低使用者的上手门槛</li></ul><hr><h2 id="基础目录结构"><a href="#基础目录结构" class="headerlink" title="基础目录结构"></a>基础目录结构</h2><pre><code class="bash">$ tree --noreport -L 2 tmstms├── cmd├── internal├── pkg└── README.md</code></pre><p>[注]在设计目录结构时，一些空目录无法提交到 Git 仓库中，但我们又想将这个空目录上传到 Git 仓库中，以保留目录结构。这时候，可以在空目录下加一个 .keep 文件</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-go-并发</title>
      <link href="/2022/10/17/09-go-bing-fa/"/>
      <url>/2022/10/17/09-go-bing-fa/</url>
      
        <content type="html"><![CDATA[<p>开启方法：通过 go 关键字来开启 goroutine <code>go 函数名( 参数列表 )</code></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-go-错误处理</title>
      <link href="/2022/10/17/08-go-cuo-wu-chu-li/"/>
      <url>/2022/10/17/08-go-cuo-wu-chu-li/</url>
      
        <content type="html"><![CDATA[<p>goLang 内部错误处理<br>方法：函数通常在最后的返回值中返回错误信息。使用 errors.New 可返回一个错误信息</p><pre><code class="go">type DivideError struct &#123;    dividee int    divider int&#125;func (de *DivideError) Error() string &#123;    strFormat := `    Cannot proceed, the divider is zero.    dividee: %d    divider: 0    `    return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 `int` 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider == 0 &#123;        dData := DivideError&#123;            dividee: varDividee,            divider: varDivider,        &#125;        errorMsg = dData.Error()        return    &#125; else &#123;        return varDividee / varDivider, &quot;&quot;    &#125;&#125;func TestError() &#123;    // 正常情况    if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123;        fmt.Println(&quot;100/10 = &quot;, result)    &#125;    // 当除数为零的时候会返回错误信息    if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123;        fmt.Println(&quot;errorMsg is: &quot;, errorMsg)    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-go-递归和类型转换</title>
      <link href="/2022/10/17/07-go-di-gui-he-lei-xing-zhuan-huan/"/>
      <url>/2022/10/17/07-go-di-gui-he-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的概念：在运行的过程中调用自己<br>递归的用法：在使用递归时，开发者需要设置退出条件，否则递归将陷入无限循环中</p><pre><code class="go">func recursion() &#123;   recursion() /* 函数调用自身 */&#125;func main() &#123;   recursion()&#125;</code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>格式：类型名称(表达式)<br>注意：不支持隐式转换类型</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>定义：把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p><pre><code class="go">/* 定义接口 */type 接口名称 interface &#123;   方法名1 [返回类型]   ...   方法名n [返回类型]&#125;/* 定义结构体 */type 结构体名称 struct &#123;   /* variables */&#125;/* 实现接口方法 */func (struct_name_variable 结构体名称)  方法名1 () [返回类型] &#123;   /* 方法实现 */&#125;...func (struct_name_variable 结构体名称) 方法名n() [返回类型] &#123;   /* 方法实现*/&#125;</code></pre><h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><pre><code class="go">type Phone interface &#123;    call()&#125;type NokiaPhone struct &#123;&#125;type IPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123;    fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;func (iPhone IPhone) call() &#123;    fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func TestInterface() &#123;    var phone Phone    phone = new(NokiaPhone)    phone.call()    phone = new(IPhone)    phone.call()&#125;/**I am Nokia, I can call you!I am iPhone, I can call you! */</code></pre><pre><code class="go">type MobilePhone interface &#123;    call()    call2()&#125;type ApplePhone struct &#123;    id            int    name          string    category_id   int    category_name string&#125;func (test ApplePhone) call() &#123;    fmt.Println(&quot;这是第一个类的第一个接口回调函数 结构体数据：&quot;, ApplePhone&#123;id: 1, name: &quot;浅笑&quot;&#125;)&#125;func (test ApplePhone) call2() &#123;    fmt.Println(&quot;这是一个类的第二个接口回调函数call2&quot;, ApplePhone&#123;id: 1, name: &quot;浅笑&quot;, category_id: 4, category_name: &quot;分类名称&quot;&#125;)&#125;type Android struct &#123;    member_id       int    member_balance  float32    member_sex      bool    member_nickname string&#125;func (test Android) call() &#123;    fmt.Println(&quot;这是第二个类的第一个接口回调函数call&quot;, Android&#123;member_id: 22, member_balance: 15.23, member_sex: false, member_nickname: &quot;浅笑18&quot;&#125;)&#125;func (test Android) call2() &#123;    fmt.Println(&quot;这是第二个类的第二个接口回调函数call2&quot;, Android&#123;member_id: 44, member_balance: 100, member_sex: true, member_nickname: &quot;陈超&quot;&#125;)&#125;func TestInterfaceDemo() &#123;    var phoneD MobilePhone    phoneD = new(ApplePhone)    phoneD.call()    phoneD.call2()    phoneD = new(Android)    phoneD.call()    phoneD.call2()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-go数组</title>
      <link href="/2022/10/14/06-go-shu-zu/"/>
      <url>/2022/10/14/06-go-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>具有<font color=red>相同唯一类型</font>（原始类型&#x2F;自定义类型）的一组已编号且<font color=red>长度固定</font>的数据项序列</p><h3 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h3><ul><li>一维数组：var balance [10] float32</li><li>二维数组：var arrayName [ x ][ y ] float32</li></ul><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li><code>balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;</code></li><li>如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度</li><li>通过指定下标初始化元素：<code>balance := [5]float32&#123;1:2.0,3:7.0&#125;</code><blockquote><p>…是go的语法糖，有两种用处：</p><ol><li>用于函数有多个不定参数的情况，可以接受多个不确定数量的参数</li><li>切片可以打散进行传递</li></ol></blockquote></li></ul><pre><code class="go">func test1(args ...string) &#123; //用法1    for _, v:= range args&#123;        fmt.Println(v)    &#125;&#125;func main()&#123;    var strss= []string&#123;        &quot;qwr&quot;,        &quot;234&quot;,        &quot;yui&quot;,        &quot;cvbc&quot;,    &#125;    test1(strss...) //用法2&#125;</code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><pre><code class="go">a := [3][4]int&#123; &#123;0, 1, 2, 3&#125; ,   /*  第一行索引为 0 */ &#123;4, 5, 6, 7&#125; ,   /*  第二行索引为 1 */ &#123;8, 9, 10, 11&#125;,   /* 第三行索引为 2 */&#125;</code></pre><h3 id="访问数组元素："><a href="#访问数组元素：" class="headerlink" title="访问数组元素："></a>访问数组元素：</h3><p>方法：通过索引未知来读取，<code>var salary float32 = balance[9]</code></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>取地址符：&amp;<br>一个指针变量指向了一个值的内存地址</p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ul><li>定义指针变量。</li><li>为指针变量赋值。</li><li>访问指针变量中指向地址的值。</li></ul><pre><code class="go">func main() &#123;    var a int = 20    var ip *int //声明指针，指针变量指向了一个值的内存地址    ip = &amp;a     //对指针变量赋值    fmt.Printf(&quot;a变量的地址是:%x\n&quot;, &amp;a)    fmt.Printf(&quot;ip 变量存储的指针地址:%x\n&quot;, ip)    fmt.Printf(&quot;*ip 变量的值: %v\n&quot;, *ip)&#125;// 输出结果：===========// a变量的地址是:c00001c030// ip 变量存储的指针地址:c00001c030// *ip 变量的值: 20</code></pre><h3 id="空指针-nil"><a href="#空指针-nil" class="headerlink" title="空指针 nil"></a>空指针 <code>nil</code></h3><h3 id="指针数组var-ptr-MAX-int"><a href="#指针数组var-ptr-MAX-int" class="headerlink" title="指针数组var ptr [MAX]*int;"></a>指针数组<code>var ptr [MAX]*int;</code></h3><pre><code class="go">const MAX int = 3func main() &#123;    var ptr [MAX]*int//声明了整型指针数组    a := []int&#123;10, 100, 200&#125;    var i int    for i = 0; i &lt; MAX; i++ &#123;        ptr[i] = &amp;a[i]    &#125;    for i = 0; i &lt; MAX; i++ &#123;        fmt.Printf(&quot;a[%d]=%d\n&quot;, i, *ptr[i])    &#125;&#125;// 输出结果:=============// a[0]=10// a[1]=100// a[2]=200</code></pre><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><pre><code class="go">func main() &#123;    var a int    var ptr *int    var pptr **int    a = 3000    ptr = &amp;a    pptr = &amp;ptr    fmt.Printf(&quot;变量a=%d\n&quot;, a)    fmt.Printf(&quot;指针变量 *ptr=%d\n&quot;, *ptr)    fmt.Printf(&quot;指向指针的指针变量 **pptr = %d\n&quot;, **pptr)    fmt.Printf(&quot;变量a的地址是:%v\n&quot;, &amp;a)    fmt.Printf(&quot;指针ptr的值为:%v\n&quot;, ptr)    fmt.Printf(&quot;指针ptr的地址是:%v\n&quot;, &amp;ptr)    fmt.Printf(&quot;指针pptr的值为:%v\n&quot;, pptr)&#125;//输出结果================// 变量a=3000// 指针变量 *ptr=3000// 指向指针的指针变量 **pptr = 3000// 变量a的地址是:0xc0000b2000// 指针ptr的值为:0xc0000b2000// 指针ptr的地址是:0xc0000ac018// 指针pptr的值为:0xc0000ac018</code></pre><h3 id="指针作为函数的参数使用"><a href="#指针作为函数的参数使用" class="headerlink" title="指针作为函数的参数使用"></a>指针作为函数的参数使用</h3><p>可使用前提:需要在函数定义的参数上设置为指针类型</p><pre><code class="go">func main() &#123;    var a int = 100    var b int = 200    fmt.Printf(&quot;交换前 a 的值 : %d\n&quot;, a)    fmt.Printf(&quot;交换前 b 的值 : %d\n&quot;, b)    fmt.Printf(&quot;交换前 a 的地址 : %v\n&quot;, &amp;a)    fmt.Printf(&quot;交换前 b 的地址 : %v\n&quot;, &amp;b)    swap(&amp;a, &amp;b)    fmt.Printf(&quot;交换后 a 的值 : %d\n&quot;, a)    fmt.Printf(&quot;交换后 b 的值 : %d\n&quot;, b)    fmt.Printf(&quot;交换后 a 的地址 : %v\n&quot;, &amp;a)    fmt.Printf(&quot;交换后 b 的地址 : %v\n&quot;, &amp;b)&#125;func swap(x *int, y *int) &#123;    var temp int    temp = *x    *x = *y    *y = temp&#125;// 输出结果// 交换前 a 的值 : 100// 交换前 b 的值 : 200// 交换前 a 的地址 : 0xc00001c030// 交换前 b 的地址 : 0xc00001c038// 交换后 a 的值 : 200// 交换后 b 的值 : 100// 交换后 a 的地址 : 0xc00001c030// 交换后 b 的地址 : 0xc00001c038</code></pre><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>由一系列具有相同类型或不同类型的数据构成的数据集合，一个结构体表示一项记录</p><pre><code class="go">type Book struct &#123;    title   string    author  string    subject string    book_id int&#125;func main() &#123;    book1 := Book&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;, &quot;Go 语言教程&quot;, 6495407&#125;    book1.subject = &quot;编程&quot;    fmt.Println(book1)    book2 := Book&#123;title: &quot;Go 语言2&quot;, author: &quot;www.runoob.com&quot;, subject: &quot;Go 语言教程2&quot;, book_id: 6495408&#125;    fmt.Println(book2)    book3 := Book&#123;title: &quot;Go 语言3&quot;, subject: &quot;www.runoob.com&quot;&#125;    book3.book_id = 111    fmt.Println(book3.book_id)    fmt.Println(book3.author)    book4 := Book&#123;&quot;Go 语言&quot;, &quot;www.runoob.com&quot;&#125;    fmt.Println(book4)    // 输出结果============// &#123;Go 语言 www.runoob.com 编程 6495407&#125;// &#123;Go 语言2 www.runoob.com Go 语言教程2 6495408&#125;// 111// Error:too few values in Book&#123;…&#125;&#125;</code></pre><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>方式：结构体.成员名</p><pre><code class="go">type Book struct &#123;    title   string    author  string    subject string    book_id int&#125;func printBook(book *Book) &#123;    fmt.Printf(&quot;Book title:%s\n&quot;, book.title)&#125;func main() &#123;    var Book1 Book    var Book2 Book    Book1.title = &quot;Go语言&quot;    Book2.title = &quot;Go语言2&quot;    printBook(&amp;Book1)    printBook(&amp;Book2)&#125;</code></pre><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h2><p>本质：对数组的抽象,即动态数组<br>区别：</p><ol><li>长度不固定</li><li>可以追加元素</li><li>追加元素的时候可能使切片容量增大</li></ol><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><ol><li>使用make创建:<br>make([]类型,初始长度,容量)</li></ol><pre><code class="go">nodes:=make([]int,3,10)</code></pre><ol start="2"><li>声明一个未知长度的数组</li></ol><pre><code class="go">var nodes int[]</code></pre><h3 id="初始化：-1"><a href="#初始化：-1" class="headerlink" title="初始化："></a>初始化：</h3><ol><li>s :&#x3D;[] int {1,2,3 } </li><li>初始化切片 s，是数组 arr 的引用。 s:&#x3D;arr[起始位置index1:结束位置index2],从index1~index2-1</li></ol><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数:"></a>常见函数:</h3><ul><li>len() 获取长度</li><li>cap() 计算容量,测量切片最长可以达到多少</li><li>append(切片名称,元素) 向切片追加新元素:<code>numbers=append(numbers,1,2)</code></li><li>copy(numbers1,numbers) 拷贝 numbers 的内容到 numbers1 <code>copy(numbers1,numbers)</code><br>copy函数只会拷贝numbers1的长度</li></ul><pre><code class="go">func printSlice(x []int) &#123;    fmt.Printf(&quot;len=%d cap=%d slice=%v\n&quot;, len(x), cap(x), x)&#125;func main() &#123;    numbers := []int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8&#125;    printSlice(numbers)    numbers1 := make([]int, 2, 5)    printSlice(numbers1)    copy(numbers1, numbers)    printSlice(numbers1)&#125;// ======输出结果// len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]// len=2 cap=5 slice=[0 0]// len=2 cap=5 slice=[0 1]</code></pre><h2 id="范围-Range"><a href="#范围-Range" class="headerlink" title="范围 Range"></a>范围 Range</h2><p>关键字：range<br>作用：用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素<br>返回值：在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对</p><pre><code class="go">for key, value := range oldMap &#123;    newMap[key] = value&#125;</code></pre><h2 id="集合-Map"><a href="#集合-Map" class="headerlink" title="集合 Map"></a>集合 Map</h2><p>概念：无序的键值对的集合<br>实现：hash 表</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>作用：用于删除集合的元素, 参数为 map 和其对应的 key</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-go-函数与作用域</title>
      <link href="/2022/10/10/05-go-han-shu-yu-zuo-yong-yu/"/>
      <url>/2022/10/10/05-go-han-shu-yu-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li>形参：定义函数时，用于接收外部传入的数据，叫做形式参数，简称形参</li><li>实参：调用函数时，传给形参的实际的数据，叫做实际参数，简称实参。</li></ul><h4 id="传参方式"><a href="#传参方式" class="headerlink" title="传参方式"></a>传参方式</h4><ul><li>值传递（默认）：<ul><li>定义：指在调用函数时将实际参数复制一份传递到函数中</li><li>影响：在函数中如果对参数进行修改，将不会影响到实际参数</li></ul><pre><code class="go">func SwapByValPass(x,y int) int&#123;    var temp int    temp=x    x=y    y=temp    return temp   //交换前100，200,交换后不变&#125;</code></pre></li><li>引用传递<ul><li>定义：指在调用函数时将实际参数的地址传递到函数中</li><li>影响：在函数中对参数所进行的修改，将影响到实际参数</li><li>实际测试：参数值变化，但是参数地址不变</li></ul><pre><code class="go">func SwapByReferPass(x *int,y *int)&#123;    var temp int    temp = *x    *x=*y    *y=temp//交换前100，200,交换后200，100&#125;</code></pre></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>匿名函数，可作为闭包。优越性在于可以直接使用函数内的变量，不必申明</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集</p><pre><code class="go">// 普通函数func function_name( [parameter list] ) [return_types] &#123;   函数体&#125;// 方法func (variable_name variable_data_type) function_name() [return_type]&#123;   /* 函数体*/&#125;/* 定义结构体 */type Circle struct &#123;  radius float64&#125;func main() &#123;  var c1 Circle  c1.radius = 10.00  fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())&#125;//该 method 属于 Circle 类型对象中的方法func (c Circle) getArea() float64 &#123;  //c.radius 即为 Circle 类型对象中的属性  return 3.14 * c.radius * c.radius&#125;</code></pre><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul><li>局部变量：函数内定义的变量，作用域只在函数体内</li><li>全局变量：函数外定义的变量，可以在整个包甚至外部包（被导出后）使用</li><li>全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑</li><li>形式参数：函数定义中的变量称为形式参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-运算符和语句</title>
      <link href="/2022/10/09/04-go-yun-suan-fu-he-yu-ju/"/>
      <url>/2022/10/09/04-go-yun-suan-fu-he-yu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算符：<code>+ - * / % ++ --</code></li><li>关系运算符：<code>== != &gt; &lt; &gt;= &lt;= </code></li><li>逻辑运算符：<code>&amp;&amp; || !</code></li><li>位运算符：<code>&amp; | ^(异或) &lt;&lt;(*2^n) &gt;&gt;(/2^n)</code></li><li>赋值运算符：<code>= += -= *= /= </code>等</li><li>&amp;：返回变量实际存储地址</li><li>*：指针变量</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>5</td><td>算术运算符（* &#x2F; % ），位运算符(&lt;&lt; &gt;&gt; &amp;)</td></tr><tr><td>4</td><td>算术运算符（+ - ）,位运算符（| ^）</td></tr><tr><td>3</td><td>关系运算符（&#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;），</td></tr><tr><td>2</td><td>逻辑运算符（&amp;&amp;）</td></tr><tr><td>1</td><td>逻辑运算符（ | | ）</td></tr></tbody></table><blockquote><p>注意点：Go 的自增，自减只能作为表达式使用，而不能用于赋值语句。</p></blockquote><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><blockquote><ol><li>不支持三目运算符</li><li>switch 如果 case 带有 fallthrough，程序会强制执行下一条 case</li></ol></blockquote><h3 id="普通-if-x2F-else-和-switch"><a href="#普通-if-x2F-else-和-switch" class="headerlink" title="普通 if&#x2F;else 和 switch"></a>普通 if&#x2F;else 和 switch</h3><pre><code class="go">// if/elsevar a int = 10if a &lt; 20 &#123;  /* 如果条件为 true 则执行以下语句 */  fmt.Printf(&quot;a 小于 20\n&quot; )&#125;// switchvar grade string = &quot;B&quot;var marks int = 90switch marks &#123;  case 90: grade = &quot;A&quot;  case 80: grade = &quot;B&quot;  case 50,60,70 : grade = &quot;C&quot;  default: grade = &quot;D&quot;&#125;switch &#123;  case grade == &quot;A&quot; :      fmt.Printf(&quot;优秀!\n&quot; )  case grade == &quot;B&quot;, grade == &quot;C&quot; :      fmt.Printf(&quot;良好\n&quot; )  case grade == &quot;D&quot; :      fmt.Printf(&quot;及格\n&quot; )  case grade == &quot;F&quot;:      fmt.Printf(&quot;不及格\n&quot; )  default:      fmt.Printf(&quot;差\n&quot; );&#125;</code></pre><h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>判断某个 interface 变量中实际存储的变量类型</p><pre><code class="go">var x interface&#123;&#125;switch i := x.(type) &#123;  case nil:      fmt.Printf(&quot; x 的类型 :%T&quot;,i)  case int:      fmt.Printf(&quot;x 是 int 型&quot;)  case float64:      fmt.Printf(&quot;x 是 float64 型&quot;)  case func(int) float64:      fmt.Printf(&quot;x 是 func(int) 型&quot;)  case bool, string:      fmt.Printf(&quot;x 是 bool 或 string 型&quot; )  default:      fmt.Printf(&quot;未知型&quot;)&#125;</code></pre><h3 id="select-语句-没看懂"><a href="#select-语句-没看懂" class="headerlink" title="select 语句(没看懂)"></a>select 语句(没看懂)</h3><blockquote><ol><li>随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的</li><li>如果有多个 case 都可以运行，Select 会随机选出一个执行。其他不会执行</li></ol></blockquote><pre><code class="go">var c1, c2, c3 chan intvar i1, i2 intselect &#123;  case i1 = &lt;-c1:      fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)  case c2 &lt;- i2:      fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)  case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3      if ok &#123;        fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)      &#125; else &#123;        fmt.Printf(&quot;c3 is closed\n&quot;)      &#125;  default:      fmt.Printf(&quot;no communication\n&quot;)&#125;</code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h3><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>作用：重复执行语句块<br>格式：</p><ol><li><font color=red>for init; condition; post { }</font></li></ol><pre><code class="go">func GetSum()&#123;    sum:=0    for i:=0;i&lt;=10;i++&#123;        sum+=i    &#125;    fmt.Println(sum)&#125;</code></pre><ol start="2"><li><font color=red>for condition { }</font></li></ol><pre><code class="go">func GetSumOnlyCondition()&#123;  sum:=0  for ;sum&lt;=10;&#123;      sum+=sum  &#125;  for sum&lt;=10&#123;      sum+=sum  &#125;  fmt.Println(sum)&#125;</code></pre><ol start="3"><li><font color=red>for { }</font>(无限循环)</li></ol><blockquote><ul><li>init:赋值表达式，给控制变量赋初值</li><li>关系表达式或逻辑表达式，循环控制条件</li><li>一般为赋值表达式，给控制变量增量或减量</li></ul></blockquote><p>步骤：</p><ol><li>对表达式 1 赋初值</li><li>判别赋值表达式 init 是否满足给定条件<br>a. 若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition<br>b. 否则判断 condition 的值为假，不满足条件，就终止 for 循环，执行循环体外语句</li></ol><h4 id="range-循环"><a href="#range-循环" class="headerlink" title="range 循环"></a>range 循环</h4><p>作用：对字符串、数组、切片等进行迭代输出元素</p><pre><code class="go">strings := []string&#123;&quot;google&quot;, &quot;runoob&quot;&#125;//定义数组for i, s := range strings &#123;  fmt.Println(i, s)&#125;numbers := [6]int&#123;1, 2, 3, 5&#125;for i,x:= range numbers &#123;  fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i,x)&#125;</code></pre><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><ul><li>有标记：跳出标记处循环</li><li>无标记：跳出当前循环</li></ul><pre><code class="go">func LoopBreakWithLabel()&#123;  for i := 1; i &lt;= 3; i++ &#123;    fmt.Printf(&quot;i: %d\n&quot;, i)    ref:      for i2 := 11; i2 &lt;= 13; i2++ &#123;          fmt.Printf(&quot;i2: %d\n&quot;, i2)          break ref      &#125;  &#125;&#125;</code></pre><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>跳过当前循环执行下一次循环语句</p><ul><li>有标记：在标记处重新执行</li><li>无标记：直接在当前循环重新执行</li></ul><h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><p>通常与条件语句配合使用，实现条件转移， 构成循环，跳出循环体</p><pre><code class="go">/* 定义局部变量 */var a int = 10/* 循环 */LOOP: for a &lt; 20 &#123;  if a == 15 &#123;      /* 跳过迭代 */      a = a + 1      goto LOOP  &#125;  fmt.Printf(&quot;a的值为 : %d\n&quot;, a)  a++&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-go 基础语法</title>
      <link href="/2022/10/09/03-go-basic-synax/"/>
      <url>/2022/10/09/03-go-basic-synax/</url>
      
        <content type="html"><![CDATA[<p>关键字，标识符(变量，类型)，常量，字符串，符号-&gt;标记-&gt;GO 程序</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>标识符：<code>A-Z,a-z,0-9,下划线\_</code>，第一个字符不能是数字</li><li>字符串拼接：使用<code>+</code>实现</li><li>保留字或者关键字不能作为标识符名</li><li>变量的声明必须使用空格隔开 <code>var age int</code></li><li>Go 程序是通过 package 来组织的，只有 package 名称为 main 的源码文件可以包含 main 函数，一个可执行程序有且仅有一个 main 包，其他包中即使有 main 函数也不会执行</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>布尔型：<ul><li>true</li><li>false</li></ul></li><li>数字:<ul><li>int&#x2F;float32&#x2F;float64</li><li>支持复数</li><li>位的运算采用补码</li><li>无需定义 int 及 float32、float64，系统会自动识别</li></ul></li><li>字符串</li><li>派生类型<ul><li>指针类型 Pointer</li><li>数组类型</li><li>结构化类型 struct</li><li>Channel 类型 chan</li><li>函数类型 func</li><li>切片类型</li><li>接口类型 interface</li><li>Map 类型</li></ul></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="变量组成"><a href="#变量组成" class="headerlink" title="变量组成"></a>变量组成</h3><p><code>A-Z,a-z,0-9,下划线\_</code>，第一个字符不能是数字</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ol><li>可一次声明多个变量 <code>var identifier1, identifier2 type</code></li><li>不同类型的变量不可以一次声明多个 <code>var i int,f float64</code>会语法报错</li></ol><h4 id="类型和变量声明"><a href="#类型和变量声明" class="headerlink" title="类型和变量声明"></a>类型和变量声明</h4><ol><li>指定变量类型，如果没有初始化，则变量默认为零值（即该类型的系统默认值）</li><li>系统根据值自行判定变量类型</li><li>如果变量已经使用 var 声明过了，再使用 :&#x3D; 声明变量，就产生编译错误，</li></ol><pre><code class="go">intVal := 1//上下两者意义一致var intVal intintVal =1</code></pre><h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><pre><code class="go">//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 //  := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var (    vname1 v_type1    vname2 v_type2)</code></pre><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><ul><li>定义：使用这些类型的变量直接指向存在内存中的值</li><li>范围：基本类型都属于值类型</li><li>拷贝：当使用等号 &#x3D; 将一个变量的值赋值给另一个变量时，如：j &#x3D; i，实际上是在内存中将 i 的值进行了拷贝</li><li>存储：存储在堆中，通过 &amp;i 来获取变量 i 的内存地址 <code> fmt.Printf(&quot;地址：%d&quot;,&amp;i)</code></li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li>存储：一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。内存地址称之为指针</li><li>拷贝：当使用赋值语句 r2 &#x3D; r1 时，只有引用（地址）被复制，修改变量 r1 和 r2 会互相影响</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>类型：布尔型、数字型和字符串型</li><li>在定义常量组的时候，如果不提供初始值，则初始值自动设置为上一行的<font color=red><strong>表达式</strong></font></li><li>定义：</li></ul><pre><code class="go">const b string = &quot;abc&quot; //显式类型定义const b = &quot;abc&quot; //隐式类型定义</code></pre><ul><li>常量表达式中，函数必须是 <code>len(), cap(), unsafe.Sizeof()</code>这些内置函数</li></ul><h3 id="特殊常量-iota"><a href="#特殊常量-iota" class="headerlink" title="特殊常量 iota"></a>特殊常量 iota</h3><p>特殊之处：</p><ul><li>可以被编译器修改的常量</li><li>iota 在 const 关键字下次出现时将被重置为 0，const 中每新增一行常量声明将使 iota 计数一次</li></ul><pre><code class="go">func GetIOTA()&#123;    const (        a = iota   //0        b          //1        c          //2        d = &quot;ha&quot;   //独立值，iota += 1        e          //&quot;ha&quot;   iota += 1        f = 100    //iota +=1        g          //100  iota +=1        h = iota   //7,恢复计数        i          //8    )    fmt.Printf(&quot;ITOA:%v %v %v %q %q %v %v %v %v\n&quot;,a,b,c,d,e,f,g,h,i)//0 1 2 ha ha 100 100 7 8&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-用go写一个hello_word程序</title>
      <link href="/2022/10/08/02-go-hello-world/"/>
      <url>/2022/10/08/02-go-hello-world/</url>
      
        <content type="html"><![CDATA[<p>去除 go.mod 文件中项目不需要的依赖：<code>go mod tidy </code></p><h2 id="用-go-写一个-hello-word-程序"><a href="#用-go-写一个-hello-word-程序" class="headerlink" title="用 go 写一个 hello_word 程序"></a>用 go 写一个 hello_word 程序</h2><p>go_demo&#x2F;pki&#x2F;main.go</p><pre><code class="go">// 包声明:源文件中非注释的第一行,指明这个文件属于哪个包// package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包package main// 引入包:告诉 Go 编译器这个程序需要使用 fmt 包// 方式1：编写多个导入语句// 方式2: 用圆括号组合了导入import &quot;fmt&quot;// 程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，// 一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）func main()&#123;    /* 这是我的第一个简单的程序 */    fmt.Println(&quot;Hello, World!&quot;)&#125;func init()&#123;    fmt.Println(&quot;init me first!&quot;)&#125;</code></pre><blockquote><h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><ol><li>当标识符以一个大写字母开头,使用这种形式的标识符的对象就可以被外部包的代码所使用，即导出</li><li>标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的</li><li>函数的左侧大括号不能单独一行，否则会报错</li><li>导入：方式 1-编写多个导入语句;方式 2-用圆括号组合导入</li></ol></blockquote><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><pre><code class="bash"> go run pki/main.go</code></pre><p>运行结果</p><img src="/2022/10/08/02-go-hello-world/hello.jpg" class="" title="执行go run"><h2 id="生成二进制文件"><a href="#生成二进制文件" class="headerlink" title="生成二进制文件"></a>生成二进制文件</h2><p>在根目录处生成同名二进制文件</p><pre><code class="bash">go build pki/main.go</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="导入同一个项目中的本地包报错"><a href="#导入同一个项目中的本地包报错" class="headerlink" title="导入同一个项目中的本地包报错"></a>导入同一个项目中的本地包报错</h3><img src="/2022/10/08/02-go-hello-world/error.jpg" class="" title="导入本地包报错"><p>官方文档(1.16)提供的方法:</p><ol><li>进入待导入本地包目录</li><li>执行 <code>go build</code></li><li>进入项目根目录</li><li>执行 <code>go install go_demo</code></li></ol><blockquote><p>结果:本地开发环境为 1.19,验证为在该版本上无效,报错同尝试 1</p></blockquote><h4 id="尝试-1"><a href="#尝试-1" class="headerlink" title="尝试 1:"></a>尝试 1:</h4><pre><code class="go">import (    &quot;fmt&quot;    &quot;go_demo/mathClass&quot;)</code></pre><p>结果:</p><blockquote><p>package go_demo&#x2F;mathClass is not in GOROOT</p></blockquote><h4 id="尝试-2"><a href="#尝试-2" class="headerlink" title="尝试 2:"></a>尝试 2:</h4><p>菜鸟教程上有一个笔记说包名和文件夹名称无关,于是基于尝试 1,将 package 名称和对应的文件夹名称修改一致<br>结果:成功,但是不知道为啥…</p><p>补充：如果觉得包名和文件夹名称必须一致很麻烦，可以使用别名的方式</p><pre><code class="go">import (    &quot;fmt&quot;    complex &quot;test_mod/ArrayDemo&quot;    &quot;test_mod/functionList&quot;)func init() &#123;    fmt.Println(&quot;init me first!&quot;)    complex.GetAddress()&#125;</code></pre><img src="/2022/10/08/02-go-hello-world/package.png" class="" title="package和文件夹名称不一样的时候的处理"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h2><p><a href="https://github.com/golang/go/issues/38812">issue#38812</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-Go语言环境的安装</title>
      <link href="/2022/10/01/01-golang-proxy/"/>
      <url>/2022/10/01/01-golang-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h3><p>下载<a href="https://golang.google.cn/dl/go1.19.2.windows-amd64.msi">文件</a>，直接 next 直至完成</p><h3 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h3><h4 id="通用步骤"><a href="#通用步骤" class="headerlink" title="通用步骤"></a>通用步骤</h4><ol><li>安装必要的包</li></ol><pre><code class="bash">yum install mercurialyum install gityum install gcc</code></pre><ol start="2"><li>下载 go 的压缩包并解压缩</li></ol><pre><code class="bash">cd /usr/local/wget https://go.dev/dl/go1.19.2.linux-amd64.tar.gz</code></pre><blockquote><p>如果该地址不可用 443，可以使用 <font color="red"><code>https://golang.google.cn/dl/go1.19.2.linux-amd64.tar.gz</code></font> 代替</p></blockquote><ol start="3"><li>添加 PATH 环境变量</li></ol><pre><code class="bash">vi ~/.bash_profile# ~/.bash_profile添加内容export GOROOT=/usr/local/go ##Golang安装目录export PATH=$PATH:$GOROOT/bin# 刷新环境变量source ~/.bash_profile</code></pre><ol start="4"><li>验证是否安装成功<img src="/2022/10/01/01-golang-proxy/go_version.jpg" class="" title="安装成功"></li></ol><h4 id="v1-11-以前"><a href="#v1-11-以前" class="headerlink" title="v1.11 以前"></a>v1.11 以前</h4><ol><li>设置 GOPATH 环境变量（go 1.11 后不必设置,可使用 go module）</li></ol><pre><code class="bash">export GOPATH=xxxx(即使手动设置为空，也会默认为/root/go)</code></pre><ol start="2"><li>建立 Go 的工作空间（workspace，也就是 GOPATH 环境变量指向的目录）】<blockquote><p>GO 代码必须在工作空间内。工作空间是一个目录，其中包含三个子目录：</p><ul><li>src —- 存放 golang 项目代码的位置,里面每一个子目录，就是一个包。</li><li>pkg —- 编译后生成的，包的目标文件</li><li>bin —- 生成的可执行文件，比如执行 <code>go get github.com/google/gops</code>,bin 目录会生成 gops 的二进制文件。</li></ul></blockquote></li></ol><pre><code class="bash">cd /rootmkdir gocd go/mkdir binmkdir srcmkdir pkg</code></pre><h4 id="v1-11-以后"><a href="#v1-11-以后" class="headerlink" title="v1.11 以后"></a>v1.11 以后</h4><ol><li>设置环境变量 GO111MODULE 进行开启或者关闭 go modules 模式</li></ol><pre><code class="bash">go env -w GO111MODULE=on #go env -w会将配置写到 GOENV 文件中去</code></pre><blockquote><p>GO111MODULE 的枚举值:</p><ul><li>空： auto 自动模式，当项目根目录有 go.mod 文件，启用 Go modules</li><li>off： 关闭 go mod 模式</li><li>on： 开启 go mod 模式</li></ul></blockquote><h2 id="GOPATH-缺点"><a href="#GOPATH-缺点" class="headerlink" title="GOPATH 缺点"></a>GOPATH 缺点</h2><img src="/2022/10/01/01-golang-proxy/GOPATH.jfif" class="" title="GOPATH"><ol><li>GOPATH 模式下，必须指定目录,项目代码不能想放哪里就放哪里</li><li>go get 命令的时候，无法指定获取的版本</li><li>引用第三方项目的时候，无法处理 v1、v2、v3 等不同版本的引用问题，因为在 GOPATH 模式下项目路径都是 github.com&#x2F;foo&#x2F;project</li><li>无法同步一致第三方版本号，在运行 Go 应用程序的时候，无法保证其它人与所期望依赖的第三方库是相同的版本。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>背景：国内因为墙的原因，所以下载一些包的时候会产生 443 报错</p><img src="/2022/10/01/01-golang-proxy/go_443.jpg" class="" title="下载包报错"><p>解决方法：设置代理<br>常用代理：</p><ul><li>GOPROXY.IO：<a href="https://goproxy.io/zh/">https://goproxy.io/zh/</a></li><li>七牛云：<a href="https://goproxy.cn/">https://goproxy.cn</a></li><li>阿里云：<a href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a></li></ul><p>设置步骤：</p><pre><code class="bash">go env -w GOPROXY=https://goproxy.cn,direct</code></pre><img src="/2022/10/01/01-golang-proxy/go_success.jpg" class="" title="成功下载"><p><a href="https://proxy.golang.com/">https://proxy.golang.com</a> 设置为代理后拉包依旧失败原因：该地址在中国大陆已被屏蔽，所以不可用</p><pre><code class="bash">export GOPROXY=https://proxy.golang.com.cn,directexport GOPROXY=https://goproxy.io,direct</code></pre><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><img src="/2022/10/01/01-golang-proxy/go_env.webp" class="" title="环境变量含义"><p>引用包：(指明本地路径)</p><pre><code>go mod edit -replace example.com/greetings=../greetings</code></pre><blockquote><p>参考文章</p><ol><li><a href="https://segmentfault.com/a/1190000041720288">简单聊聊 GOPATH 与 Go Modules</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-error</title>
      <link href="/2022/09/23/linux-error/"/>
      <url>/2022/09/23/linux-error/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><blockquote><p>Failed to download metadata for repo ‘AppStream’ [CentOS8]</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>进入目录 <code>cd /etc/yum.repos.d/</code></li><li>执行以下命令：</li></ol><ul><li><code>sed -i &#39;s/mirrorlist/#mirrorlist/g&#39; /etc/yum.repos.d/CentOS-*</code></li><li><code>sed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-*</code></li></ul><ol start="3"><li>更新 <code>yum update -y</code></li></ol><h2 id="磁盘过满怎么处理"><a href="#磁盘过满怎么处理" class="headerlink" title="磁盘过满怎么处理"></a>磁盘过满怎么处理</h2><ol><li><code>docker volume prune -f</code></li><li><a href="https://blog.csdn.net/a854517900/article/details/80824966">https://blog.csdn.net/a854517900/article/details/80824966</a></li></ol><h2 id="Linux-修改环境变量失败"><a href="#Linux-修改环境变量失败" class="headerlink" title="Linux 修改环境变量失败"></a>Linux 修改环境变量失败</h2><ol><li>&#x2F;etc&#x2F;profile</li><li>&#x2F;root&#x2F;.bash_profile（推荐）</li><li><strong>_ 修改完之后重启机器，环境变量的修改才会真正生效_</strong></li></ol><h2 id="把-centos7-系统打包成-docker-镜像"><a href="#把-centos7-系统打包成-docker-镜像" class="headerlink" title="把 centos7 系统打包成 docker 镜像"></a>把 centos7 系统打包成 docker 镜像</h2><ol><li><p>安装 docker</p></li><li><p>切换到系统根目录，对当前文件进行压缩<br><code>tar -cvpf /tmp/system.tar --directory=/ --exclude=proc --exclude=sys --exclude=dev --exclude=run --exclude=boot . </code></p><blockquote><p>&#x2F;proc、&#x2F;sys、&#x2F;run、&#x2F;dev 这几个目录都是系统启动时自动生成的，虽然也属于文件系统一部分，但是他们每次开机都会有变化，所以打包的时候就应该忽略它们</p></blockquote></li><li><p>导入 docker<br><code>docker import /tmp/system.tar linux:10.1</code></p></li><li><p>登录并新建仓库 emailforcodeyy&#x2F;centos7_iam</p></li><li><p>将生成的镜像推送到 docker hub</p><pre><code class="bash">docker logindocker push emailforcodeyy/centos7_iam:v1.0.0</code></pre></li></ol><blockquote><p>参考链接:<a href="https://cloud.tencent.com/developer/article/1920079">https://cloud.tencent.com/developer/article/1920079</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>backTopAndBottom</title>
      <link href="/2022/09/23/backtopandbottom/"/>
      <url>/2022/09/23/backtopandbottom/</url>
      
        <content type="html"><![CDATA[<h2 id="缺陷链接"><a href="#缺陷链接" class="headerlink" title="缺陷链接"></a>缺陷链接</h2><p><a href="http://10.186.18.11/jira/browse/DMP-13892">http://10.186.18.11/jira/browse/DMP-13892</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>巡检报告页面、库表检查页面增加置顶、置底功能</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>两个页面都需要增加这个功能,那就做成一个组件,避免写重复代码</li><li>umc-ui项目中已经有这部分功能的实现,所以只需要整合一下相关的代码封装成组件</li><li>置顶功能在antd中已经实现,所以需要我们自己实现的只有置底功能</li><li>通过scrollInView方法实现</li></ol><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><pre><code class="React">import &#123;  VerticalAlignBottomOutlined,  VerticalAlignTopOutlined,&#125; from &#39;@ant-design/icons&#39;;import &#123; BackTop, Button &#125; from &#39;antd&#39;;import &#123; useEffect, useState &#125; from &#39;react&#39;;const BackTopAndBottom: React.FC&lt;&#123; contentRef: HTMLDivElement | null &#125;&gt; = (&#123;  contentRef,&#125;) =&gt; &#123;  const [toBottomButtonVisible, setToBottomButtonVisible] = useState(true);  const moveToBottom = () =&gt; &#123;    if (contentRef) &#123;      contentRef.scrollIntoView(&#123;        block: &#39;end&#39;,        behavior: &#39;smooth&#39;,      &#125;);    &#125;  &#125;;  useEffect(() =&gt; &#123;    const dom = document.querySelector(      &#39;#root main.ant-layout-content.action-content&#39;    );    const handleScrollChange = () =&gt; &#123;      const interval =        (dom?.scrollHeight ?? 0) -        (dom?.scrollTop ?? 0) -        (dom?.clientHeight ?? 0);      setToBottomButtonVisible(interval &gt; 80);    &#125;;    dom?.addEventListener(&#39;scroll&#39;, handleScrollChange);    return () =&gt; &#123;      dom?.removeEventListener(&#39;scroll&#39;, handleScrollChange);    &#125;;  &#125;, []);  return (    &lt;&gt;      &#123;toBottomButtonVisible &amp;&amp; (        &lt;Button          shape=&quot;circle&quot;          icon=&#123;&lt;VerticalAlignBottomOutlined /&gt;&#125;          onClick=&#123;moveToBottom&#125;          type=&quot;primary&quot;        /&gt;      )&#125;      &lt;BackTop        visibilityHeight=&#123;250&#125;        className=&quot;back-top&quot;        target=&#123;() =&gt; document.querySelector(&#39;.action-content&#39;) as HTMLElement&#125;      &gt;        &lt;Button          shape=&quot;circle&quot;          type=&quot;primary&quot;          icon=&#123;&lt;VerticalAlignTopOutlined /&gt;&#125;        &gt;&lt;/Button&gt;      &lt;/BackTop&gt;    &lt;/&gt;  );&#125;;export default BackTopAndBottom;</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>这个组件添加以后,在库表检查页面没有问题,但是在巡检报告页面,出现了下面的bug:</p><pre><code class="TypeScript">  contentRef.scrollIntoView(&#123;    block: &#39;end&#39;,    behavior: &#39;smooth&#39;,  &#125;);</code></pre><p>当behavior设置为smooth的时候点击置底按钮,预期是拉到页面底部,但是实际情况是停在了页面的第一张canvas图部分,并没有一直拉到页面底部;但是设置为auto以后,即取消动画,点击可以拉到页面底部。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>比较两个页面调用组件的父组件的代码，发现巡检报告页面监听了页面的滚动事件，而库表检查页面没有,于是注释了对应的代码，发现问题被解决了。</p><pre><code class="TypeScript">  let setScroll = true;  useLayoutEffect(() =&gt; &#123;    const content = document.querySelector&lt;HTMLElement&gt;(&#39;.action-content&#39;);    if (setScroll &amp;&amp; content) &#123;      setScroll = false;      // 此处是问题产生的原因，增加防抖可解决问题      content.addEventListener(&#39;scroll&#39;,scrollChange);      // 修改后       content.addEventListener(&#39;scroll&#39;,lodash.debounce(scrollChange,100));    &#125;    return () =&gt; &#123;      if (content) &#123;        content.removeEventListener(&#39;scroll&#39;, scrollChange);      &#125;    &#125;;  &#125;);  const scrollChange = () =&gt; &#123;    const ball = document.querySelector&lt;HTMLSpanElement&gt;(      &#39;.ant-anchor-ink-ball&#39;    );    if (ball) &#123;      const top = Number.parseInt(ball.style.top || &#39;&#39;);      const wrapper = document.querySelector&lt;HTMLDivElement&gt;(        &#39;.ant-anchor-wrapper&#39;      );      const height = wrapper ? wrapper.clientHeight : 0;      if (wrapper) &#123;        if (top &gt; height) &#123;          wrapper.scrollTop = top - height + 100;        &#125; else if (top &lt; wrapper.scrollTop) &#123;          wrapper.scrollTop = top - 100;        &#125;      &#125;    &#125;  &#125;;</code></pre><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>子组件和父组件都监听了action-content容器的滚动事件，并且有不同的回调函数，同时执行会导致冲突，最终滚动的高度没有达到预期。使用debounce防抖，延迟执行，可以消除这一问题</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>debounce 防抖<blockquote><ul><li>_.debounce(func, [wait&#x3D;0], [options&#x3D;])</li><li>在一段连续操作结束后，处理回调</li><li>创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法</li><li>如果 wait 为 0 并且 leading 为 false, func调用将被推迟到下一个点，类似setTimeout为0的超时</li></ul></blockquote></li><li>throttle 节流<blockquote><ul><li>_.throttle(func, [wait&#x3D;0], [options&#x3D;])</li><li>创建一个节流函数，在 wait 秒内最多执行 func 一次的函数</li><li>在一段连续操作中，每一段时间只执行一次</li></ul></blockquote></li><li>原生JS实现</li></ul><pre><code class="TypeScript">//防抖 debouncefunction debounce(fn, delay) &#123;    var timer; // 维护一个 timer    return function () &#123;        var _this = this; // 取debounce执行作用域的this        var args = arguments;        if (timer) &#123;            clearTimeout(timer);        &#125;        timer = setTimeout(function () &#123;            fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);        &#125;, delay);    &#125;;&#125;//节流 throttlefunction throttle(fn, delay) &#123;    var timer;    return function () &#123;        var _this = this;        var args = arguments;        if (timer) &#123;            return;        &#125;        timer = setTimeout(function () &#123;            fn.apply(_this, args);            timer = null; // 在delay后执行完fn之后清空timer，此时timer为假，throttle触发可以进入计时器        &#125;, delay)    &#125;&#125;</code></pre><h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><ol><li><a href="https://juejin.cn/post/6844903669389885453">https://juejin.cn/post/6844903669389885453</a></li><li><a href="https://segmentfault.com/a/1190000018445196">https://segmentfault.com/a/1190000018445196</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 置顶功能实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】The Evolution of the Modern Web Application Development</title>
      <link href="/2022/09/19/web-ying-yong-kai-fa-de-yan-bian/"/>
      <url>/2022/09/19/web-ying-yong-kai-fa-de-yan-bian/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本文原文链接：<a href="https://blog.bitsrc.io/the-evolution-of-the-modern-web-application-development-18aa95b7c1a">https://blog.bitsrc.io/the-evolution-of-the-modern-web-application-development-18aa95b7c1a</a></p></blockquote><h2 id="现代web应用开发的进化"><a href="#现代web应用开发的进化" class="headerlink" title="现代web应用开发的进化"></a>现代web应用开发的进化</h2><h3 id="那时候开发人员的工作和现在大不相同"><a href="#那时候开发人员的工作和现在大不相同" class="headerlink" title="那时候开发人员的工作和现在大不相同"></a>那时候开发人员的工作和现在大不相同</h3><p><img src="https://cdn-images-1.medium.com/max/8208/1*47wUIbkat0g69vKjxm-rOg.jpeg" alt="人类进化"></p><p>你可能会非常好奇: 什么样的开发者会写出像这样的文章?</p><p>那么我可以回答这个问题: <em>一个老程序员</em>.</p><p><img src="https://cdn-images-1.medium.com/max/2416/1*cH7VoyCKrOykiUr5wDr0KA.png" alt="推特给了我写这篇文章的灵感(这让我觉得自己老的要命)"></p><p>不开玩笑了,我不年轻了,且到目前为止已经在 IT 行业工作了20年. 好处就是当我年纪大到可以写这篇文章的时候，我还很年轻，我仍然记得我们过去的工作有哪些不同。所以，我接受了我在同一时间可以既年轻又年迈。</p><p>也就是说, “以前” 我们常常使用不同的工具、模式、heck甚至标准工作，那时候兼容 IE 还不是一个笑话, 事实上, 兼容所有主流浏览器也不容易。</p><p>让我们沿着记忆的小路慢慢前行,慢慢回忆过去的情形,这样我们可以更好的理解现在使用的工具。</p><h2 id="Netlify-Vercel-AWS-这是什么"><a href="#Netlify-Vercel-AWS-这是什么" class="headerlink" title="Netlify? Vercel? AWS? 这是什么?"></a>Netlify? Vercel? AWS? 这是什么?</h2><p>当我20年前入行的时候，把平台甚至软件作为一个 Service 这件事还不存在。</p><p>那时候开发软件有多不同呢? 事实上,  “API Everything” 思想那时候还没有真正实现。 启动并运行一个 Service 需要大量精力和金钱，所以除非有必要的理由，否则没有人会去做。</p><p>除此之外, 我们过去使用的工具也不一样, Node.js 还没出现, 所以想使用像 Next.js 这样的框架也是不可能的。我一开始使用 PHP 4, 它和现在的 Node.js(或其他工具) 不一样，不能创建你自己的 web 服务器。相反, 我们必须安装 <a href="https://httpd.apache.org/">Apache Web Server</a>,或者如果你是一个冒险者,并且想拥有一个基于 Windows 的 web 服务器, Internet Information Service(IIS) 也可以, 它曾经是(或许现在也是？) Microsoft 提供的一个选择(这在过去并不理想)。</p><p>关于这种工作方式很有趣的一点是：你的应用是一系列的脚本，它们会在每次服务器接收到一个请求的时候被执行。 这意味着你的服务器上没有运行中的 app。 每一个新的请求最终都会变成一个新的进程，运行在服务器内部。这意味着服务器必须足够强大，能够处理很多请求，因为每个请求都是一个并行进程，会占用一块内存和 CPU 时间。</p><p>当然, 数据库连接 (和其他的服务) 也必须在脚本的生命周期内被建立和关闭(比如在请求期间)。</p><p>如果你想要扩容, “自动扩容”是不可能的。我还记得特定节假日必须评估运行电商网站需要的服务器数量是多么痛苦。 当然, 总是有不足之处，以至于开发者们周末期间不得不进行紧急修复处理(比如重新启动挂掉的数据库,或者清理大到充满整个硬盘的日志文件)。</p><h3 id="前端技术栈比现在更简单"><a href="#前端技术栈比现在更简单" class="headerlink" title="前端技术栈比现在更简单"></a>前端技术栈比现在更简单</h3><p>因为下面的一些原因，那时候的前端场景非常不同：</p><ol><li><p>我认为最重要的一点是那时候的 HTML, CSS 和 JavaScript 还没有现在这么标准化。 尤其是后者, 每个浏览器都遵循自己的指导方针实现了各自的版本, 并没有考虑到其他的浏览器. 它更像一场比赛而不是合作。所以 Chrome 有的功能在   Firefox 或者 IE 中可能并不可用，反之亦然。 这意味着构建任何人都能使用的 Web 应用，就必须增加许多代码处理这些差异。</p></li><li><p>那时候也没有 UI 框架, 只有各种库. 对我来说, 这个区别非常重要, 因为现在像 React 和 Vue 这样的框架提供了一个体系架构，定义了一系列你可以遵循的工具和模式。如果你基于他们去构建，就像 Next, Nuxt 和 其他一些应用做的那样，那么他们就为你提供了一条可遵循的路径。过去我们有 jQuery,<a href="https://underscorejs.org/">underscore</a>(之后几乎被<a href="https://lodash.com/">lodash</a>取代)，以及 <a href="https://mootools.net/">Mootools</a>。这些都是很好的库，但是没有真正强制推行一种工作方式，这导致人们认为前端开发不需要使用任何先进的开发方法和技术。我记得我曾经认为 JavaScript 就是增加表单验证,不然就是为静态网站添加一些愚蠢的动画。</p></li></ol><p>你必须记住, “过去那时候”, 我们甚至不能异步加载数据。直到术语 AJAX 流行起来，才发现了这种能力 (并且开始学习异步行为的概念)。这些在现在看来很普通的事情对于当时来说是工作模式的转变。</p><h3 id="现在它容易多了"><a href="#现在它容易多了" class="headerlink" title="现在它容易多了"></a>现在它容易多了</h3><p>现在开发一个应用简单多了,非常方便,不会让我担心。</p><p>你可以把你的 Github 账号和一个 Netlify (或者类似的平台) 账号连接起来，在世界的<em>某个地方</em>自动部署应用。Heck 你可以利用类似 Supabase, 或者 AWS DynamoDB 的服务，在这里你都不用担心维护数据库或者认证服务。</p><p>甚至一些服务会集中控制你的日志文件, 像 <a href="https://www.loggly.com/">Loggly</a> 和 <a href="https://www.splunk.com/">Splunk</a>, 所以如果你的日志轮换配置不是最优的话，也不需要担心硬盘空间被全部占用。</p><p>那时候独立工作是很困难的，但是现在你可以真正地接近独立工作(如果你愿意为此付出报酬的话)。</p><h3 id="前端技术栈变得更有难度了，但是这是一件好事"><a href="#前端技术栈变得更有难度了，但是这是一件好事" class="headerlink" title="前端技术栈变得更有难度了，但是这是一件好事"></a>前端技术栈变得更有难度了，但是这是一件好事</h3><p>前端生态系统现在很大，React、Vue、Svelte 甚至是 Angular,他们启发了许多框架的诞生，这些框架让前端更上一层楼。</p><p>我这么说吧,过去当我开始工作的时候,web 开发的座右铭常常是 “瘦客户端,胖服务端”或者是“让你的客户端变傻”又或者是这些思想的变体。本质上来说,你的客户端代码只是简单的表示层，不应该在上面做任何“困难”的事情，因为浏览器还没有做好准备。相反，我们将“复杂的”逻辑维护在后端，只使用 JavaScript 显示漂亮的颜色和一些警告框。</p><p>从那时起，我们已经走过了一条漫长的路。当然,这些不是没有代价的。过去我们的“bundler”是一系列的脚本标签，添加在 HTML 顶部，并且这就是所有了。</p><p>现在驱动一个现代 app 的 JS 数量已经增长了如此之多，用于优化它的工具生态系统也随之增长。</p><p>现在你需要：</p><ol><li><p>如果你使用的不是纯 JavaScript 的话，就需要一个转译器。</p></li><li><p>打包工具把所有的代码放在一起，移除不必要的部分,以一种对用户来说低“开销”的方式传输和发布。</p></li><li><p>lint程序，确保10万行JS代码中的每一行都遵循团队中相同的标准。</p></li><li><p>一个拥有热更新和文件监听功能的 webserver,优化开发体验。否则修改单独一行代码也会花费大量时间去更新。</p></li><li><p>一个包管理器, 因为作为开发者，我们已经完成了重复造轮子的工作。</p></li><li><p>一个版本控制系统 (通常是 Git + Github 但是也有其他一些选择) 确保团队成员可以很容易就同一个项目合作。</p></li><li><p>一个测试运行器,因为现在你的前端业务逻辑已经如此复杂（顺便说一下也很伟大），以至于需要一个方法确保所有的事情都和预期一样运行。</p></li></ol><p>我打赌你可能会想到更多。这对刚起步的人来说可能会有一点不知所措。</p><p>我知道这是我在多年不编程后重新上马的原因。<br>I know it was for me when getting back on the horse after years of not coding.</p><p>值得庆幸的是，行业仍然在进化。虽然它们仍然是新的，并试图进入，但人们正在开发专门用于再次简化技术栈的工具，同时保留当今复杂解决方案的功能和能力。</p><h3 id="web-开发工具生态系统的未来"><a href="#web-开发工具生态系统的未来" class="headerlink" title="web 开发工具生态系统的未来"></a>web 开发工具生态系统的未来</h3><p>旅程还未结束，这是好事情。</p><p>如果你仔细思考这件事情，我们在代码中也是这么做的：</p><ol><li><p>我们针对一个问题写了简单的解决方法。</p></li><li><p>我们意识到这个解决方法并没有覆盖所有潜在的边际案例，所以需要在此基础上添加更多代码，直到它能够正常工作。</p></li><li><p>我们意识到它是一个可恶的 Frankenstein 类型的代码，不可维护并且难以理解，所以我们开始重构和简化。</p></li></ol><p>我们的工具链正在经历同样的过程。我们现在开始看到步骤 #3。我们看到像来自<a href="https://bit.dev/">bit.dev</a>的<a href="https://bit.dev/">Bit</a> 这样的工具正在尝试集中化管理开发周期中的所有任务。</p><p>事实上, 使用 Bit, 你可以管理代码的版本并且测试代码, 并且作为个人包发布。你甚至可以用它管理一个 Monorepo 而不需要担心其他工具。</p><p>当然，这也不是说工具会为你做完所有的事情，事实上，他只是管理了整个你通常会需要担心的工具生态系统。如果你问我，我会觉得这是个聪明的做法。</p><p>另外, 类似打包工具这样的工具开始见证一个不再需要他们的趋势。听我说, 我在主持的 <a href="https://podcast.20minjs.com/">20MinJS podcast</a> 节目中采访了 <a href="https://twitter.com/MicheleRivaCode">Michele Riva</a>(他是来自 Nearform 的高级软件架构师),在那一集中,Michele 提及了 <a href="https://vitejs.dev/">Vite</a> 这样的新一代打包工具是如何利用浏览器的新能力：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">ECMA Script import 语句</a>,异步加载文件,因此提升了 JavaScript 的加载速度(而不是必须加载一个或多个大的被打包的文件)。</p><p>所以如果你问我的话，未来看上去是非常光明的。仍然有许多工作要做，但是担忧必须为应用手动设置平台的日子已经一去不返了。工具生态系统正在进化至一个点：我们可以快速制作原型和部署想法,然后将它们发展成成熟的应用程序，而无需改变太多，只需要改变我们使用的服务或我们支付的层。如果我们想要扩容，因为它们最终获得了成功，只要我们准备好为它付费，我们也可以获得。</p><p>我认为 web 开发行业的当前状态的魅力在于我们拥有选择的权利。</p><p>我们仍然可以使用“old school 方式”手动去做每一件事情，管理我们自己的服务器,规划应用所需的流量和工作量，并增加对应的基础设施。</p><p>或者如果愿意信任已经试用并且经过测试的外部平台和服务，我们可以支付他们报酬为我们工作。我们从本质上用服务替代了原本必须成熟的 IT 团队，这对一些公司来说是一个很好的引导策略。是的，最终你会需要 IT 团队和你一起工作，这是不可否认的，但是没有 IT 团队，您可以比以前走得更远。</p><p>除此之外,工具本身也会成长和适应社区的反馈。<strong>Developer Experience</strong> 是一个会在日常工具设计中频繁抛出的术语，并且我们可以从使用这些工具的简单程度中看出这一点。我认为这是非常聪明的一步，它将进一步推动开发速度和能力。</p><p>你认为呢? 从你的角度来看，未来是光明的吗?</p><h2 id="可组合-像乐高一样更快地构建应用"><a href="#可组合-像乐高一样更快地构建应用" class="headerlink" title="可组合: 像乐高一样更快地构建应用"></a>可组合: 像乐高一样更快地构建应用</h2><p><img src="https://cdn-images-1.medium.com/max/2400/1*x2l8LRH1nbC1FQZUdt50RQ.jpeg"></p><p><a href="https://bit.cloud/">Bit</a> 是一个以模块化和协作方式构建 app 的开源工具。通过可组合的方式更快,更一致并且更容易扩容。</p><p>→ <a href="https://bit.dev/">了解更多</a></p><p>构建应用,页面,用户体验和 UI 作为独立的组件。使用它们更快地组成新的应用和体验。将任意框架和工具引进你的工作流程中。共享、复用和协作以一起构建应用。</p><p>帮助你的团队了解:</p><p><strong>→ <a href="https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc">Micro-Frontends</a></strong></p><p><strong>→ <a href="https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833">Design Systems</a></strong></p><p><strong>→ <a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4">Code-Sharing and reuse</a></strong></p><p><strong>→ <a href="https://www.youtube.com/watch?v=5wxyDLXRho4&t=2041s">Monorepos</a></strong></p><h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><p><a href="https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc"><strong>How We Build Micro Frontends</strong></a><br><a href="https://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833"><strong>How we Build a Component Design System</strong></a><br><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg"><strong>How to reuse React components across your projects</strong></a><br><a href="https://blog.bitsrc.io/5-ways-to-build-a-react-monorepo-a294b6c5b0ac"><strong>5 Ways to Build a React Monorepo</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-deploy-github-443</title>
      <link href="/2022/09/14/hexo-deploy-github-443/"/>
      <url>/2022/09/14/hexo-deploy-github-443/</url>
      
        <content type="html"><![CDATA[<blockquote><p>18 files changed, 191 insertions(+), 191 deletions(-)<br>ERROR: Repository not found.<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a><br>error Command failed with exit code 2.<br>info Visit <a href="https://yarnpkg.com/en/docs/cli/run">https://yarnpkg.com/en/docs/cli/run</a> for documentation about this command.<br>问题:使用了https<br>解决方法:<br>修改.config.yml文件,使用ssh</p></blockquote><pre><code class="yml">deploy:  type: &#39;git&#39;  repo:    github: git@github.com:earthaYan/earthaYan.github.io.git  branch: master</code></pre><p>对比图:</p><img src="/2022/09/14/hexo-deploy-github-443/diff.jpg" class="" title="对比">]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于antv/g2的缺陷修复</title>
      <link href="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/"/>
      <url>/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="缺陷链接"><a href="#缺陷链接" class="headerlink" title="缺陷链接"></a>缺陷链接</h2><p><a href="http://10.186.18.11/jira/browse/DMP-13821">http://10.186.18.11/jira/browse/DMP-13821</a></p><h2 id="问题复现和解决链接"><a href="#问题复现和解决链接" class="headerlink" title="问题复现和解决链接"></a>问题复现和解决链接</h2><p><a href="https://codesandbox.io/s/tu-biao-xiu-fu-forked-1rqvwe?file=/src/index.data.ts">https://codesandbox.io/s/tu-biao-xiu-fu-forked-1rqvwe?file=/src/index.data.ts</a></p><h2 id="问题复现截图"><a href="#问题复现截图" class="headerlink" title="问题复现截图"></a>问题复现截图</h2><img src="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/error.png" class="" title="测试提供截图"><h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><ol><li>通过查看接口返回，发现接口返回数据是符合要求的，那么问题就是出在前端了</li><li>查看相关代码，发现是使用antv&#x2F;g2的Chart实现的</li><li>思考可能是传入数据的原因导致的：type轴值重复了</li><li>有两种修复方法：<br>a. data里新增属性id，由type+device<br>b. 修改对应的type值，使它唯一，然后再通过formatter选项设置type轴的显示</li><li>尝试了方法a，发现BarChart这个组件在多个父组件中被调用，如果使用该方案需要修改所有的父组件的data，所以最终选择方案2</li></ol><h2 id="修复前后代码对比"><a href="#修复前后代码对比" class="headerlink" title="修复前后代码对比"></a>修复前后代码对比</h2><img src="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/%E4%BF%AE%E5%A4%8D1.jpg" class="" title="BarChart组件"><img src="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/%E4%BF%AE%E5%A4%8D2.jpg" class="" title="调用BarChart的父组件"><h3 id="使用antv-x2F-g2实现一个条形图的过程"><a href="#使用antv-x2F-g2实现一个条形图的过程" class="headerlink" title="使用antv&#x2F;g2实现一个条形图的过程"></a>使用antv&#x2F;g2实现一个条形图的过程</h3><pre><code class="TypeScript">  // 初始化图表  const initChart = () =&gt; &#123;    chart.current = new Chart(&#123;      container: `$&#123;titleKey&#125;_chart`,      autoFit: true,      height: 295,      padding: [30, 50, 30, 200],    &#125;);  &#125;;</code></pre><pre><code class="TypeScript">  // 绘制图表  const drawChart = (data: IChartData[]) =&gt; &#123;    chart.current?.data(data);    chart.current?.axis(&#39;type&#39;, &#123;      label: &#123;        autoEllipsis: true,        style: &#123;          fill: currentThemeData.chart.linkColor,          textAlign: &#39;left&#39;,          fontSize: 14,        &#125;,        offsetX: -180,        formatter: (val) =&gt; getIp(val),      &#125;,      tickLine: null,      line: null,      verticalLimitLength: 180,    &#125;);    chart.current?.axis(&#39;value&#39;, &#123;      grid: null,      label: null,    &#125;);    chart.current?.tooltip(false);    chart.current?.legend(false);    chart.current?.coordinate(&#39;rect&#39;).transpose();    if (percent) &#123;      chart.current        ?.interval()        .adjust(&#39;stack&#39;)        .position(&#39;type*value&#39;)        .color(&#39;barType*value&#39;, (barType: string, value: string[]) =&gt; &#123;          if (barType === barTypeEnum.background) &#123;            return &#39;#ebedf0&#39;;          &#125; else &#123;            return getTypeColor(Number(value[1]));          &#125;        &#125;)        .size(15)        .label(&#39;showValue*barType&#39;, (val, barType) =&gt; &#123;          if (barType === barTypeEnum.background) &#123;            return null;          &#125;          if (titleKey === &#39;disk_top10&#39;) &#123;            return &#123;              content: (data) =&gt; &#123;                let deviceStr = data.device;                if (deviceStr.length &gt; 20) &#123;                  deviceStr = data.device.substr(0, 20) + &#39;...&#39;;                &#125;                return `$&#123;Number(val) &gt; 20 ? val : &#39;&lt;20&#39;&#125;% $&#123;deviceStr ?? &#39;&#39;&#125;`;              &#125;,              offset: Number(val) &lt; 20 ? 2 : 10,              position: &#39;left&#39;,              style: &#123;                fill: &#39;#000&#39;,              &#125;,            &#125;;          &#125;          return &#123;            content: val + &#39;%&#39;,            style: &#123;              fill: Number(val) &lt; 20 ? &#39;#000&#39; : &#39;#fff&#39;,            &#125;,            position: &#39;left&#39;,          &#125;;        &#125;);    &#125; else &#123;      chart.current        ?.interval()        .position(&#39;type*value&#39;)        .size(15)        .color(barColor)        .label(&#39;value&#39;, &#123;          style: &#123;            fill: currentThemeData.chart.guideColor,          &#125;,          offset: 20,        &#125;);    &#125;  &#125;;</code></pre><pre><code class="TypeScript">  // 渲染图表  React.useEffect(() =&gt; &#123;    initChart();    chart.current?.on(&#39;axis-label:click&#39;, jumpAction);    return () =&gt; &#123;      chart.current?.off(&#39;axis-label:click&#39;, jumpAction);    &#125;;  &#125;, []);  React.useEffect(() =&gt; &#123;    if (data?.length) &#123;      drawChart(data);      chart.current?.render();    &#125;    chart.current?.render(true);  &#125;, [data, currentThemeData]);</code></pre><pre><code class="TypeScript">  // 监听重绘  React.useEffect(() =&gt; &#123;    const MutationObserver = window.MutationObserver;    let observer: MutationObserver;    const e = document.getElementById(`$&#123;titleKey&#125;`);    if (e) &#123;      observer = new MutationObserver(() =&gt; &#123;        chart.current?.forceFit();        chart.current?.render(true);        chart.current?.changeSize(e.scrollWidth, e.scrollHeight - 30);      &#125;);      observer.observe(e, &#123;        attributes: true,        attributeFilter: [&#39;style&#39;],        attributeOldValue: true,      &#125;);    &#125;    return () =&gt; &#123;      if (observer) &#123;        observer.disconnect();      &#125;    &#125;;  &#125;, []); </code></pre><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>修复前getIp返回的是xxx.target,但是修复后只能通过xx.type去获取,原因不明</p><h3 id="修复后使用target"><a href="#修复后使用target" class="headerlink" title="修复后使用target"></a>修复后使用target</h3><img src="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/%E4%BF%AE%E5%A4%8D%E5%90%8Etarget.jpg" class="" title="修复后使用target"><p>效果如下:</p><img src="/2022/09/14/guan-yu-antv-g2-de-que-xian-xiu-fu/result.jpg" class="" title="修复后使用target效果图">]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript学习笔记</title>
      <link href="/2022/08/31/typescript-xue-xi-bi-ji/"/>
      <url>/2022/08/31/typescript-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript类型来源："><a href="#TypeScript类型来源：" class="headerlink" title="TypeScript类型来源："></a>TypeScript类型来源：</h2><ul><li><p>通过赋的值自动进行类型推论</p></li><li><p>通过 <code>interface</code> 和 <code>type</code> 定义类型</p><blockquote><p>JS自带的基础类型：<br><code>boolean, bigint, null, number, string, symbol,undefined</code></p></blockquote></li><li><p>多个简单类型组合成复杂的类型</p><ul><li>Unions：联合类型</li></ul><img src="/2022/08/31/typescript-xue-xi-bi-ji/typeof.jpg" class="" title="typeof 结果"><pre><code class="TypeScript">type WindowStates = &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;function wrapInArray(obj: string | string[]) &#123;  if (typeof obj === &quot;string&quot;) &#123;    return [obj];  &#125;  return obj;&#125; </code></pre><ul><li>Generics：泛型</li></ul></li></ul><pre><code class="TypeScript">type StringArray = Array&lt;string&gt;;interface Backpack&lt;Type&gt; &#123;  add: (obj: Type) =&gt; void;  get: () =&gt; Type;&#125;// 告诉TypeScript 有一个常量叫做 `backpack` declare const backpack: Backpack&lt;string&gt;;// object 是一个字符串类型, 因为在上面声明了Backpack的变量const object = backpack.get();//由于backpack 变量是一个字符串, 不能传一个number给add方法backpack.add(23);//报错：Argument of type &#39;number&#39; is not assignable to parameter of type &#39;string&#39;.</code></pre><h2 id="TypeScript的鸭子类型-structural-typing"><a href="#TypeScript的鸭子类型-structural-typing" class="headerlink" title="TypeScript的鸭子类型(structural typing)"></a>TypeScript的鸭子类型(structural typing)</h2><p><strong>定义</strong>：如果两个对象有一样的shape,他们就会被认为是一样的类型</p><pre><code class="TypeScript">interface Point &#123;  x: number;  y: number;&#125;function logPoint(p: Point) &#123;  console.log(`$&#123;p.x&#125;, $&#123;p.y&#125;`);&#125;// logs &quot;12, 26&quot;const point = &#123; x: 12, y: 26 &#125;;logPoint(point);</code></pre><p>如上述代码所示：变量point从来没有被声明为Point类型。但是TypeScript在类型检查中比较了Point和point的shape,完全一致，所以代码不会报错</p><p><strong>注意</strong>:shape-matching 匹配对象字段的一个子集。</p><pre><code class="TypeScript">interface Point &#123;  x: number;  y: number;&#125;function logPoint(p: Point) &#123;  console.log(`$&#123;p.x&#125;, $&#123;p.y&#125;`);&#125;const point3 = &#123; x: 12, y: 26, z: 89 &#125;;logPoint(point3); // logs &quot;12, 26&quot;const color = &#123;  x: 33,hex: &quot;#187ABF&quot; &#125;;logPoint(color);//此处报错，因为缺少缺少y</code></pre><h2 id="TypeScript的额外功能"><a href="#TypeScript的额外功能" class="headerlink" title="TypeScript的额外功能"></a>TypeScript的额外功能</h2><ul><li>输入的时候提供错误消息</li><li>代码补全功能</li><li>通过重构来轻松地重新组织代码</li><li>通过导航功能来跳转到变量的定义</li><li>查找给定变量的所有引用</li></ul><h2 id="TypeScript编译器——tsc"><a href="#TypeScript编译器——tsc" class="headerlink" title="TypeScript编译器——tsc"></a>TypeScript编译器——tsc</h2><pre><code class="bash">npm install -g typescripttsc hello.tstsc --noEmitOnError hello.ts //报错时不生成输出文件</code></pre><h2 id="tsconfig-json配置文件"><a href="#tsconfig-json配置文件" class="headerlink" title="tsconfig.json配置文件"></a>tsconfig.json配置文件</h2><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;lib&quot;: [&quot;dom&quot;,&quot;dom.iterable&quot;,&quot;esnext&quot;],    &quot;allowJs&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;strict&quot;: true,    &quot;forceConsistentCasingInFileNames&quot;: true,    &quot;noFallthroughCasesInSwitch&quot;: true,    &quot;module&quot;: &quot;esnext&quot;,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;resolveJsonModule&quot;: true,    &quot;isolatedModules&quot;: true,    &quot;noEmit&quot;: true,    &quot;jsx&quot;: &quot;react-jsx&quot;,    &quot;experimentalDecorators&quot;: true,    &quot;downlevelIteration&quot;:true  &#125;,  &quot;include&quot;: [    &quot;src&quot;,  ]&#125; </code></pre><h2 id="日常类型"><a href="#日常类型" class="headerlink" title="日常类型"></a>日常类型</h2><ul><li>原始类型：<ul><li>boolean</li><li>number</li><li>string</li><li>bigint</li><li>symbol</li></ul></li><li>Array<ul><li>Array&lt;T&gt;</li><li>T[]</li></ul></li><li>any:<ul><li>任意类型，不推荐使用</li><li>在tsconfig.json中设置{“noImplicitAny”: true}可使得它报错</li></ul></li><li>Function<ul><li>需要指定 入参类型，返回值类型</li><li>匿名函数:当一个函数出现在TypeScript可以决定如何调用它的地方时，该函数的参数会自动指定类型，不需要指定入参和返回值</li></ul></li><li>对象类型<ul><li>可选属性,<code>name?:string</code></li></ul></li><li>联合类型unions<ul><li>类型1|类型2|类型3</li><li>类型别名 <code>type UserInputSanitizedString = string;</code></li></ul></li></ul><h2 id="interface和type的区别"><a href="#interface和type的区别" class="headerlink" title="interface和type的区别"></a>interface和type的区别</h2><ul><li>type创建类型后不能被修改添加新的属性<img src="/2022/08/31/typescript-xue-xi-bi-ji/interface.jpg" class="" title="interface"><img src="/2022/08/31/typescript-xue-xi-bi-ji/error.jpg" class="" title="error"></li></ul><p>上图中左边等价于：</p><pre><code class="TypeScript">interface Window&#123;  title:string;  ts:TypeScriptAPI&#125;</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><ol><li>使用as关键字</li></ol><pre><code class="TypeScript">const myCanvas = document.getElementById(&quot;main_canvas&quot;) as HTMLCanvasElement;</code></pre><ol start="2"><li>使用尖角括号 —— 代码在.tsx文件中</li></ol><pre><code class="TypeScript">const myCanvas = &lt;HTMLCanvasElement&gt;document.getElementById(&quot;main_canvas&quot;);</code></pre><ol start="3"><li>类型转换使用 as any&#x2F;unknown as</li></ol><pre><code class="TypeScript">const expr=2type T = &#123; a: 1; b: 2; c: 3 &#125;;// ---cut---const a = (expr) as unknown as T;</code></pre><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><ol><li>如果是let,var定义的变量，他会被认为是基础类型-类型推论</li><li>如果是const 定义的常量，它的类型就是常量值，不可修改</li><li>如果const 字面量类型推论不符合预期，可通过以下方法解决</li></ol><pre><code class="TypeScript">// Change 1:const req = &#123; url: &quot;https://example.com&quot;, method: &quot;GET&quot; as &quot;GET&quot; &#125;;// change 2:const req = &#123; url: &quot;https://example.com&quot;, method: &quot;GET&quot; &#125; as const;handleRequest(req.url, req.method);</code></pre><h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><ul><li>Null：不存在，空对象</li><li>undefined：没有初始化</li><li>非null的断言操作：使用后缀!（知道类型不可能为null或者undefined）</li></ul><pre><code class="TypeScript">function liveDangerously(x?: number | null) &#123;  //不报错  console.log(x!.toFixed());&#125;</code></pre><h2 id="缩小"><a href="#缩小" class="headerlink" title="缩小"></a>缩小</h2><h3 id="类型保护-typeof"><a href="#类型保护-typeof" class="headerlink" title="类型保护 typeof"></a>类型保护 typeof</h3><p><code>typeof null ==== &#39;object&#39;，typeof undefined===&#39;undefined&#39;</code></p><h3 id="if检查"><a href="#if检查" class="headerlink" title="if检查"></a>if检查</h3><pre><code class="TypeScript">function padLeft(padding: number | string, input: string) &#123;  if (typeof padding === &quot;number&quot;) &#123;    return &quot; &quot;.repeat(padding) + input;//此时padding类型只有number  &#125;  return padding + input;//此时padding类型只有string&#125;</code></pre><h3 id="Truthiness检查："><a href="#Truthiness检查：" class="headerlink" title="Truthiness检查："></a>Truthiness检查：</h3><ul><li><code>&amp;&amp;</code>,<code>||</code>,<code>!</code>,if语句</li><li><font color="red">0,NaN,”” (the empty string),0n (the bigint version of zero),null,undefined</font>转换为布尔值都是false</li></ul><h3 id="使用-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D"><a href="#使用-x3D-x3D-x3D-x3D-x3D-x3D-x3D-x3D" class="headerlink" title="使用&#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;,  !&#x3D;"></a>使用&#x3D;&#x3D;&#x3D;, !&#x3D;&#x3D;, &#x3D;&#x3D;,  !&#x3D;</h3><pre><code class="TypeScript">function example(x: string | number, y: string | boolean) &#123;  if (x === y) &#123;    x.toUpperCase();    y.toLowerCase();  &#125; else &#123;    console.log(x);    console.log(y);  &#125;&#125;</code></pre><h3 id="in操作符：判断对象中是否有指定的属性"><a href="#in操作符：判断对象中是否有指定的属性" class="headerlink" title="in操作符：判断对象中是否有指定的属性"></a>in操作符：判断对象中是否有指定的属性</h3><pre><code class="TypeScript">type Fish = &#123; swim: () =&gt; void &#125;;type Bird = &#123; fly: () =&gt; void &#125;;type Human = &#123; swim?: () =&gt; void; fly?: () =&gt; void &#125;;function move(animal: Fish | Bird | Human) &#123;  if (&quot;swim&quot; in animal) &#123;    animal;//Fish|Human  &#125; else &#123;    animal;//bird/human  &#125;&#125;</code></pre><img src="/2022/08/31/typescript-xue-xi-bi-ji/in.jpg" class="" title="in操作符"><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>x instanceof Foo :检测 x的原型链 是否包含 Foo.prototype</p><h3 id="控制流分析（类型推断）"><a href="#控制流分析（类型推断）" class="headerlink" title="控制流分析（类型推断）"></a>控制流分析（类型推断）</h3><h3 id="类型判断：parameterName-is-Type"><a href="#类型判断：parameterName-is-Type" class="headerlink" title="类型判断：parameterName is Type"></a>类型判断：parameterName is Type</h3><pre><code class="TypeScript">type Fish = &#123; swim: () =&gt; void &#125;;type Bird = &#123; fly: () =&gt; void &#125;;declare function getSmallPet(): Fish | Bird;function isFish(pet: Fish | Bird): pet is Fish &#123;  return (pet as Fish).swim !== undefined;&#125;let pet = getSmallPet();if (isFish(pet)) &#123;  pet.swim();&#125; else &#123;  pet.fly();&#125;</code></pre><h3 id="可区分联合类型"><a href="#可区分联合类型" class="headerlink" title="可区分联合类型"></a>可区分联合类型</h3><pre><code class="TypeScript">interface Circle &#123;  kind: &quot;circle&quot;;  radius: number;&#125;interface Square &#123;  kind: &quot;square&quot;;  sideLength: number;&#125;type Shape = Circle | Square;function getArea(shape: Shape) &#123;  switch (shape.kind) &#123;    case &quot;circle&quot;:      return Math.PI * shape.radius ** 2;    case &quot;square&quot;:      return shape.sideLength ** 2;  &#125;&#125;</code></pre><hr><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="调用签名"><a href="#调用签名" class="headerlink" title="调用签名"></a>调用签名</h3><p>原因：解决无法在函数类型表达式声明其他属性<br>写法：</p><pre><code class="TypeScript">type DescribableFunction = &#123;  description: string;  (someArg: number): boolean;&#125;;function doSomething(fn: DescribableFunction) &#123;  console.log(fn.description + &quot; returned &quot; + fn(6));&#125;</code></pre><h3 id="构造函数签名"><a href="#构造函数签名" class="headerlink" title="构造函数签名"></a>构造函数签名</h3><pre><code class="TypeScript">type SomeConstructor = &#123;  new (s: string): SomeObject;&#125;;function fn(ctor: SomeConstructor) &#123;  return new ctor(&quot;hello&quot;);&#125;</code></pre><h3 id="Function的泛型"><a href="#Function的泛型" class="headerlink" title="Function的泛型"></a>Function的泛型</h3><p>原因：处理函数输入和输出有关联的情况或者两个函数输入有某种关联关系</p><pre><code class="TypeScript">function map&lt;Input, Output&gt;(arr: Input[], func: (arg: Input) =&gt; Output): Output[] &#123;  return arr.map(func);&#125;// Parameter &#39;n&#39; is of type &#39;string&#39;// &#39;parsed&#39; is of type &#39;number[]&#39;const parsed = map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) =&gt; parseInt(n));</code></pre><h3 id="泛型的约束"><a href="#泛型的约束" class="headerlink" title="泛型的约束"></a>泛型的约束</h3><ul><li>使用extends</li></ul><pre><code class="TypeScript">function minimumLength&lt;Type extends &#123; length: number &#125;&gt;(  obj: Type,  minimum: number): Type &#123;  if (obj.length &gt;= minimum) &#123;    return obj;  &#125; else &#123;    return &#123; length: minimum &#125;;//报错，原因是不能返回只返回符合约束的对象  &#125;&#125;</code></pre><blockquote><p>Type ‘{ length: number; }’ is not assignable to type ‘Type’.<br>‘{ length: number; }’ is assignable to the constraint of type ‘Type’,<br>but ‘Type’ could be instantiated with a different subtype of constraint ‘{ length: number; }’.</p></blockquote><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>使用 <code>name?:type</code></p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>作用：需要调用不同参数个数和类型的函数实现同一个目的</p><pre><code class="TypeScript">function makeDate(timestamp: number): Date;function makeDate(m: number, d: string): Date;function makeDate(m: number, d: number, y: number): Date;function makeDate(mOrTimestamp: number, d?: number|string, y?: number): Date &#123;  if (d !== undefined &amp;&amp; y !== undefined) &#123;    return new Date(y, mOrTimestamp, d);  &#125; else &#123;    return new Date(mOrTimestamp);  &#125;&#125;const d1 = makeDate(12345678);const d2 = makeDate(5, 5, 5);const d3 = makeDate(1,&#39;3&#39;);</code></pre><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>使用 <code>...变量名</code> 表示</p><h3 id="返回类型为void"><a href="#返回类型为void" class="headerlink" title="返回类型为void"></a>返回类型为void</h3><p><code>type vf = () =&gt; void</code></p><ul><li>此时并不强制只返回void,也可以返回其他类型值，但是ts会推论为void</li><li>但是直接 <code>function A():void</code> 返回其他值的时候会报错</li></ul><hr><ul><li>只读属性 readOnly<br><code>interface SomeType &#123; readonly prop: string; &#125;</code></li><li>可选属性</li></ul><pre><code class="TypeScript">interface PaintOptions &#123;  shape: Shape;  xPos?: number;  yPos?: number;&#125;`</code></pre><ul><li>索引签名:字典</li></ul><pre><code class="TypeScript">interface StringArray &#123;  [index: number]: string;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>link VS @import</title>
      <link href="/2022/08/17/link-he-import-de-qu-bie/"/>
      <url>/2022/08/17/link-he-import-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<ol><li>link 是 HTML 标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；@import 是 CSS 提供的语法，只有导入样式表的作用。</li><li>加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li><li>@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。</li><li>可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import 的方式插入样式。</li><li>link 引入的样式权重大于@import 引入的样式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css盒模型</title>
      <link href="/2022/08/17/css-he-mo-xing/"/>
      <url>/2022/08/17/css-he-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h2><ol><li>content：内容，容纳着元素的”真实“内容，例如文本，图像或是视频播放器</li><li>padding：内边距</li><li>border：边框</li><li>margin：外边距</li></ol><hr><h2 id="两种盒模型的区别："><a href="#两种盒模型的区别：" class="headerlink" title="两种盒模型的区别："></a>两种盒模型的区别：</h2><ul><li><p>W3C 盒模型 box-sizing: content-box</p><ul><li>W3C 盒模型中，通过 CSS 样式设置的 width 的大小只是 content 的大小</li></ul></li><li><p>IE 盒模型 box-sizing: border-box</p><ul><li>IE 盒模型中，通过 CSS 样式设置的 width 的大小是 content + padding + border 的和</li></ul></li></ul><hr><h2 id="margin-x2F-padding-设置百分比是相对谁的"><a href="#margin-x2F-padding-设置百分比是相对谁的" class="headerlink" title="margin&#x2F;padding 设置百分比是相对谁的"></a>margin&#x2F;padding 设置百分比是相对谁的</h2><p>margin&#x2F;padding 设置百分比都是相对于父盒子的宽度(width 属性)</p><hr><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>在需要清除浮动的元素后面添加一个空白标签，设置类名 clear，设置 <code>clear: both</code> </li><li>父级元素添加 <code>overflow: hidden</code></li><li>父元素 <code>display：table</code></li><li>伪元素清除浮动</li></ol><pre><code class="css">.clearfix:after &#123;  /*正常浏览器 清除浮动*/  content: &#39;&#39;;  display: block;  height: 0;  clear: both;  visibility: hidden;&#125;</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>clear 属性清除浮动：clear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。</li><li>其他的可以归为一类，都是通过触发 BFC 来实现的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session以及webStorage的区别</title>
      <link href="/2022/08/17/cookie-he-session-yi-ji-webstorage-de-qu-bie/"/>
      <url>/2022/08/17/cookie-he-session-yi-ji-webstorage-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="cookie-VS-webStorage"><a href="#cookie-VS-webStorage" class="headerlink" title="cookie VS webStorage"></a>cookie VS webStorage</h1><ol><li>都会在浏览器端保存，有大小限制，同源限制</li><li>cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器</li><li>cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie</li><li>有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效；localStorage 长期有效，直到用户删除</li><li>作用域不同 sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的</li><li>存储大小不同：cookie 数据不能超过 4K；webStorage 虽然也有存储大小的限制，但是比 cookie 大得多，可以达到 5M 或更大</li></ol><hr><h1 id="cookie-VS-session"><a href="#cookie-VS-session" class="headerlink" title="cookie VS session"></a>cookie VS session</h1><ol><li>存储位置不同：</li></ol><ul><li>cookie 数据存放在客户的浏览器上</li><li>session 数据放在服务器上。</li></ul><ol start="2"><li>存储容量不同：</li></ol><ul><li>单个 cookie 保存的数据不能超过 4K，一个站点最多保存 20 个 cookie。</li><li>对于 session 来说并没有上限，但出于对服务器端的性能考虑，session 内不要存放过多的东西，并且设置 session 删除机制。</li></ul><ol start="3"><li>存储方式不同：</li></ol><ul><li><p>cookie 中只能保管 ASCII 字符串，并需要通过编码方式存储为 Unicode 字符或者二进制数据。</p></li><li><p>session 中能够存储任何类型的数据，包括且不限于 string，integer，list，map 等。</p></li></ul><ol start="4"><li>隐私策略不同</li></ol><ul><li><p>cookie 对客户端是可见的，别有用心的人可以分析存放在本地的 cookie 并进行 cookie 欺骗，所以它是不安全的。</p></li><li><p>session 存储在服务器上，不存在敏感信息泄漏的风险。</p></li></ul><ol start="5"><li>有效期不同</li></ol><ul><li><p>cookie 保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie 是很好的选择。</p></li><li><p>session 是保管在服务器端的，每个用户都会产生一个 session。假如并发访问的用户十分多，会产生十分多的 session，耗费大量的内存</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器输入 URL 之后发生了什么</title>
      <link href="/2022/08/17/after-input-url/"/>
      <url>/2022/08/17/after-input-url/</url>
      
        <content type="html"><![CDATA[<ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http 状态码</title>
      <link href="/2022/08/17/http-status-code/"/>
      <url>/2022/08/17/http-status-code/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><ul><li>1XX 信息性状态码<ul><li>100 继续</li><li>101 切换协议</li></ul></li><li>2XX 成功状态码<ul><li>200 OK 成功处理了请求</li><li>204 No Content 请求处理成功，但没有资源可返回</li><li>206 Partial Content 请求资源的某一部分</li></ul></li><li>3XX 重定向状态码<ul><li>301 永久性重定向，表示请求的资源已被分配了新的 URI，比如启用了新域名、服务器切换到了新机房、网站目录层次重构，这些都算是“永久性”的改变。响应的 Location 首部中应该包含 资源现在所处的 URL</li><li>302 临时性重定向，资源的 URL 已临时定位到其他位置，客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求仍应使用老的 URL</li><li>303 告诉客户端应该用另一个 URL 获取资源</li><li>304 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li></ul></li><li>4XX 客户端错误状态码<ul><li>400 表示请求报文中存在语法错误</li><li>401 未授权，客户端没有带认证信息或者带了错误的认证信息, 这时客户端可以修改认证信息进行重试</li><li>403 服务器拒绝了请求，客户端带了正确的认证信息, 但服务器认为这个认证信息对应的用户是没有对应资源的访问权限的, 因此, 在向管理员获取相关权限之前, 是没有重试的必要的</li><li>404 服务器无法找到所请求的 URL</li></ul></li><li>5XX 服务器错误状态码<ul><li>500 内部服务器错误</li><li>502 错误网关</li><li>503 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li><li>504 响应超时</li></ul></li></ul><hr><h1 id="HTTP1-0-和-HTTP1-1-和-HTTP2-0-的区别"><a href="#HTTP1-0-和-HTTP1-1-和-HTTP2-0-的区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 和 HTTP2.0 的区别"></a>HTTP1.0 和 HTTP1.1 和 HTTP2.0 的区别</h1><p>超文本传输协议（HTTP）用于浏览器与服务器之间的通信</p><h2 id="HTTP1-0-和-HTTP1-1"><a href="#HTTP1-0-和-HTTP1-1" class="headerlink" title="HTTP1.0 和 HTTP1.1"></a>HTTP1.0 和 HTTP1.1</h2><ul><li>缓存处理：<ul><li>1.0 的 header 中主要是通过 If-Modified-Since（比较资源的最后的更新时间是否一致），expires(资源的过期时间，取决于客户端本地时间)</li><li>1.1 引入了其他的 If-Match(比较 ETag 是否一致), If-None-Match(比较 ETag 是否不一致), If-Unmodified-Since(比较资源最后的更新时间是否不一致), Entity tag(资源的匹配信息)</li></ul></li><li>带宽优化<ul><li>1.0 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，但是服务器将整个对象返回。</li><li>1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content）</li></ul></li><li>Host 头处理<ul><li>1.0 中认为每个服务器都有一个唯一的 Ip，因此请求的 url 中并没有传递主机名（hostname）</li><li>随着虚拟化技术的发展，一台物理机上可以有多个虚拟机，共享同一个 ip，1.1 中的请求消息和响应消息都支持 Host，请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）</li></ul></li><li>长连接<ul><li>http 是基于 TCP&#x2F;IP 协议的，创建一个 TCP 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</li><li>1.0 中每次需要使用 keep-alive 参数来告知服务器端要建立一个长连接</li><li>1.1 默认支持长连接，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点</li></ul></li><li>新增状态码<ul><li>1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除</li></ul></li><li>新增请求方式<ul><li>PUT，DELETE，OPTIONS 等</li></ul></li></ul><h2 id="http2-0-与-http1-X-区别"><a href="#http2-0-与-http1-X-区别" class="headerlink" title="http2.0 与 http1.X 区别"></a>http2.0 与 http1.X 区别</h2><ol><li>header 压缩: header 头部带有大量的信息，而且每次使用报头压缩，降低开销，对于相同的 header 数据，不再通过每次请求和响应发送，差量更新 HTTP 头部，既避免了重复 header 的传输，又减小了需要传输的大小</li><li>多路复用:在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序<br>二进制分帧:消息由一个或多个帧组成。多个帧之间可以乱序发送</li><li>服务端推送:HTTP2 引入服务器推送，允许服务端推送资源给客户端,服务器会顺便把一些客户端需要的资源一起推送到客户端</li></ol><hr><h1 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h1><ol><li>HTTP 传输的数据都是未加密的，也就是明文的，HTTPS 协议是由 HTTP 和 SSL 协议构建的可进行加密传输和身份认证的网络协议，比 HTTP 协议的安全性更高。</li><li>HTTPS 协议需要 CA 证书；</li><li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443；</li></ol><hr><h1 id="HTTPS-协议的工作原理"><a href="#HTTPS-协议的工作原理" class="headerlink" title="HTTPS 协议的工作原理"></a>HTTPS 协议的工作原理</h1><ol><li>客户使用 HTTPS URL 访问服务器，则要求 web 服务器建立 SSL 链接，客户端向服务器发送的报文包括客户端所支持的 ssl 版本，支持的加密算法以及密钥的长度。</li><li>web 服务器接收到客户端的请求之后，也在报文中包含 SSL 版本以及加密组件，服务器的加密组件内容时从接收到的客户端加密组件内筛选出来的。</li><li>同时，web 服务器会将网站的 CA 证书（证书中包含了公钥），返回给客户端。</li><li>客户端通过 CA 证书来验证服务端的身份，公钥是否有效，比如颁发机构，过期时间，并随机生成对称加密的密钥 X 用公钥加密发给服务端。</li><li>服务器拿到客户端发过来的加密内容用自己的私钥解密获取到密钥 X。</li><li>双方都拿到了密钥 X，SSL 通道建立完成，通过密钥 X 加密信息来进行通信。 总结：HTTPS 协议使用了非对称加密 + 对称加密的方式，即利用了非对称加密安全性高的特点，又利用了对称加密速度快，效率高的好处</li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
