---
title: 01-线性表
urlname: ygm3p9
date: '2022-05-04 20:08:21 +0800'
tags: []
categories: []
---

<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">💡  根据 [遗忘曲线](https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fr=aladdin)：如果没有记录和回顾，6天后便会忘记75%的内容
      读书笔记正是帮助你记录和回顾的工具，不必拘泥于形式，其核心是：记录、翻看、思考</div>

| **章节名** | 线性表                       |
| ---------- | ---------------------------- |
| **状态**   | 阅读中->已读完               |
| **简介**   | 零个或多个数据元素的有限序列 |

## 思维导图

> 用思维导图，结构化记录本书的核心观点。

![](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653326235230-7291282c-bb5c-4ee2-bc95-7516a4d739e3.jpeg)

## 读后感

无论是双向链表还是循环链表，好像本质上都是从单链表中延伸出来的，万变不离其宗
顺序表的应用场景：排队叫号系统
链表的应用场景：OA 工作流

## 顺序表的实现机制：

本质上，顺序表就是数组的形式
原理：利用数组的连续存储空间顺序存放数据元素，元素之间的逻辑关系和物理位置关系一致
![1653351922(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653351929107-7f88cb38-4b83-496d-b7de-fa4351a575d8.png#clientId=uf522079f-3cc0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=98&id=u410dad22&margin=%5Bobject%20Object%5D&name=1653351922%281%29.png&originHeight=161&originWidth=1083&originalType=binary∶=1&rotation=0&showTitle=false&size=16004&status=done&style=stroke&taskId=u8978790b-7d15-4fda-aeb9-5ef64d57308&title=&width=656.363598426842)

#### 顺序表初始化：

原理：建立一个空表

```javascript
function makeEmptyList() {
  this.List = [];
  this.length = 0;
}
```

#### 按下标查找元素

```javascript
function getElem(index) {
  if (this.List.length === 0 || index < 1 || index > this.List.length) {
    return this.Status.ERROR;
  }
  const val = this.List[index - 1];
  return this.Status.OK;
}
```

#### 按值查找元素：

```javascript
function getElemByData(item) {
  this.List.forEach((element, index) => {
    if (element === item) {
      return index;
    }
  });
  return -1;
}
```

#### 插入元素

```javascript
function insertElem(ele, index) {
  // 如果插入位置不合理，抛出异常
  if (index < 1 || index > this.List.length) {
    return this.Status.ERROR;
  }
  // 从最后一个元素开始向前遍历到第i个位置，分别将他们向后移动一个位置
  for (let k = this.List.length - 1; k >= index - 1; k--) {
    this.List[k + 1] = this.List[k];
  }
  // 将待插入元素填入位置i
  this.List[index - 1] = ele;
  return this.Status.OK;
}
```

#### 删除元素

```javascript
function delElem(index) {
  // 如果删除位置不合理，抛出异常
  if (this.List.length === 0 || index < 1 || index > this.List.length) {
    return this.Status.ERROR;
  }
  // 取出删除元素
  const e = this.List[index - 1];
  //从删除位置开始遍历到最后一个元素，分别前移一位
  for (let k = index; k <= this.List.length; k++) {
    this.List[k - 1] = this.List[k];
  }
  this.length--;
  console.log(e, this.List);
  return this.Status.OK;
}
```

## 链表的实现机制

链表的每个元素是由存储元素本身的节点和一个指向下一个元素的引用构成，通过链建立元素之间的逻辑关系
![1653023811(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653023826283-d05889e0-8a0d-4fd6-9565-c9624d3a3fc5.png#clientId=u502cfbc7-1ce9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=207&id=ud957c2bc&margin=%5Bobject%20Object%5D&name=1653023811%281%29.png&originHeight=342&originWidth=448&originalType=binary∶=1&rotation=0&showTitle=true&size=3685&status=done&style=stroke&taskId=u69cb7a99-20ca-4f36-b7c1-74f929590ec&title=%E5%8D%95%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9&width=270.50567626953125 "单个链表元素节点")![1653331226(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653331233189-77920955-c772-404d-b914-58337028179c.png#clientId=uecae4837-d0ca-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=66&id=ubce08e35&margin=%5Bobject%20Object%5D&name=1653331226%281%29.png&originHeight=109&originWidth=1033&originalType=binary∶=1&rotation=0&showTitle=true&size=11029&status=done&style=stroke&taskId=ufbb0bf37-f48c-41e6-a8a1-c7d52b1a60f&title=%E5%8D%95%E9%93%BE%E8%A1%A8&width=626.0605698752796 "单链表")
相对于数组来说，链表的优势如下：

- 链表元素之间的逻辑关系是连续的，但是在内存空间里不是连续的，可以充分利用内存，实现灵活的内存动态管理
- 不需要在创建的时候就确定大小，并且可以无限扩展（这个是其他语言中存在的问题，但是在 js 里面目测不存在这个问题？）
- 链表在执行插入删除的时候，不需要依次移动后面的元素，效率比较高

#### 链表的定义

```javascript
class Node {
  constructor(data) {
    // 数据域：存放数据元素
    this.data = data;
    // 指针域：存放直接后继节点的地址
    this.next = null;
  }
}
class ChainList {
  constructor() {
    // 记录单链表的长度或节点个数
    this.size = 0;
    // 定义头节点
    this.head = new Node("head");
    this.currentNode = "";
  }
}
```

#### 求表长

原理：遍历链表元素，当当前节点的 next 指向 Null 的时候，说明这是最后一个链表元素节点

```javascript
function getLength() {
  this.currentNode = this.head;
  let count = 0;
  while (currentNode) {
    this.currentNode = this.currentNode.next;
    count++;
  }
  this.size = count;
  return count;
}
```

#### 通过序号查找元素

原理：从头节点开始遍历链表,让 p 的指针向后移动,不断指向下一个节点,j 累加,直到到达指定位置

```javascript
function getElem(index) {
  this.currentNode = this.head;
  let j = 1;
  while (this.currentNode && j < index) {
    this.currentNode = this.currentNode.next;
    j++;
  }

  if (j === index) {
    console.log(this.currentNode);
    return this.currentNode;
  } else {
    return NULL;
  }
}
```

#### 按值查找

原理：从头节点遍历链表，判断数据域是否与参数一致

```javascript
function getElemByData(elem) {
  this.currentNode = this.head;
  while (this.currentNode && this.currentNode.data !== elem) {
    this.currentNode = this.currentNode.next;
  }
  console.log(this.currentNode);
  return this.currentNode;
}
```

#### 插入节点

原理：新建一个节点，找到链表的第 i-1 个节点，设置为当前节点,设置新建节点和其他元素链之间的关系
![1653339288(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653339293693-556e47a6-86fb-4693-a5a5-9db6eb2cbc49.png#clientId=uecae4837-d0ca-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=156&id=u9a2ec970&margin=%5Bobject%20Object%5D&name=1653339288%281%29.png&originHeight=257&originWidth=1117&originalType=binary∶=1&rotation=0&showTitle=false&size=21605&status=done&style=stroke&taskId=u760b6165-6e08-46b8-8696-a76aa93bf16&title=&width=676.9696578419044)

```javascript
function insertElem(index, elem) {
  this.currentNode = this.getElem(index - 1);
  if (!this.currentNode) {
    return Status.ERROR;
  } else {
    let newNode = new Node(elem);
    newNode.next = this.currentNode.next;
    this.currentNode.next = newNode;
    return Status.OK;
  }
}
```

#### 删除节点：

原理：找到链表的第 i-1 个节点，设置为当前节点；
![1653339885(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653339893238-0e1db448-37b4-4ce2-bc51-954b2b422814.png#clientId=uecae4837-d0ca-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=162&id=ub15d2fd9&margin=%5Bobject%20Object%5D&name=1653339885%281%29.png&originHeight=268&originWidth=1257&originalType=binary∶=1&rotation=0&showTitle=false&size=26240&status=done&style=stroke&taskId=u73476932-0d64-4ac3-95cf-3c4a4505968&title=&width=761.8181377862793)

```javascript
function delElem(index) {
  this.currentNode = this.getElem(i - 1);
  let delNode = this.currentNode.next;
  this.currentNode.next = delNode.next;
  const data = delNode.data;
  return `${Status.OK} data`;
}
```

### 双向链表：

![1653355256(1).png](https://cdn.nlark.com/yuque/0/2022/png/115484/1653355259842-b1ca38da-ae1e-4234-a0a0-ecd405ee7131.png#clientId=u477f7646-c449-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=ue3cf0e74&margin=%5Bobject%20Object%5D&name=1653355256%281%29.png&originHeight=349&originWidth=643&originalType=binary∶=1&rotation=0&showTitle=true&size=28162&status=done&style=stroke&taskId=u905afe01-1ac2-4977-85c5-6a5905621c2&title=%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8&width=389.6969471730927 "双向链表")
原理：在单个链表节点中有两个指针域，next 指向直接后继元素，prev 指向直接前驱元素

#### 双向链表定义

```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}
class doubleList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
}
```

#### 获取元素

原理：先判断需要获取元素的位置在前半段还是后半段，如果是在前半段就从头节点开始遍历，否则从尾节点开始遍历

```javascript
function getElem(position) {
  if (position < 0 || position >= this.length) {
    return Status.ERROR;
  }
  let currentNode = null;
  let index = 0;
  if (position < this.length / 2) {
    currentNode = this.head;
    while (index < position) {
      currentNode = currentNode.next;
      index++;
    }
  } else {
    currentNode = this.tail;
    index = this.length - 1;
    while (index > position) {
      currentNode = currentNode.prev;
      index--;
    }
  }
  return current.data;
}
```

#### 插入元素

原理：根据链表长度和插入位置改变节点的 prev 和 next 指针指向

```javascript
function insertElem(position, data) {
  if (position < 0 || position > this.length) return Status.ERROR;
  let newNode = new Node(data);
  // 原链表为空
  // 情况1：插入的newNode是第一个节点
  if (this.length == 0) {
    this.head = newNode;
    this.tail = newNode;
  } else {
    // 原链表不为空
    // 情况2：position == 0
    if (position == 0) {
      this.head.prev = newNode;
      newNode.next = this.head;
      this.head = newNode;
    } else if (position == this.length) {
      // 情况3：position == this.length
      this.tail.next = newNode;
      newNode.prev = this.tail;
      this.tail = newNode;
    } else {
      // 情况4：0 < position < this.length
      let current = this.head;
      let index = 0;
      while (index < position) {
        current = current.next;
        index++;
      }
      //修改pos位置前后节点变量的指向
      newNode.next = current;
      newNode.prev = current.pre;
      current.prev.next = newNode;
      current.prev = newNode;
    }
  }
  this.length++;
  return Status.OK;
}
```

#### 删除元素

原理：先找到元素所在位置，然后根据不同情况修改头节点，尾节点或者对应节点的指针

```javascript
function indexOf(data) {
  let currentNode = this.head;
  let index = 0;
  while (currentNode) {
    if (currentNode.data === data) {
      return index;
    }
    currentNode = currentNode.next;
    index++;
  }
  return -1;
}
function removeAt(position) {
  if (position < 0 || position >= this.length) return Status.ERROR;
  let currentNode = this.head;
  if (this.length === 1) {
    this.head = null;
    this.tail = null;
  } else {
    if (position === 0) {
      // 删除第一个节点
      this.head.next.prev = null;
      this.head = this.head.next;
    } else if (position === this.length - 1) {
      // 删除最后一个节点
      currentNode = this.tail;
      this.tail.prev.next = null;
      this.tail = this.tail.prev;
    } else {
      let index = 0;
      while (index < position) {
        current = current.next;
        index++;
      }
      current.pre.next = current.next;
      current.next.pre = current.pre;
    }
  }
  this.length--;
  return currentNode.data;
}
function remove(data) {
  let index = this.indexOf(data);
  return this.removeAt(index);
}
```
