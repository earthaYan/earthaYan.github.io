---
title: 02-多进程
urlname: vkq91g
date: '2022-06-30 00:37:26 +0800'
tags: []
categories: []
---

electron 内置了继承自 chromium 内核的多进程架构
拒绝单进程原因：

- 浏览器主要任务是展示 web 页面内容，但是同时也承担了部分需求：管理多个标签页或者窗口，加载第三方插件
- 早期，浏览器通常使用一个进程来实现上述所有这些功能。这种模式意味着你打开的每个标签的开销更小，但也意味着一个网站的崩溃或挂起会影响整个浏览器

解决方法：多进程模型
每个 tab 页在自己的进程中渲染，单个浏览器进程控制这些子进程和应用程序的生命周期
![](https://cdn.nlark.com/yuque/0/2022/png/115484/1656521167001-6e88f512-f07f-4e5b-8665-5bc6464e49d8.png#clientId=u27dffca4-2ce5-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u12bd4310&margin=%5Bobject%20Object%5D&originHeight=138&originWidth=593&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5a28ec78-aee2-4b77-aef4-4a8e21f7eb0&title=)
![kr6eXvsSoy.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1656997385285-7ee691b7-56dd-499d-a9af-67a038efa8c3.jpeg#clientId=uf47051aa-69ae-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=589&id=ucf28b4ec&margin=%5Bobject%20Object%5D&name=kr6eXvsSoy.jpg&originHeight=884&originWidth=1122&originalType=binary∶=1&rotation=0&showTitle=false&size=374375&status=done&style=none&taskId=ubae37345-0757-471e-84ce-c156db61c80&title=&width=748)

---

开发者控制：

- 主进程：
  - 作为整个应用的入口，运行在 Node.js 环境，可以使用 require 模块和 Node.js 的 api
  - 主要作用是窗口管理,一个个 BrowserWindow 实例相当于浏览器中的一个个 tab 页，在各自的渲染器进程中创建加载 web 页面的应用窗口
  - 可以使用窗口的 webContents 对象与 web 内容进行交互，可以添加各种用户事件的处理
  - BrowserWindow 实例窗口销毁，相关的渲染器进程也会终止
  - 通过 app 模块控制应用程序的生命周期
  - 提供了 API 与操作系统或桌面交互
- 渲染器进程:
  - app 为每个窗口实例和嵌入式 web 内容生成一个渲染器进程
  - 作用是渲染 web 内容
  - 运行在渲染器进程上的代码都应该遵循 web 标准【至少像 Chromium】
  - HTML 文件是渲染器进程的入口文件
  - UI 样式通过 css 增加
  - 通过 script 标签添加可执行的 JS 代码
  - 渲染器不能使用 require 或者 Node.js 的 api
  - 渲染器中直接包含 NPM 模块，必须使用 web 上使用的打包工具例如，webpack 或 parcel)。
- preload 脚本：
  - 预渲染脚本在 web 内容开始加载之前在渲染器进程中执行
  - preload 脚本和渲染器进程共享全局的 window 接口，可以访问 Node.js 的 api,它通过暴露
  - 运行在渲染器上下文，但是有权限访问 Node.js 的 API
  - 通过 webPreferences 选项附加在主进程上
