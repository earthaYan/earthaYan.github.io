---
title: 02-栈与队列
urlname: uk4eef
date: '2022-05-29 14:17:09 +0800'
categories: [算法,数据结构]
categories: [算法]
---

<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">💡  根据 [遗忘曲线](https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fr=aladdin)：如果没有记录和回顾，6天后便会忘记75%的内容
      读书笔记正是帮助你记录和回顾的工具，不必拘泥于形式，其核心是：记录、翻看、思考</div>

| **书名** | 栈与队列       |
| -------- | -------------- |
| **状态** | 待开始->阅读中 |
| **简介** | 栈与队列       |

## 读后感

### 观点 1

> 栈其实就是线性表，只是它的操作位置限制在了线性表表尾

### 观点 2

> 双向栈本质上就是把两个栈分别放在数组的两端，然后不断向中间靠拢。

### 观点 3

> 读完该书后，受益的核心观点与说明...

## 栈：

### 基本构成：

栈是特殊的线性表，元素存在唯一的前驱元素和后继元素，逻辑遵循先进先出原则

### 区别：

栈添加/删除元素的位置只能是在栈顶，即线性表表尾

### 顺序存储结构：

![843933d3ccd14d4ad8a823e5ea1967b1.jpeg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653810215559-eff77ccf-34c7-44d3-8d61-32199be90b60.jpeg#clientId=u7c2619cf-bc38-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=u379a5419&margin=%5Bobject%20Object%5D&name=843933d3ccd14d4ad8a823e5ea1967b1.jpeg&originHeight=332&originWidth=843&originalType=binary∶=1&rotation=0&showTitle=true&size=33124&status=done&style=none&taskId=u5fff932c-7902-4d22-87fd-87a06f015a3&title=%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B&width=510.90906137934246 "栈的基本操作过程")

#### 初始化

```javascript
constructor() {
  this.length = 0;
  this.stack = [];
}
```

#### 插入元素：

原理：增加栈的长度，设置栈顶元素(即数组的最后一个元素)为当前待插入元素

```javascript
pushToStack(ele) {
  this.length++;
  this.stack[this.length - 1] = ele;
}
```

#### 删除元素：

原理：获取栈数组最后一个元素的位置，根据位置获取待删除元素并返回，同时减小栈的长度

```javascript
popFromStack() {
  if (this.length === 0) {
    return 'error';
  }
  const index = this.length - 1;
  const data = this.stack[index];
  this.stack.length--;
  this.length--;
  return data;
}
```

#### 双向栈：

![33a8740de962c3567b5ffbb06c7333f.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653876458438-d23d8689-af7b-4b4e-8efb-f0e10b3dd336.jpeg#clientId=ue953f90b-f069-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=2663&id=u2aa1424a&margin=%5Bobject%20Object%5D&name=33a8740de962c3567b5ffbb06c7333f.jpg&originHeight=1830&originWidth=435&originalType=binary∶=1&rotation=90&showTitle=false&size=319868&status=done&style=none&taskId=u73b7b036-3a46-47c4-a843-ebd35e883ab&title=&width=633.0037231445312)
定义：所谓的双向栈，就是两个栈合并在一起用一个数组表示，数组的开始是栈 1 的栈底，数组的结束是栈 2 的栈底。两个栈共享内存空间

```javascript
constructor(length) {
  this.stack = new Array(length);
  this.top1 = -1;//栈1的栈顶指针
  this.top2 = this.stack.length;//栈2的栈顶指针
  this.rightPositionId = 0;//栈2的起始位置
}
```

操作：
原理：如果两个栈顶指针只相差 1 的话，说明此时该共享空间已满，不能再插入新的数据。如果在左侧栈插入数据，栈 1 的栈顶指针后移，如果在右侧插入数据，栈 2 的栈顶指针前移，栈 2 数组元素的起始位置此时为栈 2 的栈顶指针

```javascript
sharePush(ele, stackId) {
  if (this.top2 - this.top1 === 1) {
    console.log('栈已满');
    return Status.ERROR;
  }
  if (stackId === 1) {
    this.top1++;
    this.stack[this.top1] = ele;
  } else if (stackId === 2) {
    this.top2--;
    this.stack[this.top2] = ele;
    this.rightPositionId = this.top2;
  }
  return Status.OK;
}
```

原理：在删除之前，先判断当前栈是否为空栈。如果删除的是左边的元素，则栈 1 的栈顶指针前移，栈 2 数组元素的起始位置前移 1 位，如果删除的是右边的元素，则栈 2 的栈顶指针后移 1 位，

```javascript
sharePop(stackId) {
  if (stackId === 1) {
    if (this.top1 === -1) {
      // 空栈
      return Status.ERROR;
    }
    const data = this.stack.splice(this.top1, 1);
    this.top1--;
    this.rightPositionId--;
    return data;
  } else if (stackId === 2) {
    if (this.top2 === this.stack.length) {
      return Status.ERROR;
    }
    const data = this.stack.splice(this.rightPositionId, 1);
    this.top2++;
    return data;
  }
}
}
```

### 链式存储结构：

#### 初始化

![6409bc8af01e6217dd7ac56d0d355bc.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653960016916-b7a2edb8-ed2b-492c-8951-b9575de5021b.jpeg#clientId=u85c50bbe-efb4-4&crop=0.2061&crop=0&crop=0.6183&crop=1&from=paste&height=105&id=u3d77fda4&margin=%5Bobject%20Object%5D&name=6409bc8af01e6217dd7ac56d0d355bc.jpg&originHeight=931&originWidth=1920&originalType=binary∶=1&rotation=0&showTitle=false&size=512492&status=done&style=none&taskId=u54486acc-0dd0-4197-bb85-a8e3a69b8c7&title=&width=216)链栈是链表的一种，必须有一个栈顶指针，而普通的单链表是必须有一个头指针，在这里可以使用 top 指针代替头指针，指向单链表的头部。当为空栈的时候，top 指针指向 Null

```javascript
class StackNode {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}
class LinkedStack {
  constructor() {
    this.top = null;
    this.count = 0;
  }
}
```

#### 插入元素

![21e9ec466957019d1a96cd8923f1abc.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653960726166-e83ef31b-f9df-475e-a7b3-c2e8dc267803.jpeg#clientId=u85c50bbe-efb4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=179&id=u79132938&margin=%5Bobject%20Object%5D&name=21e9ec466957019d1a96cd8923f1abc.jpg&originHeight=750&originWidth=926&originalType=binary∶=1&rotation=90&showTitle=false&size=268978&status=done&style=none&taskId=u6d37b7bb-4690-4a1c-bea1-2663dcf85eb&title=&width=220.99240112304688)
原理：新建一个栈元素节点，将当前栈顶元素作为新节点的直接后继，然后再将 top 指针指向新节点

```javascript
function pushToLinkedStack(data) {
  const newNode = new StackNode(data);
  newNode.next = this.top;
  this.top = newNode;
  this.count++;
  return Status.OK;
}
```

#### 删除元素

![765db90d6c47fd5eb7e40eaa2e88a88.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1653960877565-09c31878-0b69-4002-9fd5-09565e2daaf2.jpeg#clientId=u85c50bbe-efb4-4&crop=0&crop=0.2899&crop=0.9817&crop=0.7071&from=paste&height=437&id=ud822a1c9&margin=%5Bobject%20Object%5D&name=765db90d6c47fd5eb7e40eaa2e88a88.jpg&originHeight=1920&originWidth=931&originalType=binary∶=1&rotation=90&showTitle=false&size=530008&status=done&style=none&taskId=u23f084e9-d091-4007-9fcf-c760f13e37d&title=&width=211.9943084716797)
原理：先保存需要删除的栈顶元素节点，再将栈顶指针后移,切断原来的栈顶元素与整个栈的关联

```javascript
function stackEmpty() {
  return !this.count;
}
function popFromLinkedStack() {
  if (this.stackEmpty()) {
    return Status.ERROR;
  }
  const delData = this.top.data;
  const delNode = this.top;
  this.top = delNode.next;
  this.count--;
  return delData;
}
```

## 队列：

### 定义：

只在一端（队尾）进行插入操作，另一端（队首）进行删除操作的线性表，遵循先进先出原则
![image.png](https://cdn.nlark.com/yuque/0/2022/png/115484/1655184909210-f5aa902b-3636-4122-82a7-907fd7574e62.png#clientId=u2572a1b6-4ef5-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=78&id=uf6ebac2f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=125&originWidth=404&originalType=url∶=1&rotation=0&showTitle=false&size=3650&status=done&style=none&taskId=u29608741-72a8-4d04-92ac-befa2566a79&title=&width=250.99050903320312)
