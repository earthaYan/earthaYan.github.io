---
title: 排序
urlname: kw57o5
date: '2022-08-15 18:28:06 +0800'
tags: []
categories: []
---

| **分类标准**                 | **细类**                     | **区别**       |
| ---------------------------- | ---------------------------- | -------------- |
| 存储介质                     | 内部/外部排序                |
| 外部排序 aka 文件排序        | 内部：数据量不大，数据在内存 |
| 外部：数据量较大，数据在外存 |
| 比较器个数                   | 串行/并行排序                | 串行：单处理机 |
| 并行：多处理机               |
| 主要操作                     | 比较排序                     |

- 插入排序
- 交换排序
- 选择排序
- 合并排序

基数排序 | 比较：比较元素大小
基数：不比较元素大小，仅根据元素本身的取值确定其有序位置
|
| 辅助空间 | 原地排序
非原地排序 | 原地：辅助空间用量为 O(1)的排序方法，不占用额外空间
|
| 稳定性 | 稳定排序
非稳定排序 | 稳定：能够使任何数值相等的元素，排序以后相对次序不变
只对结构类型数据排序有意义 |
| 自然性 | 自然排序
非自然排序
| 自然：输入数据越有序，排序速度越快的排序方法 |

## 插入排序

原理：有序插入，在有序序列中插入一个元素，保持序列有序,从而使得有序序列的长度不断增加

| 顺序法确定插入位置     | 直接插入排序 |
| ---------------------- | ------------ |
| 二分法确定插入位置     | 二分插入排序 |
| 缩小增量，多遍插入排序 | 希尔排序     |

### 直接插入排序：

方法：顺序查找，确定插入的位置 j，边查找边移动元素
空间复杂度：O(1) 即不需要额外的辅助存储空间
时间复杂度：

1. 原始数据越接近有序，排序速度越快
1. 属于自然排序，具有稳定性
1. 最坏情况下（输入数据是逆有序的）：C 和 M 达到最大值， Tn=O(n2)

![FuRjFewhY3.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1660807051435-b322797e-6a30-43f5-b386-47c12f7db1c2.jpeg#clientId=ufc20187f-ca28-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=178&id=uf5136974&margin=%5Bobject%20Object%5D&name=FuRjFewhY3.jpg&originHeight=476&originWidth=990&originalType=binary∶=1&rotation=0&showTitle=false&size=103069&status=done&style=none&taskId=u073c1d75-8bc9-42ee-8b04-f2fb94a048d&title=&width=371)
提高排序速度要素：减少元素的比较次数和移动次数

```javascript
let x=a[i] //空出a[i]的位置
for(let j=i-1;j>0&&x<a[j];j---){
  //移动，定位
  a[j+1]=a[j]
}
a[j+1]=x //将x插在位置j+1
```

```javascript
function sortByMovingAndFindData(arr) {
  for (let i = 0; i < arr.length; i++) {
    let x = arr[i],
      j;
    for (j = i - 1; j > 0 && x < arr[j]; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = x;
  }
  console.log(arr);
  return arr;
}
let arr1 = [3, 5, 10, 16, 7, 32, 83, 23];
sortByMovingAndFindData(arr1);
```

---

### 二分插入排序：

原理：在直接插入排序的基础上，使用双指针和二分值减少了元素的比较次数，但是没有减少元素的移动次数
时间复杂度： Tn=O(n2)

```javascript
let x = a[i];
for (let j = i - 1; j >= left; j--) {
  a[j + 1] = a[j]; //元素右移
}
a[j + 1] = x; //元素x就位
```

```javascript
function sortByMiddle(arr) {
  for (let i = 0; i < arr.length; i++) {
    let x = arr[i];
    let left = 0,
      right = i - 1,
      j;
    while (left <= right) {
      let middle = Math.floor((left + right) / 2);
      if (x < arr[middle]) {
        right = middle - 1;
      } else {
        left = middle + 1;
      }
    }
    for (j = i - 1; j >= left; j--) {
      arr[j + 1] = arr[j];
    }
    arr[left] = x;
  }
  console.log(arr);
  return arr;
}
let arr1 = [3, 5, 10, 16, 7, 32, 83, 23];
sortByMiddle(arr1);
```

---

### 希尔插入排序：

原理：比较一次，移动一大步，使它尽快靠近正确的插入位置，从而减少移动次数
特点：缩小增量，多遍插入排序，最后一个增量必须是 1
时间复杂度：与增量序列有关
空间复杂度：与增量序列有关
概念：

1. h-排序：增量为 h 的那一遍排序
1. h-子序列：下标间隔为 h 的元素组成的子序列
1. h-前驱/后继：同一个 h-子序列中的元素之间有 h-前驱后继关系
