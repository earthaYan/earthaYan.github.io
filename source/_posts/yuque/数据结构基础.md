---
title: 数据结构基础
urlname: iga214
date: '2022-04-13 11:21:52 +0800'
tags: []
categories: []
---

## 数据结构：

目标：将数据和逻辑关系存储到计算机内存

- 逻辑结构：数据对象中数据元素之间的相互关系，面向问题![](https://cdn.nlark.com/yuque/0/2022/jpeg/115484/1649822579300-8ba8c31e-10a5-4e5a-a908-8cfefa2e93a1.jpeg#clientId=u2322b651-ea2b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ucb6c880b&margin=%5Bobject%20Object%5D&originHeight=323&originWidth=1132&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1a4c0eec-288e-43da-b3f2-f8d0ed2cd6d&title=)
  - 集合结构
    - 各个数据元素平等，除了同属于某个集合，他们没有任何关系
  - 线性结构
    - 数据元素之间是一对一的关系
  - 树形结构
    - 数据元素之间存在一种一对多的层次关系
  - 图形结构
    - 数据元素之间是多对多的关系
- 物理结构（存储结构）：数据的逻辑结构在计算机中的存储形式，面向计算机

![image.png](https://cdn.nlark.com/yuque/0/2022/png/115484/1649823654277-3211402b-74da-477c-95fb-7a5c859fee9e.png#clientId=u2322b651-ea2b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaaab5a60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=458&originWidth=713&originalType=url∶=1&rotation=0&showTitle=false&size=20887&status=done&style=none&taskId=u60f1ecee-196c-440e-9c43-49bca79fd6d&title=)

- 顺序存储结构
  - 把数据元素存放在地址连续的存储单元里，数据间的逻辑关系和物理关系一致
  - 本质上就是排队占位
  - 典型的就是数组，建立一个有 9 个整型数据的数组，计算机在内存中找空闲区域，按照一个整型所占位置大小乘以 9，开辟一段连续空间，数组数据按照顺序依次排放
- 链式存储结构
  - 把数据元素放在任意的存储单元里，数据元素的物理关系不能反映逻辑关系
  - 使用一个指针存放数据元素的地址，通过地址确定相关联数据元素的位置
  - 缺点：数据节点之间是单线联系，如果中间某个节点出问题则整个存储结构就会出问题

---

## 线性表：

举个生活中的例子：

> 一个广场上有老人，有小孩，那么小孩的数据对于整个广场的人群来说，不能算是线性表的结构。但如果一个班级的小朋友，一个跟着一个排队，有一个开头和结尾，当中的小朋友知道他前后分别是谁，如同有一根线把他们串起来，就可以称之为线性表

定义：零个或多个数据元素的有序排列，多个数据元素时，第一个元素没有前驱元素，最后一个元素没有后继元素，中间的有且仅有一个直接前驱和后继

```javascript
ADT 线性表（List）
Data
  线性表的数据集合对象为{a1,a2,..an},类型为DataType。
  除开头和结尾外，中间的元素都是有且只有一个前驱和后继元素。
  数据元素之间的关系是一对一的关系
Operation
  initList
  getLength;
  clear; // 清空顺序表
  insertEl; // 插入元素
  removeEl; // 删除元素
  changeEl; // 更改元素
  findEl;     // 查找元素
end ADT
```

    这些都是线性表最基本的操作，实际问题中涉及的关于线性表的更复杂操作，可以通过基本操作组合来实现。比如，实现两个线性表A和B的并集操作，本质上就是把存在于B但不存在于A中的数据元素插入A。

步骤：

1. 获取列表 B 长度—— getLength
1. 循环获取 B 中的每个元素,判断当前元素是否在 A 中——findEl
1. 不存在则插入 A——insertEl

---

### 线性表的顺序存储结构（顺序表）

> 顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙

![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649923900190-d71ecb50-b0ef-4552-8b9b-dad7bf137054.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u31218b3e&margin=%5Bobject%20Object%5D&originHeight=82&originWidth=400&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaa43d475-59ff-42f9-8a72-c8597caa919&title=)

#### 顺序表插入元素

> 顺序表插入数据的步骤：
>
> 1. 通过遍历，找到数据元素要插入的位置
> 1. 将要插入位置元素以及后续的元素整体向后移动一个位置
> 1. 把元素放到腾出来的位置上

例如，在 [1, 2, 3, 4, 5] 的第 3 个位置上插入元素 6，实现过程如下：
![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649924673017-e346aaa6-0d13-42f9-87ae-5db520e7b1fb.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u586ba085&margin=%5Bobject%20Object%5D&originHeight=97&originWidth=400&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1484698-62e5-4c2a-99bc-8b354a56510&title=)
![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649924699151-e72d5510-cd4e-47a4-bbe2-5488dae89a60.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6eb08ffa&margin=%5Bobject%20Object%5D&originHeight=139&originWidth=400&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u213bed82-afb8-463d-8138-aa3878d30a9&title=)
![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649924727742-27ed308e-2297-431d-9790-03b8273ecee5.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2cf3b236&margin=%5Bobject%20Object%5D&originHeight=97&originWidth=400&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=uee33b048-d375-4ee8-9631-875940d2e31&title=)

```javascript
function getLength() {
  return this.data.length;
}
function insertEl(el, index) {
  if (index > this.getLength() || index < 0) {
    throw new Error("插入位置有错");
  } else {
    // 插入操作，需要将从插入位置开始的后续元素，逐个后移
    for (var len = this.getLength(); len >= index; len--) {
      this.data[len] = this.data[len - 1];
    }
    // 后移完成后，直接将所需插入元素，添加到顺序表的相应位置
    this.data[index] = el;
    return this.data;
  }
}
```

---

#### 顺序表删除元素

> 顺序表删除元素步骤：
>
> 1. 找到目标元素
> 1. 将其后续所有元素整体前移 1 个位置

![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649925228200-a68a1447-5263-45dc-a0f2-4ddfd2a0f218.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue0a6f8b0&margin=%5Bobject%20Object%5D&originHeight=237&originWidth=400&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u920639c0-2a72-4cfa-9023-6cf6b012ba6&title=)

```javascript
function removeEl(index) {
  if (index > this.getLength() || index < 0) {
    throw new Error("删除位置有误");
  } else {
    for (var i = index; i < this.getLength() - 1; i++) {
      this.data[i] = this.data[i + 1];
    }
    this.data.length--;
    return this.data;
  }
}
```

优点：

1. 逻辑关系与物理关系一致，不需要为元素之间的逻辑关系新增额外的存储空间
1. 可以快速存取表中任一位置的元素,时间复杂度为 O(1)

缺点：

3. 增删操作需要移动大量元素，时间复杂度为 O(n)

---

### 线性表的链式存储结构(链表)

定义：数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构
特点：随用随申请，因此数据的存储位置是相互分离的
![](https://cdn.nlark.com/yuque/0/2022/gif/115484/1649925965008-8727106d-344d-469f-9a3a-2ef3bae7212f.gif#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=uc2c09f7c&margin=%5Bobject%20Object%5D&originHeight=78&originWidth=350&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87c2bcdd-dde7-4bff-bc92-6bf051ec3c6&title=&width=458.9999694824219)
问题：数据之间的逻辑关系和物理关系不一致，不能获取到数据之间的逻辑关系
解决方法：每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素
![](https://cdn.nlark.com/yuque/0/2022/png/115484/1649926105247-b42415a1-6b71-4709-80f6-a233a3e586a8.png#clientId=u7abc7c1c-1d8a-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue5490e03&margin=%5Bobject%20Object%5D&originHeight=149&originWidth=600&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub1567dc9-0203-4387-9308-d58d375b3ea&title=)
链表节点的构成

一个完整的链表结构：
头指针:一个普通的指针，它的特点是永远指向链表第一个节点的位置,一般用于指明链表的位置，便于后期找到链表并使用表中的数据
节点：![](https://cdn.nlark.com/yuque/0/2022/gif/115484/1649992688733-a2bd58cd-56ca-41cc-9b99-f1758bf5c000.gif#clientId=ubc63128a-d16f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubee91b64&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=220&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud89ed74e-53ed-4a52-bc20-3193a1edc44&title=)
![](https://cdn.nlark.com/yuque/0/2022/gif/115484/1649992935319-253f2463-d831-49e2-9908-8937fe25a20b.gif#clientId=ubc63128a-d16f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5c170e43&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=600&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6bd4294c-47df-42d3-bb30-27bddc886c5&title=)

---

链表初始化：

```javascript
class Node {
  constructor(element) {
    this.element = element; // element 用来保存节点上的数据
    this.next = null; // next 用来保存指向下一节点的指针
  }
}
class LinkedList {
  constructor() {
    // head 节点的 next 属性被初始化为 null，当有新元素插入时，next 会指向新的元素
    this.head = new Node("head");
  }
}
```

#### 链表插入元素

基本步骤：

- 将新节点的 next 指针指向插入位置后的节点；
- 将插入位置前面的节点的 next 指针指向插入节点；
- 链表插入元素必须是先步骤 1，再步骤 2，否则会导致插入位置后面的这部分链表丢失，无法实现步骤 1

![](https://cdn.nlark.com/yuque/0/2022/gif/115484/1649993576131-48e0a46b-7bf2-469f-98f9-c88d19974644.gif#clientId=udb8cc690-cb4c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1db4ba7d&margin=%5Bobject%20Object%5D&originHeight=158&originWidth=600&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=u5e0a3580-3d2e-4439-873c-e185129931f&title=)

```javascript
//遍历链表，查找给定数据
function find(item) {
  var currNode = this.head; // 创建一个新节点
  while (currNode.element != item) {
    // 如果当前节点数据不符合我们要找的节点
    currNode = currNode.next; // 当前节点移动到一下节点
  }
  return currNode;
}
//插入元素
function insert(newElement, item) {
  var newNode = new Node(newElement);
  var current = this.find(item);
  // 向链表插入节点 newNode
  newNode.next = current.next; // 将新节点的 next 指针指向插入位置后的节点 （步骤 1）
  current.next = newNode; // 设置插入位置前的 next 指针指向新节点（步骤2）
}
```

---

#### 链表删除元素

步骤：

- 找到待删除节点前面的节点的直接前驱节点；
- 找到这个节点后，修改它的 next 指针，使其不再指向待删除节点；

![](https://cdn.nlark.com/yuque/0/2022/gif/115484/1649993695203-3385344a-93ec-46e0-8abf-1fecbc2131e6.gif#clientId=udb8cc690-cb4c-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uc66a59a8&margin=%5Bobject%20Object%5D&originHeight=101&originWidth=600&originalType=url∶=1&rotation=0&showTitle=false&status=done&style=none&taskId=uae78868e-5812-4a57-a97a-9898c63e3af&title=)

```javascript
//遍历链表中的元素，检查每一个节点的 直接后继节点 中是否存储着待删除数据。
//如果找到，返回该节点（待删除节点的直接前驱节点
function findPrevious(item) {
  var currNode = this.head;
  while (!(currNode.next == null) && currNode.next.element != item) {
    currNode = currNode.next;
  }
  return currNode;
}
function remove(item) {
  var prevNode = this.findPrevious(item);
  if (!(prevNode.next == null)) {
    prevNode.next = prevNode.next.next;
  }
}
```
