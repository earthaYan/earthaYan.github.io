---
title: 俄罗斯方块
date: 2023-11-10 21:23:58
tags: [游戏开发, python]
categories: python
---

## 初始化 pygame

1. 引入 pygame 包
2. 调用 pygame 的 init 方法进行初始化

```py
import pygame
from pygame.locals import *

pygame.init()
```

2 个 import 的区别是：第二个 import 导出的变量可以直接使用，不需要加包名前缀

## 主循环

1. 使用 set_mode 方法定义一个游戏窗口
2. 使用 while 做一个死循环，使用 udpate 方法不断更新游戏窗口
3. 添加退出机制

```py
pygame.init()
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
```

### pygame.event.get()方法

作用：从事件队列中获取当前所有*挂起的事件*(事件队列中等待处理的事件)，并将其从事件队列中移除
在调用 pygame.event.get() 方法后，事件队列中不再保留这些事件，会被直接清空

## 创建画面

使用 set_mode 方法创建一个游戏窗口

```py
pygame.init()
DISPLAYSURF=pygame.display.set_mode((800,600))
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
```

## 显示图片

1. image.load 方法加载图片
2. get_rect 获取矩形
3. 通过举行对象的 center 属性设置矩形中心点
4. 使用 blit 方法绘制图片

```py
Image=pygame.image.load('../pic/red.png')
Rect=Image.get_rect()
Rect.center=(400,300)
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    pygame.display.update()
```

### get_rect()方法

作用：返回一个与图像大小相匹配的矩形对象，这个矩形可以用来定位、处理碰撞检测等操作
React 对象：包含了图片的位置和大小信息

### blit(image,position)方法

作用：将图像绘制到屏幕上
使用：调用 Surface 对象（比如游戏窗口或者其他画布）的 blit 方法

## 让图片动起来

本质上就是修改矩形对象的中心点

```py
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
```

## 去掉残影

原因：每次渲染并不会清除上一帧的渲染结果
解决方法：每次渲染之前需要填充一次屏幕,可以使用 fill 方法

```py
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.fill((0,0,0))
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
```

## 控制移动

通过获取用户的输入来控制矩形对象的移动

```py
pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
DISPLAYSURF.fill((0,0,0))
DISPLAYSURF.blit(Image,Rect)
pygame.display.update()
```

### get_pressed()方法

作用：获取当前键盘按键状态
返回：一个包含所有按键当前状态的元组，对应的元素值是布尔类型。
原理：元组中的顺序与 pygame 中定义的键盘按键常量一一对应，所以可以通过 press[key]来判断

### Rect.move_ip(x,y)方法

作用：根据矩形对象当前的位置进行相对移动
移动方向：
矩形对象 rect，其初始位置为 (x1, y1)，调用 rect.move_ip(5, 10) 之后，矩形的位置将变为 (x1+5, y1+10)。也就是说，矩形会在水平方向上向右移动 5 个单位，在垂直方向上向下移动 10 个单位

## 增加上下方向移动

其实就是增加`K_UP`和`K_DOWN`的判断

```py
pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
elif pressed[K_UP]:
    Rect.move_ip(0,-1)
elif pressed[K_DOWN]:
    Rect.move_ip(0,1)
```

## 实现方块类

我们在上一步中绘制了一个方块并不断更新屏幕，而游戏是由很多个这样的方块组成的，所以我们可以将其封装成一个 Class。实现方块类主要有 2 个步骤

1. 定义初始化方法\_\_init\_\_,在初始化方法中定义需要的属性
2. 定义方法

首先，一个方块，应该有一个图像 image 用于绘制，然后还需要设置它的位置,即 rect。
其次，他需要一个 update 的更新方法，用于记录方块的运动，最后需要一个 draw 方法进行方块的绘制

```py
class Block(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image=pygame.image.load('../pic/red.png')
        self.rect=self.image.get_rect()
        self.rect.center=(400,300)
    def update(self):
        pressed=pygame.key.get_pressed()
        if pressed[K_LEFT]:
            self.rect.move_ip(-1,0)
        elif pressed[K_RIGHT]:
            self.rect.move_ip(1,0)
        elif pressed[K_UP]:
            self.rect.move_ip(0,-1)
        elif pressed[K_DOWN]:
            self.rect.move_ip(0,1)
    def draw(self,surface):
        surface.blit(self.image,self.rect)
```

### 在主函数中进行调用

1. 新建一个 Block 实例 b
2. 调用 udpate 方法记录运动
3. 调用 draw 方法绘制防窥啊

```py
b=Block()
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    b.update()
    DISPLAYSURF.fill((0,0,0))
    b.draw(DISPLAYSURF)
    pygame.display.update()
```

## 多实例

## 拆分文件

## 逻辑和表现分离

## 组合方块

## 模拟下落

## 框架代码

## 确定游戏主逻辑

## BlockGroup 的多态

## 模拟碰撞

## 控制左右移动

## 控制左右移动速度

## 控制下落速度

## 方块旋转

## 方块消除

## 结束消除

## 失败判定

## 计分规则

## 下个方块
