---
title: 俄罗斯方块
date: 2023-11-10 21:23:58
tags: [游戏开发, python]
categories: python
---

## 初始化 pygame

1. 引入 pygame 包
2. 调用 pygame 的 init 方法进行初始化

```py
import pygame
from pygame.locals import *

pygame.init()
```

2 个 import 的区别是：第二个 import 导出的变量可以直接使用，不需要加包名前缀

## 主循环

1. 使用 set_mode 方法定义一个游戏窗口
2. 使用 while 做一个死循环，使用 udpate 方法不断更新游戏窗口
3. 添加退出机制

```py
pygame.init()
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
```

### pygame.event.get()方法

作用：从事件队列中获取当前所有*挂起的事件*(事件队列中等待处理的事件)，并将其从事件队列中移除
在调用 pygame.event.get() 方法后，事件队列中不再保留这些事件，会被直接清空

## 创建画面

使用 set_mode 方法创建一个游戏窗口

```py
pygame.init()
DISPLAYSURF=pygame.display.set_mode((800,600))
while True:
    for event in pygame.event.get():
        if event.type== QUIT:
            pygame.quit()
            sys.exit()
    pygame.display.update()
```

## 显示图片

1. image.load 方法加载图片
2. get_rect 获取矩形
3. 通过举行对象的 center 属性设置矩形中心点
4. 使用 blit 方法绘制图片

```py
Image=pygame.image.load('../pic/red.png')
Rect=Image.get_rect()
Rect.center=(400,300)
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    pygame.display.update()
```

### get_rect()方法

作用：返回一个与图像大小相匹配的矩形对象，这个矩形可以用来定位、处理碰撞检测等操作
React 对象：包含了图片的位置和大小信息

### blit(image,position)方法

作用：将图像绘制到屏幕上
使用：调用 Surface 对象（比如游戏窗口或者其他画布）的 blit 方法

## 让图片动起来

本质上就是修改矩形对象的中心点

```py
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
```

## 去掉残影

原因：每次渲染并不会清除上一帧的渲染结果
解决方法：每次渲染之前需要填充一次屏幕,可以使用 fill 方法

```py
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    DISPLAYSURF.fill((0,0,0))
    DISPLAYSURF.blit(Image,Rect)
    Rect.centerx +=random.randint(-1,1)
    pygame.display.update()
```

## 控制移动

通过获取用户的输入来控制矩形对象的移动

```py
pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
DISPLAYSURF.fill((0,0,0))
DISPLAYSURF.blit(Image,Rect)
pygame.display.update()
```

### get_pressed()方法

作用：获取当前键盘按键状态
返回：一个包含所有按键当前状态的元组，对应的元素值是布尔类型。
原理：元组中的顺序与 pygame 中定义的键盘按键常量一一对应，所以可以通过 press[key]来判断

### Rect.move_ip(x,y)方法

作用：根据矩形对象当前的位置进行相对移动
移动方向：
矩形对象 rect，其初始位置为 (x1, y1)，调用 rect.move_ip(5, 10) 之后，矩形的位置将变为 (x1+5, y1+10)。也就是说，矩形会在水平方向上向右移动 5 个单位，在垂直方向上向下移动 10 个单位

## 增加上下方向移动

其实就是增加`K_UP`和`K_DOWN`的判断

```py
pressed=pygame.key.get_pressed()
if pressed[K_LEFT]:
    Rect.move_ip(-1,0)
elif pressed[K_RIGHT]:
    Rect.move_ip(1,0)
elif pressed[K_UP]:
    Rect.move_ip(0,-1)
elif pressed[K_DOWN]:
    Rect.move_ip(0,1)
```

## 实现方块类

我们在上一步中绘制了一个方块并不断更新屏幕，而游戏是由很多个这样的方块组成的，所以我们可以将其封装成一个 Class。实现方块类主要有 2 个步骤

1. 定义初始化方法\_\_init\_\_,在初始化方法中定义需要的属性
2. 定义方法

首先，一个方块，应该有一个图像 image 用于绘制，然后还需要设置它的位置,即 rect。
其次，他需要一个 update 的更新方法，用于记录方块的运动，最后需要一个 draw 方法进行方块的绘制

```py
class Block(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image=pygame.image.load('../pic/red.png')
        self.rect=self.image.get_rect()
        self.rect.center=(400,300)
    def update(self):
        pressed=pygame.key.get_pressed()
        if pressed[K_LEFT]:
            self.rect.move_ip(-1,0)
        elif pressed[K_RIGHT]:
            self.rect.move_ip(1,0)
        elif pressed[K_UP]:
            self.rect.move_ip(0,-1)
        elif pressed[K_DOWN]:
            self.rect.move_ip(0,1)
    def draw(self,surface):
        surface.blit(self.image,self.rect)
```

### 在主函数中进行调用

1. 新建一个 Block 实例 b
2. 调用 udpate 方法记录运动
3. 调用 draw 方法绘制防窥啊

```py
b=Block()
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    b.update()
    DISPLAYSURF.fill((0,0,0))
    b.draw(DISPLAYSURF)
    pygame.display.update()
```

## 多实例

多实例即需要使用不一样的图片和位置初始化 block 实例。所以可以将方块图片和位置作为 init 函数的参数

```py
class BlockType:
    RED=0
    ORANGE=1
    YELLOW=2
    GREEN=3
    CYAN=4
    BLUE=5
    PURPLE=6
    BLOCKMAX=7

BLOCK_RES={
    BlockType.RED:'../pic/red.png',
    BlockType.ORANGE:'../pic/orange.png',
    BlockType.YELLOW:'../pic/yellow.png',
    BlockType.GREEN:'../pic/green.png',
    BlockType.CYAN:'../pic/cyan.png',
    BlockType.BLUE:'../pic/blue.png',
    BlockType.PURPLE:'../pic/purple.png',
}
class Block(pygame.sprite.Sprite):
    def __init__(self,blockType,pos):
        super().__init__()
        self.image=pygame.image.load(BLOCK_RES[blockType])
        self.rect=self.image.get_rect()
        self.rect.center=pos
```

## 拆分文件

到上一步之后，目前的 main.py 代码行数已经较多，且 Block 类作为一个独立的类可以拆分到 block.py，项目中的常量可以拆分到 const.py

## 逻辑和表现分离

希望可以根据方块类下、行/列坐标、宽/高以及相对位置来实现多态。根据传参来确定使用哪张图片、实际尺寸以及确定位置

```py
# block.py
def __init__(self,blockType,rowIdx,colIdx,width,height,relPos):
    super().__init__()
    self.blockType=blockType
    self.rowIdx=rowIdx
    self.colIdx=colIdx
    self.width=width
    self.height=height
    self.relPos=relPos
    self.loadImage()
    self.updateImagePos()
def loadImage(self):
    self.image=pygame.image.load(BLOCK_RES[self.blockType])
    self.image=pygame.transform.scale(self.image,(self.width,self.height))
def updateImagePos(self):
    self.rect=self.image.get_rect()
    self.rect.left=self.relPos[0]+self.width*self.colIdx
    self.rect.top=self.relPos[1]+self.height*self.rowIdx
```

### transform.scale()

作用：缩放图像
语法：`pygame.transform.scale(Surface, (width, height))`

### 生成多个方块

```py
blcoks=[]
for i in range(GAME_ROW):
    b=[]
    for j in range(GAME_COL):
        currentBlock=Block(random.randint(0,BLEND_MAX),i,j,32,32,(240,50))
        b.append(currentBlock)
    blcoks.append(b)
```

最终生成是数据如下(假设 GAME_ROW 为 3，GAME_COL 为 2)：

```JS
[
    [Block(0, 0), Block(1, 0)],
    [Block(0, 1), Block(1, 1)],
    [Block(0, 2), Block(1, 2)]
]

```

### 主流程渲染方块

```py
while True:
    for event in pygame.event.get():
        if event.type == QUIT:
            pygame.quit()
            sys.exit()
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].update()
    DISPLAYSURF.fill((0,0,0))
    for i in range(GAME_ROW):
        for j in range(GAME_COL):
            blcoks[i][j].draw(DISPLAYSURF)
    pygame.display.update()
```

### relPos

relPos 指的是左上方方块的矩形对象位置

## 组合方块

常见方块形状：
{%asset_img block.png%}
坐标含义：
每个元组 (x, y) 表示一个方块相对于参考点（通常是旋转中心）的偏移量。例如，(0, 0) 表示方块当前位置，(0, 1) 表示向上移动一个单位，(1, 0) 表示向右移动一个单位，以此类推。

```py
BLOCK_SHAPE=[
    [(0,0),(0,1),(1,0),(1,1)], #方形
    [(0,0),(0,1),(0,2),(0,3)], #长条
    [(0,0),(0,1),(1,1),(1,2)], #z字形
    [(0,1),(1,0),(1,1),(1,2)]  #飞机形
]
```

## 模拟下落

## 框架代码

## 确定游戏主逻辑

## BlockGroup 的多态

## 模拟碰撞

## 控制左右移动

## 控制左右移动速度

## 控制下落速度

## 方块旋转

## 方块消除

## 结束消除

## 失败判定

## 计分规则

## 下个方块
