---
title: 如何开发一个自己的前端脚手架
date: 2023-06-21 14:47:47
tags: [脚手架,GoLang]
categories: 后端
---

## 脚手架的作用

1. 开发新的项目的时候，有时候有一些以前用过的项目架构或者一些配置可以通用，但是单纯的`ctrlC`+`ctrlV`，可能会导致一些问题，比如：代码粘贴遗漏，package.json 某些依赖的版本难以管理。通过将其封装成模板可以避免这种情况。
2. 开发中可能会使用不同的技术，比如 vue,react,angular 等框架，每个技术框架可以积攒自己的模板工程，有了脚手架可以通过不同模板快速搭建一个新的项目

## 基本功能

1. 有一个创建项目的命令
2. 用户进行交互式选择相关配置

   - 模板
   - tag

3. 根据用户的选择生成用户需要的项目文件

## 工具库

```json
{
  "axios": "^0.26.1",
  "chalk": "^4.0.0",
  "commander": "^9.0.0",
  "download-git-repo": "^3.0.2",
  "figlet": "^1.5.2",
  "fs-extra": "^10.0.1",
  "gitee-repo": "^0.0.2",
  "inquirer": "^8.2.1",
  "ora": "^5.0.0"
}
```

## 源码实现

### 脚手架模板的两种方法

1. 托管到 github

   - 代码体积小
   - 可以选择 tag

2. 本地新建一个 template 工程

   - 不需要从 github 下载模板代码
   - 代码体积大
   - 自由度不高

### 主要过程

#### 初始化项目

执行`npm init`

#### 创建入口文件 /bin/entry

```bash
#! /usr/bin/env node
require('../index.js')
```

> `#!`是一个约定的标记，告诉系统需要用什么解释器来执行这个 shell 脚本，就是指使用哪一种 shell。比如上述代码指的就是当前的脚本需要通过 nodejs 来执行。

#### 在 package.json 中配置 bin 配置项

作用：使得包以 name 属性的值当做命令，比如此时就是`sun`

```json
{ "name": "sun", "bin": "bin/entry" }
```

> bin 字段是**命令名到本地文件名的映射**。在安装时，npm 会将文件符号链接到 prefix/bin 以进行全局安装或./node_modules/.bin/本地安装。

使用 npm 或者 yarn 命令安装包，如果该包的 package.json 有 bin 字段，就会在 node_modules 文件夹下面的.bin 目录中复制了 bin 字段链接的执行文件。我们在调用执行文件时，可以不带路径，直接使用命令名来执行相应的执行文件。

#### 使用 npm link 进行测试

执行`npm link`后，在命令行执行`sun`,可以看到控制台输出

> npm link 作用：将包的 bin 文件链接到 node 全局

或者直接将包安装到全局： `yarn add 包名 -g`

#### 创建真正的程序入口文件/index.js

#### 安装对应依赖

### 源码解析

#### index.js 文件

主要作用：定义和添加 create 命令

```javascript
const program = require('commander');

program.name('sun').usage(`<command>[option]`).version('1.0.0');
program
  .command('create <project-name>') //添加create指令
  .description('create a new project') //添加指令描述
  .option('-f,--force', 'overwrite target dir if it exists') //强制覆盖
  .action((projectName, cmd) => {
    // 处理用户输入create 指令附加的参数
    console.log(projectName, cmd);
    require('./lib/create')(projectName, cmd);
  });
program.parse(process.argv);
```

#### /lib/create 文件

主要作用：执行创建命令的逻辑

1. 如果当前项目路径已存在，则进行判断是否需要删除当前项目目录
2. 执行 create 逻辑

```javascript
const path = require('path');
const fs = require('fs-extra');
const Inquirer = require('inquirer');
const loading = require('./util');
const Creator = require('./creator');
module.exports = async function (projectName, options) {
  // 获取当前目录
  const cwd = process.cwd();
  const targetDir = path.join(cwd, projectName);
  // 如果当前已存在同名目录
  if (fs.existsSync(targetDir)) {
    if (!!options.force) {
      // 使用的--force 强制执行参数
      // 删除重名目录
      await fs.remove(targetDir);
    } else {
      // 未使用--force:是否重写同名目录
      let { isOverwrite } = await new Inquirer.prompt([
        {
          name: 'isOverwrite', //与返回值对应
          type: 'list',
          message: 'target dir exists,please choose an action',
          choices: [
            { name: 'Overwrite', value: true },
            { name: 'Cancel', value: false },
          ],
        },
      ]);
      // 不重写
      if (!isOverwrite) {
        console.log('cancel');
        return;
      } else {
        // 重写
        await loading(
          `Removing ${projectName} ,please wait a moment`,
          fs.remove,
          targetDir
        );
      }
    }
  }
  // 创建项目
  const creator = new Creator(projectName, targetDir);
  creator.create();
};
```
#### /lib/creator.js
主要作用：获取用户选择的模板信息并下载对应的模板
```javascript
const downloadGitRepo = require('gitee-repo')
const util = require('util');
const path = require('path')
const { loading } = require('./util')
const { getTagsByRepo, getZhuRongRepo } = require('./api')
const chalk = require('chalk')
const Inquirer = require('inquirer')
class Creator {
  constructor(name, target) {
    this.name = name
    this.target = target
    // 转化为promise方法
    this.downloadGitRepo = util.promisify(downloadGitRepo)
  }
  // 创建项目
  async create() {
    // 仓库信息——模板信息
    let repo = await this.getRepoInfo()
    // 标签信息——版本信息
    let tag = await this.getTagInfo(repo)
    // 下载模板
    await this.download(repo, tag)
    // 模板使用提示
    console.log(`\r\nSuccessfully created project ${chalk.cyan(this.name)}`)
    console.log(`\r\n cd ${chalk.cyan(this.name)}`)
    console.log(' npm install')
    console.log(' npm run serve\r\n')
  }
  async getRepoInfo() {
    // 获取组织下的仓库信息
    let repoList = await loading('waiting for fetching template', getZhuRongRepo)
    if (!repoList) return
    // 提取仓库名
    const repoNames = repoList.map(item => item.name)
    // 选取模板信息
    let { repo } = await new Inquirer.prompt([{
      name: 'repo',
      type: 'list',
      message: 'pls choose a template for creating project',
      choices: repoNames
    }])
    return repo
  }
  async getTagInfo(repo) {
    // 获取tag信息
    let tagList = await loading('waiting for fetching version', getTagsByRepo, repo)
    if (!tagList) return
    const tagNames = tagList.map(item => item.name)
    let { tag } = await new Inquirer.prompt([{
      name: 'tag',
      type: 'list',
      message: 'pls choose version for creating project',
      choices: tagNames
    }])
    return tag
  }
  async download(repo, tag) {
    // 模板下载地址
    const templateUrl = `gitee:wanghy07/${repo}${tag ? ("#" + tag) : ""}`
    // 调用downloadGitRepo方法将对应模板下载到指定目录
    await loading(
      "downloading template,pls wait",
      this.downloadGitRepo,
      templateUrl,
      path.resolve(process.cwd(), this.target) //项目创建位置
    )
  }
}
module.exports = Creator
```

除此以外还有一些工具函数，比如loading等等。。。