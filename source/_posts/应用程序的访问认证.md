---
title: 应用程序的访问认证
date: 2023-02-22 15:00:44
tags: [GoLang]
categories: 后端
---

## 认证和授权

- 认证(Authentication,authn):验证某个用户是否具有访问系统的权限->who r u
- 授权(Authorization,authz):验证某个用户是否具有访问某个资源的权限-> what can u do

  {% asset_img authz_authn.webp %}

## 四种基本的认证方式

### Basic:

1. 前端将`用户名:密码`通过 base64 编码后，放入 HTTP Authorization Header
2. 后端服务解析通过将接收到的字符串解码获取用户名和密码
3. 后端将用户名和密码跟数据库中的值进行比较确认是否通过认证

```go
basic=`echo -n 'admin:Admin@2021'|base64`
curl -XPOST -H"Authorization: Basic ${basic}" http://127.0.0.1:8080/login
```

总结：Basic 认证简单但不安全,需要和 SSL 配合使用，保证认证过程的安全性

### Digest

{%asset_img digest.webp %}

1. 客户端请求服务端的资源
2. 在客户端能够证明它知道密码从而确认其身份之前，服务端认证失败，返回 401 Unauthorized，并返回 WWW-Authenticate 头，里面包含认证需要的信息
3. 客户端根据 WWW-Authenticate 头中的信息，选择加密算法，并使用密码随机数 nonce，计算出密码摘要 response，并再次请求服务端
4. 服务器将客户端提供的密码摘要与服务器内部计算出的摘要进行对比。如果匹配，就说明客户端知道密码，认证通过，并返回一些与授权会话相关的附加信息，放在 Authorization-Info 中。
   {%asset_img WWW-Authenticate.webp%}

### OAuth2.0

开放授权，在不需要用户提供用户名和密码给第三方的情况下，允许第三方访问该用户在某一 Web 服务上存储的私密资源

#### 隐藏式，适用于前端

1. 网站提供一个跳转到 B 网站的链接，用户点击后跳转至 B 网站，并向用户请求授权
2. 用户登录 B 网站，同意授权后，跳转回 A 网站指定的重定向 redirect_url 地址，并携带 B 网站返回的令牌，用户在 B 网站的数据给 A 网站使用

#### 凭借式,适用于没有前端的命令行应用

1. 应用 A 在命令行向应用 B 请求授权，此时应用 A 需要携带应用 B 提前颁发的 secretID 和 secretKey，其中 secretKey 出于安全性考虑，需在后端发送；
2. 应用 B 接收到 secretID 和 secretKey，并进行身份验证，验证通过后返回给应用 A 令牌。

### Bearer

令牌认证，核心是`bearer token`，它是由服务端根据密钥生成的加密字符串。
需要和 HTTPS 一起使用，保证认证安全性
主流 token 编码方式：JWT(JSON Web Token)

1. 客户端发出请求的时候，必须在请求头中包含 `Authorization: Bearer`
2. 服务端收到请求后，解析 token 并校验其合法性，确认是否认证通过

## JWT 认证

### 背景业务场景：

为了区分用户和保证安全，必须对 API 请求进行鉴权，但是不能要求每一个请求都进行登录操作。所以需要：

1. 第一次登录之后产生一个有一定有效期的 token，并将它存储在浏览器的 Cookie 或 LocalStorage 之中。
2. 之后的请求都携带这个 token ，请求到达服务器端后，服务器端用这个 token 对请求进行认证。
3. 在第一次登录之后，服务器会将这个 token 用文件、数据库或缓存服务器等方法存下来，用于之后请求中的比对。

### 优点：

1. 不需要在服务端存储用户数据，减轻服务端压力
2. 采用 JSON 数据格式，比较易读
3. 跨语言，轻量级

### 步骤

{%asset_img jwt.webp %}

1. 客户端使用用户名和密码请求登录
2. 服务端收到请求后，会去验证用户名和密码。如果用户名和密码跟数据库记录不一致，则验证失败；如果一致则验证通过，服务端会签发一个 Token 返回给客户端
3. 客户端收到请求后会将 Token 缓存起来，比如放在浏览器 Cookie 中或者 LocalStorage 中，之后每次请求都会携带该 Token
4. 服务端收到请求后，会验证请求中的 Token，验证通过则进行业务逻辑处理，处理完后返回处理后的结果

### token 的组成

JWT=`Header 的 base64 编码`.`Payload 的 base64 编码`.`Signature`
` eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NDI4NTY2MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2MzUwODA2MzcsInN1YiI6ImFkbWluIn0.Shw27RKENE_2MVBq7-c8OmgYdF92UmdwS8xE-Fts2FM`

#### Header

```json
{
  "typ": "JWT",
  "alg": "HS256",
  "kid": "XhbY3aCrfjdYcP1OFJRu9xcno8JzSbUIvGE2" //非必选，标识密钥id
}
// 编码->echo -n '{"typ":"JWT","alg":"HS256"}'|base64->eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```

#### Payload

Payload=JWT 标准中注册的声明(可选)+公共的声明+私有的声明
{% asset_img jwt_declare.webp JWT标准中注册的声明部分%}

#### 签名

生成方式：

1. 将 Header 和 Payload 分别 base64 编码后，用 . 连接
2. 使用 Header 中声明的加密方式，利用 secretKey 对连接后的字符串进行加密
3. 加密后的字符串即签名
