---
title: 开发一个网页版的简历生成器系列-3
date: 2023-08-03 17:07:36
tags: [实践]
categories: 实践
---

## 用户管理模块

### 注册

### 登录

### 知识点

#### vue3 中使用 TypeScript(以 VSCODE 为例)

1. 卸载或禁用 Vscode 插件 Vetur
2. 安装 volar(Vue Language Features (Volar))
3. 安装 TypeScript Vue Plugin (Volar)
4. 配置 tsconfig.json
5. 组合式可参考[TypeScript 与组合式 API](https://cn.vuejs.org/guide/typescript/composition-api.html)

#### vue3 中 router 配置和 RouterLink 怎么匹配的

Vue Router 中的路由配置和 RouterLink 的匹配是通过路径和组件的映射关系来实现的。

1. 在路由配置中,我们通过 routes 数组来定义路由路径和组件的映射关系,如下所示，把路径'/user'和 User 组件做了映射

```javascript
const routes = [
  {
    path: '/user',
    component: User,
  },
];
```

2. 在模板中,我们通过<RouterLink>组件来生成链接,指定 to 属性为需要跳转的路径

```vue
<RouterLink to="/user">User</RouterLink>
```

3. 当点击该链接时,Vue Router 会拦截跳转,根据当前的路径'/user'找到匹配的路由配置,然后动态渲染对应的组件(这里是 User 组件)
4. 通过路径的匹配,Vue Router 完成了路由配置和 RouterLink 的关联,从而实现了组件的切换和渲染

> 总结：RouterLink 提供导航功能,路由配置定义了路径和组件的映射,两者结合可以实现 SPA 的路由与组件切换

#### 如果有多个菜单时，如何避免手写多个 RouterLink

不需要，Vue Router 提供了动态生成 RouterLink 的方式,避免了需要写多个 RouterLink 的问题。常见方式有：

1. 使用 v-for 循环 routes 数组

```vue
<div v-for="route in routes">
  <RouterLink :to="route.path">{{route.name}}</RouterLink> 
</div>
```

2. 将 routes 数组映射成菜单组件

```javascript
const menuItems = routes.map((item) => {
  return {
    path: item.path,
    label: item.name,
  };
});
```

```javascript
<Menu :items="menuItems" />
<!-- Menu组件 -->

{/* Menu组件内部 */}
props: ['items'],
render() {
  return this.items.map(item => {
    return <RouterLink to={item.path}>{item.label}</RouterLink>
  })
}

```

3. 使用 render 函数动态生成:

```javascript
render(h) {
  return routes.map(item => {
    return h('RouterLink', {
      attrs: {
        to: item.path
      }
    }, item.name)
  })
}
```

#### vue3 中如何使用 css 预处理器（以 less 为例）

1. 安装 `yarn add -D less`
2. 如果使用的是单文件组件，可以通过 `<style lang="less">` 自动开启

#### TypeScript 报错

问题描述：在 `views` 文件夹下新建 `*.vue` 文件，并添加到路由配置中，但是路由配置文件中组件导入一直报错如下，且每次重启 vscode 后该报错会自动消失。

> File 'd:/private/frontend/resume-generator/src/views/TestView.vue' is not listed within the file list of project 'd:/private/frontend/resume-generator/tsconfig.vitest.json'. Projects must list all files or use an 'include' pattern.ts(6307)

```json
//tsconfig.json
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.node.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.vitest.json"
    }
  ]
}
```

```json
//tsconfig.node.json
{
  "extends": "@tsconfig/node18/tsconfig.json",
  "include": [
    "vite.config.*",
    "vitest.config.*",
    "cypress.config.*",
    "nightwatch.conf.*",
    "playwright.config.*"
  ],
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "types": ["node"]
  }
}
```

```json
//tsconfig.app.json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": ["env.d.ts", "src/**/*", "src/**/*.vue"],
  "exclude": ["src/**/__tests__/*"],
  "compilerOptions": {
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "isolatedModules": true
  }
}
```

```json
//tsconfig.vitest.json
{
  "extends": "./tsconfig.app.json",
  "exclude": [],
  "compilerOptions": {
    "composite": true,
    "lib": [],
    "types": ["node", "jsdom"]
  }
}
```

```js
//router/index.ts
import {
  createRouter,
  createWebHistory,
  type RouteRecordRaw,
} from 'vue-router';
import HomeView from '../views/HomeView.vue';
import RegisterLoginView from '../views/RegisterLoginView.vue';

export const routes: RouteRecordRaw[] = [
  {
    path: '/',
    name: 'home',
    component: HomeView,
  },
  {
    path: '/sign',
    name: 'sign',
    component: RegisterLoginView,
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (About.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import('../views/AboutView.vue'),
  },
  {
    path: '/test',
    name: 'test',
    component: () => import('../views/TestView.vue'),
  },
];
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes,
});

export default router;
```

网上搜了一下很多都说是 tsconfig 的配置有问题，还有就是增加一个全局的[类型定义文件](https://segmentfault.com/q/1010000040178399),但是尝试以后发现都不起作用。然后想起了当时看 vue 官方文档关于 TypeScript 章节的时候有个一闪而过的 take over 模式，按照文档尝试开启了 volar take over 模式，果然报错消失了。

原理：为了让 Vue 单文件组件和 TypeScript 一起工作，Volar 创建了一个针对 Vue 的 TS 语言服务实例，将其用于 Vue 单文件组件。同时，**普通的 TS 文件依然由 VSCode 内置的 TS 语言服务来处理**。

开启：

1. `ctrl+shift+p` 唤起命令面板
2. 输入 `built`，选择 “Extensions：Show Built-in Extensions”
3. 在插件搜索框内输入 typescript (不要删除 @builtin 前缀)
4. 点击“TypeScript and JavaScript Language Features”右下角的小齿轮，然后选择“Disable (Workspace)”。
5. 重新加载工作空间
