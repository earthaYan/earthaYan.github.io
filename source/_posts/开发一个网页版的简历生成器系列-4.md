---
title: 开发一个网页版的简历生成器系列-4
date: 2023-08-22 14:20:03
tags: [实践]
categories: 实践
---

## 后端

后端尝试使用了 MVC 架构
├─controllers
│ └─resumeController
├─docs
├─models
├─repositories
└─router

- Model 层:定义表示数据库实体的 Go 结构体
- Controller 层:处理业务逻辑，处理请求逻辑,与 Model、Repository 层交互。直接返回 JSON 格式数据给前端
- Repositories 层：基于 Model 操作数据库,使用 database/sql 直接执行 SQL 查询,并手动转换结果到 Model 对象。

### main.go

```go
	// 初始化数据库
	repositories.InitMysql()
	// 初始化gin
	r := gin.Default()
	router := r.Group("/api")
	ReadRouters(router)
	docs.SwaggerInfo.BasePath = "/"
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))
	r.Run(":3000")
```

读取 router 下的路由组

```go
// ReadRouters 读取router下的路由组
func ReadRouters(g *gin.RouterGroup) {
  routes := router.Router{}
  val := reflect.ValueOf(routes)
  // 获取到该结构体有多少个方法
  numOfMethod := val.NumMethod()
  for i := 0; i < numOfMethod; i++ {
    // 断言特定类型的方法
    fn, ok := val.Method(i).Interface().(func(g *gin.RouterGroup))
    if !ok {
      continue
    }
    fn(g)
  }
}
```

resume 模块

```go
func (r Router) Resume(g *gin.RouterGroup) {
	rg := g.Group("/resume")
	{
		// 查看简历列表
		rg.GET("/list", resumeController.GetResumeList)
		// 查询简历详情
		rg.GET("/:id", resumeController.GetSingleResume)
		// 添加简历
		rg.POST("/add", resumeController.CreateResume)
		// 修改简历
		rg.POST("/update", resumeController.UpdateResume)
		// 删除简历
		rg.DELETE("/:id", resumeController.DeleteResume)
	}
}
```

上面这些功能的具体实现逻辑都放在 Controller 层

如何构建一个简单的 REST API https://blog.techchee.com/build-a-rest-api-with-golang-gin-and-mysql/

reflect 反射-待补充 https://juejin.cn/post/6844903559335526407

### database/sql 包

连接数据库：

```go
var db *sql.DB
var err error

func InitMysql() {
	dsn := db_user + ":" + db_pwd + "@tcp(116.204.108.126:3306)/resume"
	db, err = sql.Open("mysql", dsn)
	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
}
```

## gin

### 特点

1. 快速，占内存少，API 性能可预测
2. 支持中间件：请求可以由一系列中间件和最终操作来处理

```go
// 全局中间件
r.Use(gin.Logger())
// 单个路由支持任意数量的中间件。
r.GET("/benchmark", MyBenchLogger(), benchEndpoint)
// 认证中间件
authorized := r.Group("/", AuthRequired())
// 路由组中间件
authorized := r.Group("/")
authorized.Use(AuthRequired())
{
	//路由
}
```

3. crash 处理：可以 catch 一个发生在 HTTP 请求中的 panic 并 recover 它，保证服务器始终可用
4. json 验证：解析并验证请求的 JSON
5. 路由组：不同版本的 API 分组，授权分组，可以无限嵌套
6. 错误管理：收集 HTTP 请求期间发生的所有错误，中间件最终将这些错误写入日志文件、数据库
7. 内置渲染：为 JSON，XML 和 HTML 渲染提供了易于使用的 API
8. 可扩展性高

### 安装

```bash
go get -u github.com/gin-gonic/gin
import "github.com/gin-gonic/gin"
```

### c.AsciiJSON

作用：生成只包含 ASCII 字符的 JSON 格式数据，对于非 ASCII 字符会进行转义

```go
// 原数据
data := map[string]interface{}{
	"lang": "GO语言",
	"tag":  "<br>",
}
c.AsciiJSON(http.StatusOK, data)
// 结果 {"lang":"GO\u8bed\u8a00","tag":"\u003cbr\u003e"}
```

### c.LoadHTMLGlob 或者 c.LoadHTMLFiles

作用：渲染 HTML

```go
router.LoadHTMLGlob("templates/*")
router.LoadHTMLFiles("templates/template1.html", "templates/template2.html")//二选一
router.GET("/index", func(c *gin.Context) {
	c.HTML(http.StatusOK, "index.tmpl", gin.H{
		"title": "Main website",
	})
})
```

模板 templates/index.tmpl

```html
<html>
  <h1>{{ .title }}</h1>
</html>
```

### 绑定 Multipart/Urlencoded

```go
type LoginForm struct {
	User     string `form:"user" binding:"required"`
	Password string `form:"password" binding:"required"`
}
```

```go
var form LoginForm
// 显式绑定multipart form：
c.ShouldBindWith(&form, binding.Form)
// 自动绑定，自动选择合适的绑定
c.ShouldBind(&form, binding.Form)
if c.ShouldBind(&form) == nil {
	if form.User == "user" && form.Password == "password" {
		c.JSON(200, gin.H{"status": "you are logged in"})
	} else {
		c.JSON(401, gin.H{"status": "unauthorized"})
	}
}
// $ curl -v --form user=user --form password=password http://localhost:8080/login
```

### Multipart/Urlencoded 表单

```go
message := c.PostForm("message")
nick := c.DefaultPostForm("nick", "anonymous")
c.JSON(200, gin.H{
	"status":  "posted",
	"message": message,
	"nick":    nick,
})
```

### c.PureJSON

作用：按字面功能对特殊 html 字符进行编码

```go
// 提供unicode实体:非html内容
r.GET("/json", func(c *gin.Context) {
	c.JSON(200, gin.H{
		"html": "<b>Hello, world!</b>",
	})
})
// 提供字面字符
r.GET("/purejson", func(c *gin.Context) {
	c.PureJSON(200, gin.H{
		"html": "<b>Hello, world!</b>",
	})
})
```

### 上传单个文件

```go
//  multipart forms 设置较低的内存限制 (默认是 32 MiB)
router.MaxMultipartMemory = 8 << 20  // 8 MiB
// 单文件
file, _ := c.FormFile("file")
log.Println(file.Filename)
dst := "./" + file.Filename
// 上传文件至指定的完整文件路径
c.SaveUploadedFile(file, dst)

c.String(http.StatusOK, fmt.Sprintf("'%s' uploaded!", file.Filename))
// curl -X POST http://localhost:8080/upload \
//   -F "file=@/Users/appleboy/test.zip" \
//   -H "Content-Type: multipart/form-data"
```

### 不使用默认中间件

r=gin.New() //不使用
r := gin.Default() //使用 Logger 和 Recovery 中间件

### 绑定 url 查询字符串

作用：自动忽略 post 数据

```go
type Person struct {
	Name    string `form:"name"`
	Address string `form:"address"`
}
route.Any("/testing", startPage)
func startPage(c *gin.Context) {
	var person Person
	if c.ShouldBindQuery(&person) == nil {
		log.Println("====== Only Bind By Query String ======")
		log.Println(person.Name)
		log.Println(person.Address)
	}
	c.String(200, "Success")
}

```

### 记录日志

```go
// 记录到文件
f, _ := os.Create("gin.log")
gin.DefaultWriter = io.MultiWriter(f)
// 同时记录到文件和控制台
gin.DefaultWriter = io.MultiWriter(f, os.Stdout)
```

### c.shouldBind

作用：绑定 request body 到不同的结构体中，不能多次调用
Query, Form, FormPost, FormMultipart 可以多次调用 c.ShouldBind()

```go
type formA struct {
  Foo string `json:"foo" xml:"foo" binding:"required"`
}

type formB struct {
  Bar string `json:"bar" xml:"bar" binding:"required"`
}
objA := formA{}
objB := formB{}
// c.ShouldBind 使用了 c.Request.Body，不可重用。
if errA := c.ShouldBind(&objA); errA == nil {
	c.String(http.StatusOK, `the body should be formA`)
	// 因为现在 c.Request.Body 是 EOF，所以这里会报错。
} else if errB := c.ShouldBind(&objB); errB == nil {
	c.String(http.StatusOK, `the body should be formB`)
} else {
// 其他
}
```

多次绑定:c.ShouldBindBodyWith

```go
 objA := formA{}
objB := formB{}
// 读取 c.Request.Body 并将结果存入上下文。
if errA := c.ShouldBindBodyWith(&objA, binding.JSON); errA == nil {
 c.String(http.StatusOK, `the body should be formA`)
 // 这时, 复用存储在上下文中的 body。
} else if errB := c.ShouldBindBodyWith(&objB, binding.JSON); errB == nil {
 c.String(http.StatusOK, `the body should be formB JSON`)
 // 可以接受其他格式
} else if errB2 := c.ShouldBindBodyWith(&objB, binding.XML); errB2 == nil {
  c.String(http.StatusOK, `the body should be formB XML`)
} else {
// xxx
}
```

### c.QueryMap/c.PostFormMap

映射查询字符串或表单参数

```go
// POST /post?ids[a]=1234&ids[b]=hello HTTP/1.1
// Content-Type: application/x-www-form-urlencoded
ids := c.QueryMap("ids")
names := c.PostFormMap("names")
fmt.Printf("ids: %v; names: %v", ids, names)
// ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou]
```

### c.DefaultQuery/c.Query

作用：查询字符串参数

```go
// 使用现有的基础请求对象解析查询字符串参数。
// /welcome?firstname=Jane&lastname=Doe
firstname := c.DefaultQuery("firstname", "Guest")
lastname := c.Query("lastname") // c.Request.URL.Query().Get("lastname") 的一种快捷方式
c.String(http.StatusOK, "Hello %s %s", firstname, lastname)
```

### 绑定结构体

作用：使用模型绑定将请求体绑定到结构体中
使用时，需要在要绑定的所有字段上，设置相应的 tag。 例如，使用 JSON 绑定时，设置字段标签为 json:"fieldname"。

#### must bind

Bind, BindJSON, BindXML, BindQuery, BindYAML
过程：如果发生绑定错误，则请求终止，并触发 c.AbortWithError(400, err).SetType(ErrorTypeBind)。响应状态码被设置为 400 并且 Content-Type 被设置为 text/plain;

#### should bind

ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery,ShouldBindYAML
过程：如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求。

【注意】：使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定，如果明确知道要绑定什么，可以使用 MustBindWith 或 ShouldBindWith。

```go
// 绑定 JSON
type Login struct {
	// binding:"required"指定必须绑定的字段,如果
	User     string `form:"user" json:"user" xml:"user"  binding:"required"`
	Password string `form:"password" json:"password" xml:"password" binding:"required"`
}
// 绑定 JSON ({"user": "manu", "password": "123"})
var json Login
if err := c.ShouldBindJSON(&json); err != nil {
	c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	return
}

if json.User != "manu" || json.Password != "123" {
	c.JSON(http.StatusUnauthorized, gin.H{"status": "unauthorized"})
	return
}

c.JSON(http.StatusOK, gin.H{"status": "you are logged in"})
```

### c.ShouldBindUri

作用：绑定 uri

```go
type Person struct {
	ID   string `uri:"id" binding:"required,uuid"`
	Name string `uri:"name" binding:"required"`
}
route.GET("/:name/:id", func(c *gin.Context) {
	var person Person
	if err := c.ShouldBindUri(&person); err != nil {
		c.JSON(400, gin.H{"msg": err.Error()})
		return
	}
	c.JSON(200, gin.H{"name": person.Name, "uuid": person.ID})
})
// $ curl -v localhost:8088/thinkerou/not-uuid
```

### c.ShouldBind

作用：绑定查询字符串或表单数据

```go
type Person struct {
	Name     string    `form:"name"`
	Address  string    `form:"address"`
	Birthday time.Time `form:"birthday" time_format:"2006-01-02" time_utc:"1"`
}
// 如果是 `GET` 请求，只使用 `Form` 绑定引擎（`query`）。
// 如果是 `POST` 请求，首先检查 `content-type` 是否为 `JSON` 或 `XML`，然后再使用 `Form`（`form-data`）。
if c.ShouldBind(&person) == nil {
	log.Println(person.Name)
	log.Println(person.Address)
	log.Println(person.Birthday)
}
```

### 绑定数据到自定义结构体

```go
type StructA struct {
    FieldA string `form:"field_a"`
}

type StructB struct {
    NestedStruct StructA
    FieldB string `form:"field_b"`
}
func GetDataB(c *gin.Context) {
    var b StructB
    c.Bind(&b)
    c.JSON(200, gin.H{
        "a": b.NestedStruct,
        "b": b.FieldB,
    })
}
```

### 自定义验证器

```go
import (
	"net/http"
	"reflect"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/validator/v10"
)
// Booking 包含绑定和验证的数据。
type Booking struct {
	CheckIn  time.Time `form:"check_in" binding:"required,bookabledate" time_format:"2006-01-02"`
	CheckOut time.Time `form:"check_out" binding:"required,gtfield=CheckIn,bookabledate" time_format:"2006-01-02"`
}
var bookableDate validator.Func = func(fl validator.FieldLevel) bool {
	date, ok := fl.Field().Interface().(time.Time)
	if ok {
		today := time.Now()
		if today.After(date) {
			return false
		}
	}
	return true
}

func getBookable(c *gin.Context) {
	var b Booking
	if err := c.ShouldBindWith(&b, binding.Query); err == nil {
		c.JSON(http.StatusOK, gin.H{"message": "Booking dates are valid!"})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
	}
}
func main(){
if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("bookabledate", bookableDate)
	}
}
// curl "localhost:8085/bookable?check_in=2018-04-16&check_out=2018-04-17"
// {"message":"Booking dates are valid!"}
```

### 设置/获取 cookie

获取： `cookie, err := c.Cookie("gin_cookie")`
设置：`c.SetCookie("gin_cookie", "test", 3600, "/", "localhost", false, true)`

### 路由参数

```go
// 此 handler 将匹配 /user/john 但不会匹配 /user/ 或者 /user
router.GET("/user/:name", func(c *gin.Context) {
	name := c.Param("name")
	c.String(http.StatusOK, "Hello %s", name)
})
// 此 handler 将匹配 /user/john/ 和 /user/john/send
// 如果没有其他路由匹配 /user/john，它将重定向到 /user/john/
router.GET("/user/:name/*action", func(c *gin.Context) {
	name := c.Param("name")
	action := c.Param("action")
	message := name + " is " + action
	c.String(http.StatusOK, message)
})
```

### 路由组

```go
v1 := router.Group("/v1")
{
	v1.POST("/login", loginEndpoint)
	v1.POST("/submit", submitEndpoint)
	v1.POST("/read", readEndpoint)
}
```

### 重定向

HTTP 重定向 c.Redirect

```go
r.GET("/test", func(c *gin.Context) {
	c.Redirect(http.StatusMovedPermanently, "http://www.google.com/")
})
```

路由重定向 r.HandleContext

```go
r.GET("/test", func(c *gin.Context) {
    c.Request.URL.Path = "/test2"
    r.HandleContext(c)
})
```
