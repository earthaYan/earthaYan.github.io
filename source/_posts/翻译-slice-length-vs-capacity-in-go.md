---
title: 翻译-slice-length-vs-capacity-in-go
date: 2022-11-25 16:43:54
tags: [翻译, Go]
categories: 翻译
---

原文地址：https://teivah.medium.com/slice-length-vs-capacity-in-go-af71a754b7d8

# Go 语言中的切片 length 和 capacity

<b>长话短说</b>:切片长度是指切片中可访问元素的数量,而切片容量是指从切片第一个元素开始,数组中元素的数量。

---

Go 开发者混淆或者没有完全理解切片 length 和 capacity 的现象非常普遍。理解这两个概念有利于高效地处理一些核心操作,比如初始化切片,使用 append 添加元素,复制,截取。而这种错误理解会导致切片滥用甚至内存泄漏。

在 Go 语言中, slice 是由数组返回的。这意味着切片的数据是持久化的存在一个数组形式的数据结构中。如果数组满了，切片可以处理添加元素的逻辑,或者如果数组几乎是空的话,切片也可以处理缩小数组的逻辑。

在计算机内部, 切片包含一个指向数组的指针,一个 length 属性和一个 capacity 属性。length 是切片包含的元素个数,而 capacity 是从切片第一个元素开始计算的后备数组的元素个数。让我们通过一些例子来让事情更清晰一些。首先通过给定的 length 和 capacity 初始化切片：

```go
s := make([]int, 3, 6)  /// length 3, 容量 6 的切片
```

代表 length 的第一个参数是必须的，但是代表 capacity 的第二个参数是可选参数。图 1 展示了这段代码在内存中的执行结果。

{% asset_img slice.webp 图1-一个长度3，容量6的切片 %}

这个例子里,`make` 创建了一个 6(capacity) 个元素的数组。但是因为 length 被设置为 3, 所以 Go 只初始化了前 3 个元素。而且由于 slice 被设置为 `[]int` 类型，所以前三个元素的初始值被设置为 `int` 的零值: 0。灰色元素是已经分配但还没被使用。

我们打印这个切片,可以得到 length 范围内的元素: `[0,0,0]`。如果我们设置 `s[1]` 为 1,切片的第二个元素会被修改，但是不会影响它的 length 和 capacity。图 2 说明了这一点。

{% asset_img slice_update.webp 图2——更新切片第二个元素:s[1]=1 %}

但是, length 范围以外的元素即使已经在内存中分配了空间已经也是禁止访问的。举个例子, `s[4]=0` 就会引发下面的报错:

> panic: runtime error: index out of range [4] with length 3

那我们怎样使用切片的剩余空间呢?答案是通过内置的 `append` 方法:

```go
s = append(s, 2)
```

这行代码会追加一个新的元素到已经存在的 `s` 切片。如图 3 所示,他会使用第一个灰色元素(已经被分配空间但还未使用)来存储元素 `2`

{% asset_img slice_3.webp 图3——追加元素到s %}

此时切片的 length 会从 3 更新到 4,因为切片现在包含了 4 个元素。如果我们现在再追加 3 个元素,让背后的数组不够大的话会发生什么呢?

```go
s=append(s,3,4,5)
fmt.Println(s)
```

运行这段代码,我们看到切片依然能够处理我们的请求:

> [0 1 0 2 3 4 5]

数组是大小固定的结构,所以只能存储新元素到 4 。当我们想要插入元素 5 的时候,数组已经满了:此时 Go 会在内部另外创建一个数组：capacity 是原来的两倍,拷贝原数组中的所有元素,然后插入元素 5。图 4 展示了这个过程。

{% asset_img new.webp 图4——初始数组已满,GO创建了另一个数组并复制了所有的元素 %}

切片现在指向了新的后备数组。那之前的后备数组会发生什么呢?如果堆中分配了空间,且它不再被引用,那么最终会被垃圾收集器(GC)释放。(我们在 #95 错误中讨论了堆内存:"[不理解栈和堆](https://livebook.manning.com/book/100-go-mistakes-and-how-to-avoid-them/chapter-12/240)",并且在 #99 错误中学习了 GC 是如何工作的。)

截取切片会发生什么呢?截取是在数组或切片执行的操作,提供了半开区间范围。索引 1 是被包含的,而索引 2 是不被包含的。接下来的例子展示了这个影响，图 5 展示了内存中的结果：

```go
s1 := make([]int,3,6)
s2 := s1[1:3] //截取自索引1~3
```

{% asset_img slicing.webp 图5——s1和s2以不同的length和capacity引用了同一个后备数组%}

首先 `s1` 作为 length 3 和 capacity 6 的切片被创建。当通过截取 `s1` 创建 `s2` 时,两个切片引用了同一个后备数组。但是 `s2` 是从索引 1 开始的。因此它的 length 和 capacity 和 s1 是不一样的(length 等于 2,capacity 为 5)。如果我们修改 `s1[0]` 或者 `s2[0]`,这个修改是作用域同一个数组的,因此会如图 6 所示在两个切片中都是可见的。
{%asset_img visible_change.webp 图6——因为s1和s2共用一个后备数组，所以修改一个元素会使得两个切片都会产生变化%}

现在如果我们追加一个元素到 `s2` 会发生什么呢?接下来的代码也会修改 `s1` 么?

```go
s2 = append(s2, 2)
```

共享的后备数组会被修改,但是只有 `s2` 的 length 变了。图 7 展示了追加元素到 `s2` 的结果。

{%asset_img append.webp 图7——追加一个元素到s2 %}

`s1` 仍然是一个 length 为 3,capacity 为 6 的切片。因此如果打印 `s1` 和 `s2`,添加的元素只在 `s2`中可见：

> s1=[0 1 0], s2=[1 0 2]

理解这个行为非常重要，这样我们在使用 append 的时候不会做出错误的假设。

【注意】：在这些例子中,后备数组都是内部创建, GO 开发者不能直接获取。唯一的例外是：切片是从对现有数组进行切片创建的。

最后需要注意的一点是:假使我们一直追加元素到 s2 到后备数组变满会怎么样呢?就智能内存而言状态会是什么样? 让我们再添加 3 个元素，这样后备数组就不会有剩余的容量了：

```go
s2 = append(s2, 3)
s2 = append(s2, 4) // At this stage, the backing is already full
s2 = append(s2, 5)
```

这段代码会使得 GO 创建另一个后备数组。图 8 展示了内存中的结果。

{% asset_img figure8.webp 图8——向s2追加元素直至后备元素没有剩余空间%}

此时 s1 和 s2 指向了两个不同的数组。因为 s1 依旧 length 为 3,capacity 为 6,仍然有可用的缓存空间，所以它还是引用原来的数组。同时，新的后备数组通过从 s2 的第一个索引开始复制原数组创建。这就是为什么新数组从元素 1 而不是从元素 0 开始。

## 总结

总的来说, slice length 是切片中可用元素的个数,而 slice capacity 是后备数组中元素个数。向一个满切片(length == capacity) 添加元素会创建一个新后备数组,这个数组拥有新的 capacity,然后从之前的数组中复制所有元素，修改切片指针指向新的数组。
